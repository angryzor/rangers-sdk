#pragma once

namespace heur::rfl {
    struct DecoConfigParam {
        csl::ut::Color8 clientColor;
        uint8_t windowAlpha;
        csl::ut::Color8 startGradationGuideColor;
        csl::ut::Color8 endGradationGuideColor;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DecoConfigParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DecoConfigParam* pInstance);
        static void Clean(DecoConfigParam* pInstance);
    };
}

namespace heur::rfl {
    struct DecoBlurParam {
        int32_t radius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DecoBlurParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DecoBlurParam* pInstance);
        static void Clean(DecoBlurParam* pInstance);
    };
}

namespace heur::rfl {
    struct DecoGradationParam {
        enum class Orientation : int8_t {
            ORIENTATION_NONE = 0,
            ORIENTATION_HORIZONTAL = 1,
            ORIENTATION_VERTICAL = 2,
            ORIENTATION_DIAGONAL = 3,
        };

        Orientation orientation;
        int8_t srcPosX;
        int8_t srcPosY;
        int8_t dstPosX;
        int8_t dstPosY;
        csl::ut::Color8 srcColor;
        csl::ut::Color8 dstColor;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DecoGradationParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DecoGradationParam* pInstance);
        static void Clean(DecoGradationParam* pInstance);
    };
}

namespace heur::rfl {
    struct DecoDropShadowParam {
        csl::ut::Color8 color;
        uint8_t size;
        uint8_t spread;
        int8_t distanceX;
        int8_t distanceY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DecoDropShadowParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DecoDropShadowParam* pInstance);
        static void Clean(DecoDropShadowParam* pInstance);
    };
}

namespace heur::rfl {
    struct DecoRimParam {
        csl::ut::Color8 color;
        int32_t thickness;
        int32_t offsetX;
        int32_t offsetY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DecoRimParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DecoRimParam* pInstance);
        static void Clean(DecoRimParam* pInstance);
    };
}

namespace heur::rfl {
    struct DecoPassParam {
        heur::rfl::DecoDropShadowParam dropShadow;
        heur::rfl::DecoRimParam rim;
        heur::rfl::DecoGradationParam gradation;
        heur::rfl::DecoBlurParam blur;
        bool avoidEdgeArtifact;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DecoPassParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DecoPassParam* pInstance);
        static void Clean(DecoPassParam* pInstance);
    };
}

namespace heur::rfl {
    struct DecoTechParam {
        enum class DecoLayerBlendOp : int8_t {
            DECO_LAYER_BLEND_OP_BLEND = 0,
            DECO_LAYER_BLEND_OP_SUBTRACT_ALPHA = 1,
        };

        csl::ut::VariableString name;
        csl::ut::Color8 fontColor;
        heur::rfl::DecoGradationParam fontGradParam;
        DecoLayerBlendOp layerBlendOp;
        int32_t numPasses;
        heur::rfl::DecoPassParam passParams[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DecoTechParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DecoTechParam* pInstance);
        static void Clean(DecoTechParam* pInstance);
    };
}

namespace heur::rfl {
    struct DecoTechParams {
        heur::rfl::DecoTechParam params[512];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DecoTechParams* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DecoTechParams* pInstance);
        static void Clean(DecoTechParams* pInstance);
    };
}

namespace heur::rfl {
    struct Agent {
        float radius;
        float height;
        float maxClimb;
        float maxSlope;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Agent* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Agent* pInstance);
        static void Clean(Agent* pInstance);
    };
}

namespace heur::rfl {
    struct DetailMesh {
        float sampleDistance;
        float sampleMaxError;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DetailMesh* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DetailMesh* pInstance);
        static void Clean(DetailMesh* pInstance);
    };
}

namespace heur::rfl {
    struct OffMeshLinkElement {
        enum class OffMeshLinkDirection : uint8_t {
            OffMeshLinkUnidirectional = 0,
            OffMeshLinkBidirectional = 1,
        };

        csl::math::Vector3 source;
        csl::math::Vector3 destination;
        float radius;
        uint16_t flags;
        uint8_t area;
        OffMeshLinkDirection direction;
        uint32_t userID;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OffMeshLinkElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OffMeshLinkElement* pInstance);
        static void Clean(OffMeshLinkElement* pInstance);
    };
}

namespace heur::rfl {
    struct OffMeshLinkParameter {
        csl::ut::MoveArray<heur::rfl::OffMeshLinkElement> elements;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OffMeshLinkParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OffMeshLinkParameter* pInstance);
        static void Clean(OffMeshLinkParameter* pInstance);
    };
}

namespace heur::rfl {
    struct Filtering {
        bool lowHangingObstacles;
        bool ledgeSpans;
        bool walkableLowHeightSpans;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Filtering* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Filtering* pInstance);
        static void Clean(Filtering* pInstance);
    };
}

namespace heur::rfl {
    struct World {
        csl::math::Vector3 aabbMin;
        csl::math::Vector3 aabbMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(World* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(World* pInstance);
        static void Clean(World* pInstance);
    };
}

namespace heur::rfl {
    struct Rasterization {
        float voxelSize;
        float voxelHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Rasterization* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Rasterization* pInstance);
        static void Clean(Rasterization* pInstance);
    };
}

namespace heur::rfl {
    struct Region {
        int32_t minArea;
        int32_t mergeArea;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Region* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Region* pInstance);
        static void Clean(Region* pInstance);
    };
}

namespace heur::rfl {
    struct Partitioning {
        enum class Partition : uint8_t {
            Watershed = 0,
            Monotone = 1,
            Layers = 2,
        };

        Partition type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Partitioning* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Partitioning* pInstance);
        static void Clean(Partitioning* pInstance);
    };
}

namespace heur::rfl {
    struct Polygonization {
        float edgeMaxLength;
        float maxSimplificationError;
        int32_t vertsPerPoly;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Polygonization* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Polygonization* pInstance);
        static void Clean(Polygonization* pInstance);
    };
}

namespace heur::rfl {
    struct Tiling {
        float size;
        int32_t maxTiles;
        bool cache;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Tiling* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Tiling* pInstance);
        static void Clean(Tiling* pInstance);
    };
}

namespace heur::rfl {
    struct NavMeshParameter {
        heur::rfl::World world;
        heur::rfl::Rasterization rasterization;
        heur::rfl::Agent agent;
        heur::rfl::Region region;
        heur::rfl::Partitioning partitioning;
        heur::rfl::Filtering filtering;
        heur::rfl::Polygonization polygonization;
        heur::rfl::DetailMesh detailMesh;
        heur::rfl::Tiling tiling;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NavMeshParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NavMeshParameter* pInstance);
        static void Clean(NavMeshParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StatsDataValue {
        enum class StatsType : int32_t {
            TYPE_INVALID = 0,
            TYPE_UINT64 = 1,
            TYPE_UINT32 = 2,
            TYPE_SINT32 = 3,
            TYPE_FLOAT = 4,
        };

        StatsType type;
        uint64_t value;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StatsDataValue* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StatsDataValue* pInstance);
        static void Clean(StatsDataValue* pInstance);
    };
}

namespace heur::rfl {
    struct StatsDataContainer {
        csl::ut::MoveArray<heur::rfl::StatsDataValue> data;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StatsDataContainer* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StatsDataContainer* pInstance);
        static void Clean(StatsDataContainer* pInstance);
    };
}

namespace hh::needle {
    struct FxSunPosAngle {
        float azimuthAngle;
        float elevationAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSunPosAngle* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSunPosAngle* pInstance);
        static void Clean(FxSunPosAngle* pInstance);
    };
}

namespace hh::needle {
    struct FxSunPosEarth {
        float azimuthAngle;
        float latitude;
        float longitude;
        int32_t month;
        int32_t day;
        float time;
        bool enableAnimation;
        float animationSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSunPosEarth* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSunPosEarth* pInstance);
        static void Clean(FxSunPosEarth* pInstance);
    };
}

namespace hh::needle {
    struct FxSun {
        enum class SunPosType : int8_t {
            SUN_POS_TYPE_NONE = 0,
            SUN_POS_TYPE_ANGLE = 1,
            SUN_POS_TYPE_EARTH = 2,
        };

        float solarRadiusScale;
        SunPosType sunPosType;
        hh::needle::FxSunPosAngle posTypeAngle;
        hh::needle::FxSunPosEarth posTypeEarth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSun* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSun* pInstance);
        static void Clean(FxSun* pInstance);
    };
}

namespace hh::needle {
    struct FxMoon {
        enum class MoonPosType : int8_t {
            MOON_POS_TYPE_NONE = 0,
            MOON_POS_TYPE_INV_SUN = 1,
            MOON_POS_TYPE_EARTH = 2,
        };

        MoonPosType moonPosType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxMoon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxMoon* pInstance);
        static void Clean(FxMoon* pInstance);
    };
}

namespace hh::needle {
    struct FxSkyCommon {
        enum class SkyModel : int8_t {
            BRUNETON = 0,
            SEBASTIEN = 1,
        };

        SkyModel skyModel;
        float illuminanceScale;
        bool enableScattering;
        float scatteringRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSkyCommon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSkyCommon* pInstance);
        static void Clean(FxSkyCommon* pInstance);
    };
}

namespace hh::needle {
    struct FxBrunetonSkyNight {
        float lunarIntensityInSky;
        float starIntensityInSky;
        float lunarIntensityInCloud;
        float lunarIntensity;
        float skyIntensity;
        csl::ut::Color8 lunarLightColor;
        csl::math::Vector4 lunarLightColorOffset;
        float lunarLightPower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxBrunetonSkyNight* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxBrunetonSkyNight* pInstance);
        static void Clean(FxBrunetonSkyNight* pInstance);
    };
}

namespace hh::needle {
    struct FxBrunetonSky {
        float illuminanceScale;
        csl::ut::Color8 rayleighColor;
        csl::ut::Color8 lightColorScale;
        float miePhaseFunctionG;
        csl::ut::Color8 mieScatteringColor;
        float mieScatteringScale;
        csl::ut::Color8 mieAbsorptionColor;
        float mieAbsorptionScale;
        csl::ut::Color8 rayleighScatteringColor;
        float rayleighScatteringScale;
        csl::ut::Color8 groundAlbedo;
        csl::ut::Color8 groundIrradianceScale;
        csl::ut::Color8 cubemapColorScale;
        float cubemapColorAngleRatio;
        bool enableScattering;
        float scatteringRatio;
        hh::needle::FxBrunetonSkyNight night;
        bool enableLimitY;
        float debugSkyCubeIntensity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxBrunetonSky* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxBrunetonSky* pInstance);
        static void Clean(FxBrunetonSky* pInstance);
    };
}

namespace hh::needle {
    struct FxSebastienSky {
        float miePhaseFunctionG;
        csl::ut::Color8 mieScatteringColor;
        csl::math::Vector4 mieScatteringColorOffset;
        float mieScatteringScale;
        csl::ut::Color8 mieAbsorptionColor;
        csl::math::Vector4 mieAbsorptionColorOffset;
        float mieAbsorptionScale;
        csl::ut::Color8 rayleighScatteringColor;
        csl::math::Vector4 rayleighScatteringColorOffset;
        float rayleighScatteringScale;
        csl::ut::Color8 groundAlbedo;
        csl::math::Vector4 groundAlbedoOffset;
        bool enableGround;
        int32_t numScatteringOrder;
        bool enableScattering;
        bool enableLimitY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSebastienSky* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSebastienSky* pInstance);
        static void Clean(FxSebastienSky* pInstance);
    };
}

namespace hh::needle {
    struct FxCloudProcedural {
        csl::math::Vector3 uvScale;
        csl::math::Vector3 colorGamma;
        csl::math::Vector3 colorScale;
        csl::math::Vector3 colorOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCloudProcedural* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCloudProcedural* pInstance);
        static void Clean(FxCloudProcedural* pInstance);
    };
}

namespace hh::needle {
    struct FxCloudBlendParameter {
        bool enable;
        float probability;
        float cloudiness;
        hh::needle::FxCloudProcedural proceduralCloud;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCloudBlendParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCloudBlendParameter* pInstance);
        static void Clean(FxCloudBlendParameter* pInstance);
    };
}

namespace heur::rfl {
    struct FxCloudParameter {
        bool enable;
        bool enableAnimation;
        float animationFrame;
        float animationSpeed;
        float animationAngle;
        float animationSpeedCirrus;
        float animationAngleCirrus;
        float skyHorizonOffset;
        float cloudStartHeight;
        float cloudCoverageSpeed;
        float cloudTypeSpeed;
        float cloudWetnessSpeed;
        float miePhaseFunctionG;
        float silverIntensity;
        float silverSpread;
        float scale;
        float density;
        float densityThreshold;
        csl::ut::Color8 cloudsExtinctionColor1;
        csl::math::Vector4 cloudsExtinctionColor1Offset;
        csl::ut::Color8 cloudsExtinctionColor2;
        csl::math::Vector4 cloudsExtinctionColor2Offset;
        csl::ut::Color8 cloudsExtinctionColor3;
        csl::math::Vector4 cloudsExtinctionColor3Offset;
        float cloudExtinctionBlend;
        bool enableShadow;
        int32_t shadowCoverage;
        float shadowValueMin;
        hh::needle::FxCloudBlendParameter blendParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCloudParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCloudParameter* pInstance);
        static void Clean(FxCloudParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxCrepuscularRay {
        bool enable;
        float density;
        float decay;
        float weight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCrepuscularRay* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCrepuscularRay* pInstance);
        static void Clean(FxCrepuscularRay* pInstance);
    };
}

namespace hh::needle {
    struct FxManualHeightFog {
        csl::math::Vector3 sunColor;
        csl::math::Vector3 ambColor;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxManualHeightFog* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxManualHeightFog* pInstance);
        static void Clean(FxManualHeightFog* pInstance);
    };
}

namespace hh::needle {
    struct FxHeightFog {
        bool enable;
        bool enableFogMap;
        float heightScale;
        float distanceOffset;
        float distanceScale;
        csl::math::Vector3 rayleighScale;
        csl::math::Vector3 mieScale;
        float noiseBlend;
        float noiseScale;
        float noiseDistance;
        float animationSpeed;
        float animationAngle;
        bool isAtmospheric;
        hh::needle::FxManualHeightFog manualFog;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxHeightFog* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxHeightFog* pInstance);
        static void Clean(FxHeightFog* pInstance);
    };
}

namespace hh::needle {
    struct FxAtmosphereParameter {
        bool enable;
        hh::needle::FxSun sunParam;
        hh::needle::FxMoon moonParam;
        hh::needle::FxSkyCommon commonSkyParam;
        hh::needle::FxBrunetonSky brunetonSkyParam;
        hh::needle::FxSebastienSky sebastienSkyParam;
        heur::rfl::FxCloudParameter cloudParam;
        hh::needle::FxCrepuscularRay crepuscularRayParam;
        hh::needle::FxHeightFog heightFogParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxAtmosphereParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxAtmosphereParameter* pInstance);
        static void Clean(FxAtmosphereParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxCloudShadowParameter {
        bool enableShadow;
        int32_t shadowCoverage;
        float shadowValueMin;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCloudShadowParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCloudShadowParameter* pInstance);
        static void Clean(FxCloudShadowParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxDensityDebugParameter {
        bool underSelect;
        float factor;
        float unit[32];
        int8_t chunk[32];
        float lodAddition;
        int32_t chunkAddition;
        float drawLimitLenght;
        bool drawCallReduction;
        bool enableDither;
        int32_t ditherGrass;
        int32_t ditherOther;
        int32_t ditherPreComputeGrass;
        int32_t ditherPreComputeOther;
        int32_t computeMode;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDensityDebugParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDensityDebugParameter* pInstance);
        static void Clean(FxDensityDebugParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxDensityLodParameter {
        float lodRatio;
        float lodRise;
        float lodDecrease;
        float lodThreshold;
        bool lodFadeEnable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDensityLodParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDensityLodParameter* pInstance);
        static void Clean(FxDensityLodParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxDensityParameter {
        enum class PlacementType : int8_t {
            CirclePacking = 0,
            RandomPos = 1,
            PT_COUNT = 2,
        };

        enum class ShadowCullingType : int8_t {
            Normal = 0,
            AabbUpScale2 = 1,
            ShadowFrustum = 2,
        };

        bool enable;
        bool precomputeEnable;
        bool cameraUpdate;
        PlacementType placement;
        float placementScale;
        bool alphaEnable;
        float alphaThreshold;
        float alphaScale;
        bool complementEnable;
        bool disableCut;
        ShadowCullingType shadowCulling;
        bool occlusionCulling;
        float occlusionSize;
        float occlusionShadowSize;
        float occlusionBias;
        hh::needle::FxDensityLodParameter lodParam;
        bool angleCulling;
        float angleCullingParam;
        hh::needle::FxDensityDebugParameter debugParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDensityParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDensityParameter* pInstance);
        static void Clean(FxDensityParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxDensityWindParameter {
        float windDir;
        float windPower;
        float windLenght;
        float windSpeed;
        float windRalenght;
        float windRaamp;
        float windRalevel;
        float windRtpower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDensityWindParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDensityWindParameter* pInstance);
        static void Clean(FxDensityWindParameter* pInstance);
    };
}

namespace hh::gfx {
    struct FxDentParameter {
        bool enable;
        float simRadius;
        float dentDepth;
        float normalIntensity;
        float edgeBulge;
        float fade;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDentParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDentParameter* pInstance);
        static void Clean(FxDentParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxLightScatteringParameter {
        bool enable;
        csl::math::Vector3 color;
        float inScatteringScale;
        csl::math::Vector3 betaRayleigh;
        float betaMie;
        float g;
        float znear;
        float zfar;
        float depthScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxLightScatteringParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxLightScatteringParameter* pInstance);
        static void Clean(FxLightScatteringParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxCyberNoiseEffectParameter {
        bool enable;
        float tileX;
        float tileY;
        float tileScrollSpeed;
        float noiseScrollSpeed;
        float thresholdSpeed;
        float thredholdMin;
        float thredholdMax;
        float selectRate;
        float scanLineRSpeed;
        float scanLineRBlend;
        float scanLineGSpeed;
        float scanLineGBlend;
        float rgbLineScale;
        float rgbLineBlend;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCyberNoiseEffectParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCyberNoiseEffectParameter* pInstance);
        static void Clean(FxCyberNoiseEffectParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxCyberNPCSSEffectRenderParameter {
        bool enable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCyberNPCSSEffectRenderParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCyberNPCSSEffectRenderParameter* pInstance);
        static void Clean(FxCyberNPCSSEffectRenderParameter* pInstance);
    };
}

namespace hh::gfx {
    struct FxRenderTargetSetting {
        enum class DOFRenderTargetSize : int32_t {
            DOF_RTSIZE_FULL_SCALE = 0,
            DOF_RTSIZE_HALF_SCALE = 1,
            DOF_RTSIZE_QUARTER_SCALE = 2,
            DOF_RTSIZE_COUNT = 3,
            DOF_RTSIZE_INVALID = 3,
        };

        DOFRenderTargetSize dofRenderTargetScale;
        int32_t shadowMapWidth;
        int32_t shadowMapHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxRenderTargetSetting* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxRenderTargetSetting* pInstance);
        static void Clean(FxRenderTargetSetting* pInstance);
    };
}

namespace heur::rfl {
    struct HourMinuteData {
        uint8_t hour;
        uint8_t minute;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HourMinuteData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HourMinuteData* pInstance);
        static void Clean(HourMinuteData* pInstance);
    };
}

namespace heur::rfl {
    struct GlobalLightAngleLimit {
        enum class Type : int8_t {
            NONE = 0,
            SHADOW_LIGHT = 1,
            SHADOW_AND_DISTANT_LIGHT = 2,
        };

        Type type;
        float minLightElevationAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GlobalLightAngleLimit* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GlobalLightAngleLimit* pInstance);
        static void Clean(GlobalLightAngleLimit* pInstance);
    };
}

namespace heur::rfl {
    struct GlobalLightParameter {
        bool enable;
        heur::rfl::GlobalLightAngleLimit limit;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GlobalLightParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GlobalLightParameter* pInstance);
        static void Clean(GlobalLightParameter* pInstance);
    };
}

namespace hh::needle {
    struct DebugScreenOption {
        enum class ChannelMode : int8_t {
            CHANNELMODE_RGB = 0,
            CHANNELMODE_RRR = 1,
            CHANNELMODE_GGG = 2,
            CHANNELMODE_BBB = 3,
            CHANNELMODE_AAA = 4,
            CHANNELMODE_RG = 5,
            CHANNELMODE_BA = 6,
        };

        enum class DebugScreenType : int8_t {
            DEBUG_SCREEN_GBUFFER0 = 0,
            DEBUG_SCREEN_GBUFFER1 = 1,
            DEBUG_SCREEN_GBUFFER2 = 2,
            DEBUG_SCREEN_GBUFFER3 = 3,
            DEBUG_SCREEN_DEPTHBUFFER = 4,
            DEBUG_SCREEN_CSM0 = 5,
            DEBUG_SCREEN_CSM1 = 6,
            DEBUG_SCREEN_CSM2 = 7,
            DEBUG_SCREEN_CSM3 = 8,
            DEBUG_SCREEN_HDR = 9,
            DEBUG_SCREEN_BLOOM = 10,
            DEBUG_SCREEN_RLR = 11,
            DEBUG_SCREEN_GODRAY = 12,
            DEBUG_SCREEN_SSAO = 13,
            DEBUG_SCREEN_CSM_CACHE0 = 14,
            DEBUG_SCREEN_CSM_CACHE1 = 15,
            DEBUG_SCREEN_CSM_CACHE2 = 16,
            DEBUG_SCREEN_CSM_CACHE3 = 17,
            DEBUG_SCREEN_CSM_CACHE4 = 18,
            DEBUG_SCREEN_CSM_CACHE5 = 19,
            DEBUG_SCREEN_CUSTOM0 = 20,
            DEBUG_SCREEN_CUSTOM1 = 21,
            DEBUG_SCREEN_CUSTOM2 = 22,
            DEBUG_SCREEN_CUSTOM3 = 23,
        };

        enum class ErrorCheckType : int8_t {
            ERROR_CHECK_NONE = 0,
            ERROR_CHECK_NAN = 1,
            ERROR_CHECK_ALBEDO = 2,
            ERROR_CHECK_NORMAL = 3,
        };

        enum class VisualizeMode : int8_t {
            DEFAULT = 0,
            HEATMAP_TYPE0 = 1,
            HEATMAP_TYPE1 = 2,
            HEATMAP_TYPE2 = 3,
            VECTOR2D_TYPE0 = 4,
            VECTOR2D_TYPE1 = 5,
            VECTOR2D_TYPE2 = 6,
        };

        bool enable;
        bool fullScreen;
        ChannelMode channelMode;
        float min;
        float max;
        int32_t renderTargetType;
        int32_t depthTargetType;
        DebugScreenType screenType;
        ErrorCheckType errorCheck;
        VisualizeMode visualizeMode;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DebugScreenOption* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DebugScreenOption* pInstance);
        static void Clean(DebugScreenOption* pInstance);
    };
}

namespace heur::rfl {
    struct GlobalUserParamOption {
        bool enable;
        csl::math::Vector4 value;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GlobalUserParamOption* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GlobalUserParamOption* pInstance);
        static void Clean(GlobalUserParamOption* pInstance);
    };
}

namespace hh::needle {
    struct FxRenderOption {
        enum class DebugViewType : int8_t {
            DEBUG_VIEW_DEFAULT = 0,
            DEBUG_VIEW_DIR_DIFFUSE = 1,
            DEBUG_VIEW_DIR_SPECULAR = 2,
            DEBUG_VIEW_AMB_DIFFUSE = 3,
            DEBUG_VIEW_AMB_SPECULAR = 4,
            DEBUG_VIEW_ONLY_IBL = 5,
            DEBUG_VIEW_ONLY_IBL_SURF_NORMAL = 6,
            DEBUG_VIEW_SHADOW = 7,
            DEBUG_VIEW_WHITE_ALBEDO = 8,
            DEBUG_VIEW_WHITE_ALBEDO_NO_AO = 9,
            DEBUG_VIEW_USER0 = 10,
            DEBUG_VIEW_USER1 = 11,
            DEBUG_VIEW_USER2 = 12,
            DEBUG_VIEW_USER3 = 13,
            DEBUG_VIEW_ALBEDO = 14,
            DEBUG_VIEW_ALBEDO_CHECK_OUTLIER = 15,
            DEBUG_VIEW_OPACITY = 16,
            DEBUG_VIEW_NORMAL = 17,
            DEBUG_VIEW_ROUGHNESS = 18,
            DEBUG_VIEW_AMBIENT = 19,
            DEBUG_VIEW_CAVITY = 20,
            DEBUG_VIEW_REFLECTANCE = 21,
            DEBUG_VIEW_METALLIC = 22,
            DEBUG_VIEW_LOCAL_LIGHT = 23,
            DEBUG_VIEW_SCATTERING_FEX = 24,
            DEBUG_VIEW_SCATTERING_LIN = 25,
            DEBUG_VIEW_SSAO = 26,
            DEBUG_VIEW_RLR = 27,
            DEBUG_VIEW_IBL_DIFFUSE = 28,
            DEBUG_VIEW_IBL_SPECULAR = 29,
            DEBUG_VIEW_ENV_BRDF = 30,
            DEBUG_VIEW_WORLD_POSITION = 31,
            DEBUG_VIEW_SHADING_MODEL_ID = 32,
            DEBUG_VIEW_IBL_CAPTURE = 33,
            DEBUG_VIEW_IBL_SKY_TERRAIN = 34,
            DEBUG_VIEW_WRITE_DEPTH_TO_ALPHA = 35,
            DEBUG_VIEW_SMOOTHNESS = 36,
            DEBUG_VIEW_OCCLUSION_CAPSULE = 37,
            DEBUG_VIEW_PROBE = 38,
            DEBUG_VIEW_COUNT = 39,
            DEBUG_VIEW_INVALID = 39,
        };

        enum class LocalLightCullingType : int8_t {
            LOCAL_LIGHT_CULLING_TYPE_NONE = 0,
            LOCAL_LIGHT_CULLING_TYPE_CPU_TILE = 1,
            LOCAL_LIGHT_CULLING_TYPE_GPU_TILE = 2,
            LOCAL_LIGHT_CULLING_TYPE_GPU_CLUSTER = 3,
            LOCAL_LIGHT_CULLING_TYPE_COUNT = 4,
            LOCAL_LIGHT_CULLING_TYPE_DEFAULT = 0,
        };

        enum class TextureViewType : int8_t {
            TEXTURE_VIEW_NONE = 0,
            TEXTURE_VIEW_DEPTH = 1,
            TEXTURE_VIEW_LUMINANCE = 2,
            TEXTURE_VIEW_DOF_BOKEH = 3,
            TEXTURE_VIEW_DOF_BOKEH_NEAR = 4,
            TEXTURE_VIEW_SSAO_SOURCE = 5,
            TEXTURE_VIEW_DOWNSAMPLE = 6,
            TEXTURE_VIEW_COUNT = 7,
        };

        enum class AmbientSpecularType : int8_t {
            AMBIENT_SPECULAR_NONE = 0,
            AMBIENT_SPECULAR_SG = 1,
            AMBIENT_SPECULAR_IBL = 2,
            AMBIENT_SPECULAR_BLEND = 3,
        };

        enum class DebugScreenView : int8_t {
            DEBUG_SCREEN_VIEW_DEFAULT = 0,
            DEBUG_SCREEN_VIEW_ALL_ENABLE = 1,
            DEBUG_SCREEN_VIEW_ALL_DISABLE = 2,
        };

        DebugViewType debugViewType;
        bool clearRenderTarget;
        bool enableDrawCubeProbe;
        heur::rfl::GlobalLightParameter globalLight;
        bool enablePointLight;
        bool enableEffectDeformation;
        bool enablePreMergeIBL;
        bool enableLitePostEffect;
        LocalLightCullingType localLightCullingType;
        float localLightScale;
        float shadowIBLAttenuation;
        int32_t maxCubeProbe;
        bool debugEnableDrawLocalLight;
        TextureViewType debugTextureViewType;
        bool debugEnableOutputTextureView;
        int32_t debugScreenshotResolutionHeight;
        float debugScreenshotDepthNear;
        float debugScreenshotDepthFar;
        AmbientSpecularType debugAmbientSpecularType;
        bool debugEnableSGGIVer2nd;
        bool debugEnableAOGI;
        hh::needle::DebugScreenOption debugScreen[16];
        DebugScreenView debugScreenView;
        bool enableMSAA;
        bool debugEnableDrawFrustumCullFrustum;
        bool debugEnableFixFrustumCullFrustum;
        int32_t debugDrawFrustumCullGroupSettingIndex;
        bool debugEnableOcclusionCullingView;
        int32_t debugOccluderVertThreshold;
        heur::rfl::GlobalUserParamOption globalUserParam[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxRenderOption* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxRenderOption* pInstance);
        static void Clean(FxRenderOption* pInstance);
    };
}

namespace hh::needle {
    struct FxSGGIParameter {
        float sgStartSmoothness;
        float sgEndSmoothness;
        float doStartSmoothness;
        float doEndSmoothness;
        float doOffset;
        float aoOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSGGIParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSGGIParameter* pInstance);
        static void Clean(FxSGGIParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxRLRParameter {
        bool enable;
        bool traceSky;
        bool useTrans;
        bool usePenet;
        bool useQuat;
        bool useNormal;
        float rayMarchingCount;
        float planeNormalDist;
        float traceThreshold;
        float resolveReproj;
        float overrideRatio;
        float maxRoughness;
        float roughnessLevel;
        float uvOffsetScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxRLRParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxRLRParameter* pInstance);
        static void Clean(FxRLRParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSSGIDebugParameter {
        bool useDenoise;
        float rayLength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSSGIDebugParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSSGIDebugParameter* pInstance);
        static void Clean(FxSSGIDebugParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSSGIParameter {
        bool enable;
        float intensity;
        bool useAlbedo;
        bool useParameter;
        hh::needle::FxSSGIDebugParameter debugParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSSGIParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSSGIParameter* pInstance);
        static void Clean(FxSSGIParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxPlanarReflectionParameter {
        bool enable;
        csl::math::Vector4 plane;
        uint32_t width;
        uint32_t height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxPlanarReflectionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxPlanarReflectionParameter* pInstance);
        static void Clean(FxPlanarReflectionParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxBloomParameter {
        bool enable;
        bool fast;
        float bloomScale;
        float sampleRadiusScale;
        int32_t blurQuality;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxBloomParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxBloomParameter* pInstance);
        static void Clean(FxBloomParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxManualExposureParameter {
        float exposureValue;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxManualExposureParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxManualExposureParameter* pInstance);
        static void Clean(FxManualExposureParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxAutoExposureParameter {
        enum class LUMINANCE_RANGE : int8_t {
            LUMINANCE_RANGE_CLAMP = 0,
            LUMINANCE_RANGE_CUTOFF = 1,
            LUMINANCE_RANGE_CUTOFF_PCT_RATE = 2,
            LUMINANCE_RANGE_CUTOFF_PCT_AREA = 3,
        };

        float middleGray;
        float lumMax;
        float lumMin;
        float cutMax;
        float cutMin;
        float pctMax;
        float pctMin;
        float adaptedRatio;
        LUMINANCE_RANGE luminanceRangeType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxAutoExposureParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxAutoExposureParameter* pInstance);
        static void Clean(FxAutoExposureParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxCameraControlParameter {
        enum class Exposure : int8_t {
            EXPOSURE_MANUAL = 0,
            EXPOSURE_AUTO = 1,
        };

        Exposure exposureType;
        hh::needle::FxManualExposureParameter manualExposure;
        hh::needle::FxAutoExposureParameter autoExposure;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCameraControlParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCameraControlParameter* pInstance);
        static void Clean(FxCameraControlParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxToneMapParameterFilmic {
        float whitePoint;
        float toeStrength;
        float linearAngle;
        float linearStrength;
        float shoulderStrength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxToneMapParameterFilmic* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxToneMapParameterFilmic* pInstance);
        static void Clean(FxToneMapParameterFilmic* pInstance);
    };
}

namespace hh::needle {
    struct FxToneMapParameterGT {
        float maxDisplayBrightness;
        float contrast;
        float linearSectionStart;
        float linearSectionLength;
        float black;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxToneMapParameterGT* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxToneMapParameterGT* pInstance);
        static void Clean(FxToneMapParameterGT* pInstance);
    };
}

namespace hh::needle {
    struct FxToneMapParameter {
        enum class Tonemap : int8_t {
            TONEMAP_DISNEY = 0,
            TONEMAP_FILMIC = 1,
            TONEMAP_ACES = 2,
            TONEMAP_GT = 3,
        };

        Tonemap tonemapType;
        hh::needle::FxToneMapParameterFilmic tonemapParamFilmic;
        hh::needle::FxToneMapParameterGT tonemapParamGT;
        bool updateLuminance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxToneMapParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxToneMapParameter* pInstance);
        static void Clean(FxToneMapParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxColorContrastParameter {
        enum class LutIndex : int32_t {
            LUT_INDEX_DEFAULT = 0,
            LUT_INDEX_WB = 1,
            LUT_INDEX_USER_0 = 2,
            LUT_INDEX_USER_1 = 3,
            LUT_INDEX_USER_2 = 4,
            LUT_INDEX_USER_3 = 5,
            LUT_INDEX_USER_4 = 6,
            LUT_INDEX_USER_5 = 7,
            LUT_INDEX_COUNT = 8,
        };

        bool enable;
        float contrast;
        float dynamicRange;
        float crushShadows;
        float crushHilights;
        bool useLut;
        LutIndex lutIndex0;
        LutIndex lutIndex1;
        float blendRatio;
        float lutRatio;
        bool useHlsCorrection;
        float hlsHueOffset;
        float hlsLightnessOffset;
        float hlsSaturationOffset;
        int32_t hlsColorOffset[3];
        float hlsColorizeRate;
        float hlsColorizeHue;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxColorContrastParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxColorContrastParameter* pInstance);
        static void Clean(FxColorContrastParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxDOFParameter {
        enum class RenderTargetSize : int32_t {
            RTSIZE_FULL_SCALE = 0,
            RTSIZE_HALF_SCALE = 1,
            RTSIZE_QUARTER_SCALE = 2,
            RTSIZE_COUNT = 3,
            RTSIZE_INVALID = 3,
        };

        bool enable;
        bool useFocusLookAt;
        float foregroundBokehMaxDepth;
        float foregroundBokehStartDepth;
        float backgroundBokehStartDepth;
        float backgroundBokehMaxDepth;
        bool enableCircleDOF;
        float cocMaxRadius;
        float bokehRadiusScale;
        int32_t bokehSampleCount;
        float skyFocusDistance;
        float bokehBias;
        bool drawFocalPlane;
        RenderTargetSize rtScale;
        bool enableSWA;
        float swaFocus;
        float swaFocusRange;
        float swaNear;
        float swaFar;
        bool enableEnhancedForeBokeh;
        float foreBokehScale;
        float foreBokehMaxLuminance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDOFParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDOFParameter* pInstance);
        static void Clean(FxDOFParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxShadowMapParameter {
        enum class ShadowRenderingType : int8_t {
            SHADOW_RENDERING_TYPE_SHADOW_MAP = 0,
            SHADOW_RENDERING_TYPE_PLANAR_PROJECTION = 1,
            SHADOW_RENDERING_TYPE_PLANAR_PROJECTION_SHADOW_MAP = 2,
            SHADOW_RENDERING_TYPE_MULTI_SHADOW_MAP = 3,
            SHADOW_RENDERING_TYPE_COUNT = 4,
        };

        enum class ShadowFilter : int8_t {
            SHADOW_FILTER_POINT = 0,
            SHADOW_FILTER_PCF = 1,
            SHADOW_FILTER_PCSS = 2,
            SHADOW_FILTER_ESM = 3,
            SHADOW_FILTER_MSM = 4,
            SHADOW_FILTER_VSM_POINT = 5,
            SHADOW_FILTER_VSM_LINEAR = 6,
            SHADOW_FILTER_VSM_ANISO_2 = 7,
            SHADOW_FILTER_VSM_ANISO_4 = 8,
            SHADOW_FILTER_VSM_ANISO_8 = 9,
            SHADOW_FILTER_VSM_ANISO_16 = 10,
            SHADOW_FILTER_COUNT = 11,
            SHADOW_FILTER_VSM_FIRST = 5,
            SHADOW_FILTER_VSM_LAST = 10,
        };

        enum class ShadowRangeType : int8_t {
            SHADOW_RANGE_TYPE_CAMERA_LOOKAT = 0,
            SHADOW_RANGE_TYPE_POSITION_MANUAL = 1,
            SHADOW_RANGE_TYPE_FULL_MANUAL = 2,
            SHADOW_RANGE_TYPE_COUNT = 3,
            SHADOW_RANGE_TYPE_DEFAULT = 0,
        };

        enum class FitProjection : int8_t {
            FIT_PROJECTION_TO_CASCADES = 0,
            FIT_PROJECTION_TO_SCENE = 1,
            FIT_PROJECTION_TO_ROTATE_CASCADES = 2,
        };

        enum class FitNearFar : int8_t {
            FIT_NEARFAR_ZERO_ONE = 0,
            FIT_NEARFAR_AABB = 1,
            FIT_NEARFAR_SCENE_AABB = 2,
        };

        enum class PartitionType : int8_t {
            PARTITION_PSSM = 0,
            PARTITION_MANUAL = 1,
        };

        ShadowRenderingType renderingType;
        bool enable;
        ShadowFilter shadowFilter;
        ShadowRangeType shadowRangeType;
        FitProjection fitProjection;
        FitNearFar fitNearFar;
        PartitionType partitionType;
        float sceneRange;
        float sceneCenter[3];
        float manualLightPos[3];
        float pssmLambda;
        float cascadeOffset;
        int32_t cascadeLevel;
        float cascadeSplits[4];
        float cascadeBias[4];
        float bias;
        float offset;
        float normalBias;
        int32_t width;
        int32_t height;
        int32_t blurQuality;
        int32_t blurSize;
        float fadeoutDistance;
        float cascadeTransitionfadeDistance;
        bool enableCSMCache;
        float csmCacheMaxHeight;
        float csmCacheMinHeight;
        int32_t csmCacheMaxRenderPass;
        float csmCacheFixedFovy;
        float csmCacheLightDirectionThreshold;
        bool csmCacheParallaxCorrectionEnabled;
        float csmCacheParallaxCorrectionHorizontalBias;
        float csmCacheParallaxCorrectionVerticalBias;
        int32_t csmCacheFramesToRender[3];
        float csmCacheFadeLightElevationAngle;
        float csmCacheMinLightElevationAngle;
        csl::math::Matrix44 shadowCameraViewMatrix;
        csl::math::Matrix44 shadowCameraProjectionMatrix;
        float shadowCameraNearDepth;
        float shadowCameraFarDepth;
        float shadowCameraLookAtDepth;
        bool enableBackFaceShadow;
        bool enableShadowCamera;
        bool enableDrawSceneAABB;
        bool enableDrawShadowFrustum;
        bool enableDrawCascade;
        bool enableDrawCameraFrustum;
        bool enableDrawCSMCache;
        bool enableClearOnCSMCacheIsInvalidated;
        bool enablePauseCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxShadowMapParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxShadowMapParameter* pInstance);
        static void Clean(FxShadowMapParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxShadowHeightMapParameter {
        bool enable;
        float bias;
        float distanceFalloff;
        float heightFalloffMinHeight;
        float heightFalloffDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxShadowHeightMapParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxShadowHeightMapParameter* pInstance);
        static void Clean(FxShadowHeightMapParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxVolumetricShadowParameter {
        bool enable;
        bool isForceUseShadowmap;
        bool isUseCloudShadow;
        bool isUseHeightmapShadow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxVolumetricShadowParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxVolumetricShadowParameter* pInstance);
        static void Clean(FxVolumetricShadowParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSSAO_Parameter {
        float intensity;
        float radius;
        float fadeoutDistance;
        float fadeoutRadius;
        float power;
        float bias;
        float occlusionDistance;
        float directLightingInfluence;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSSAO_Parameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSSAO_Parameter* pInstance);
        static void Clean(FxSSAO_Parameter* pInstance);
    };
}

namespace hh::needle {
    struct FxHBAO_Parameter {
        float hbaoPower;
        float hbaoBias;
        float hbaoRadius;
        float hbaoFalloff;
        float hbaoSteps;
        float hbaoGitter;
        int8_t hbaoRaycount;
        bool hbaoGiMaskEnable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxHBAO_Parameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxHBAO_Parameter* pInstance);
        static void Clean(FxHBAO_Parameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSSS_Parameter {
        float sssRayLength;
        int8_t sssRaycount;
        float sssBias;
        float sssIntensity;
        float sssDepthMin;
        float sssDepthMax;
        float sssLightDistance;
        float sssThickness;
        bool sssGiMaskEnable;
        float sssLimit;
        bool sssDitherEnable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSSS_Parameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSSS_Parameter* pInstance);
        static void Clean(FxSSS_Parameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSSAOParameter {
        enum class SSAOType : int8_t {
            SSAO = 0,
            HBAO = 1,
            HBAO_SSS = 2,
            SSS = 3,
            TYPE_COUNT = 4,
        };

        enum class RenderTargetSize : int8_t {
            RTSIZE_SAME_AS_FRAMEBUFFER = 0,
            RTSIZE_ONE_SECOND = 1,
            RTSIZE_ONE_FORTH = 2,
            RTSIZE_COUNT = 3,
        };

        enum class BLURType : int8_t {
            None = 1,
            Gauss2x2 = 2,
            Gauss3x3 = 3,
            Gauss4x4 = 4,
            Gauss5x5 = 5,
            Gauss6x6 = 6,
            Gauss7x7 = 7,
            Gauss8x8 = 8,
            Gauss9x9 = 9,
            Bilateral = 10,
            BLUR_COUNT = 11,
        };

        bool enable;
        SSAOType postType;
        RenderTargetSize renderTargetSize;
        BLURType blurStep;
        float bilateralThreshold;
        hh::needle::FxSSAO_Parameter ssaoParam;
        hh::needle::FxHBAO_Parameter hbaoParam;
        hh::needle::FxSSS_Parameter sssParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSSAOParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSSAOParameter* pInstance);
        static void Clean(FxSSAOParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxLightFieldMergeParameter {
        bool enable;
        float blendRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxLightFieldMergeParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxLightFieldMergeParameter* pInstance);
        static void Clean(FxLightFieldMergeParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSHLightFieldParameter {
        enum class DebugDrawType : int8_t {
            DEBUG_DRAW_NONE = 0,
            DEBUG_DRAW_ONLY_ENABLED = 1,
            DEBUG_DRAW_ALL = 2,
        };

        bool enable;
        DebugDrawType debugDrawType;
        bool showSkyVisibility;
        float debugProbeSize;
        csl::math::Vector3 multiplyColorUp;
        csl::math::Vector3 multiplyColorDown;
        float normalBias;
        hh::needle::FxLightFieldMergeParameter lfMerge;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSHLightFieldParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSHLightFieldParameter* pInstance);
        static void Clean(FxSHLightFieldParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxScreenBlurParameter {
        enum class BlurType : int8_t {
            BLURTYPE_PREV_SURFACE = 0,
            BLURTYPE_RADIAL = 1,
            BLURTYPE_CAMERA = 2,
            BLURTYPE_COUNT = 3,
        };

        enum class FocusType : int8_t {
            FOCUSTYPE_CENTER = 0,
            FOCUSTYPE_LOOKAT = 1,
            FOCUSTYPE_USER_SETTING = 2,
            FOCUSTYPE_COUNT = 3,
        };

        bool enable;
        BlurType blurType;
        float blurPower;
        FocusType focusType;
        csl::math::Vector3 focusPosition;
        float focusRange;
        float alphaSlope;
        int32_t sampleNum;
        bool singleDirectionOpt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxScreenBlurParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxScreenBlurParameter* pInstance);
        static void Clean(FxScreenBlurParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxOcclusionCapsuleParameter {
        bool enable;
        bool enableOcclusion;
        csl::ut::Color8 occlusionColor;
        float occlusionPower;
        bool enableSpecularOcclusion;
        float specularOcclusionAlpha;
        float specularOcclusionPower;
        float specularOcclusionConeAngle;
        bool enableShadow;
        csl::ut::Color8 shadowColor;
        float shadowPower;
        float shadowConeAngle;
        float cullingDistance;
        bool enableManualLight;
        int32_t manualLightCount;
        csl::math::Vector3 manualLightPos[4];
        bool debugDraw;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxOcclusionCapsuleParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxOcclusionCapsuleParameter* pInstance);
        static void Clean(FxOcclusionCapsuleParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxEffectParameter {
        float lightFieldColorCoefficient;
        float invTonemapCoefficient;
        csl::math::Vector3 shadowColor;
        csl::math::Vector3 directionalLightOverwrite;
        float directionalLightIntensityOverwrite;
        bool overwriteDirectionalLight;
        float localLightIntensityScale;
        float lodDistances[8];
        bool enableVisualizeOverdraw;
        bool renderWireframe;
        bool upsampleBilateral;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxEffectParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxEffectParameter* pInstance);
        static void Clean(FxEffectParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxScreenSpaceGodrayParameter {
        bool enable;
        float rayMarchingCount;
        float density;
        float decay;
        float threshold;
        float lumMax;
        float intensity;
        bool enableDither;
        csl::math::Vector3 lightPos;
        csl::math::Vector3 lightDir;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxScreenSpaceGodrayParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxScreenSpaceGodrayParameter* pInstance);
        static void Clean(FxScreenSpaceGodrayParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxGodrayVolumeTexture {
        bool enableVolumeTexture;
        float uvScale;
        float timeScale;
        float animationAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxGodrayVolumeTexture* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxGodrayVolumeTexture* pInstance);
        static void Clean(FxGodrayVolumeTexture* pInstance);
    };
}

namespace hh::needle {
    struct FxGodrayParameter {
        bool enable;
        bool isUseShadowmap;
        bool isVariableStep;
        csl::math::Matrix44 shadow;
        csl::math::Matrix34 box;
        csl::math::Vector3 color;
        float density;
        float anisotropy;
        float range;
        float rayMarchingCount;
        float rayMarchingStep;
        float shadowEdge;
        bool isScanFromBack;
        int32_t boxCount;
        bool isNewMode;
        hh::needle::FxGodrayVolumeTexture volumeTexture;
        float transparency;
        bool enable3d;
        float reProject3d;
        float logNear3d;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxGodrayParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxGodrayParameter* pInstance);
        static void Clean(FxGodrayParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxHeatHazeParameter {
        bool enable;
        float speed;
        float scale;
        float cycle;
        float nearDepth;
        float farDepth;
        float maxHeight;
        float parallaxCorrectFactor;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxHeatHazeParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxHeatHazeParameter* pInstance);
        static void Clean(FxHeatHazeParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxPuddleParameter {
        float heightThreshold;
        float slopeThreshold;
        float noiseScaleXZ;
        float noiseScaleY;
        float noiseThreshold;
        float noiseAttenuationRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxPuddleParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxPuddleParameter* pInstance);
        static void Clean(FxPuddleParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxRippleParameter {
        float intensity;
        float uvScale;
        float timeScale;
        float normalIntensity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxRippleParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxRippleParameter* pInstance);
        static void Clean(FxRippleParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxDropParameter {
        float uvScale;
        float timeScale;
        float normalIntensity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDropParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDropParameter* pInstance);
        static void Clean(FxDropParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxRainParameter {
        bool enableDrop;
        bool enableFilter;
        bool enableRipple;
        float intensity;
        csl::math::Vector4 dropColor;
        bool dropRotTarget;
        bool enableDropOcc;
        float dropCameraLerp;
        float dropCameraRate;
        float dropCameraRotation;
        float dropWidth;
        float dropLength;
        float dropWind;
        float dropRange;
        csl::math::Vector4 filterColor;
        float filterRange;
        float filterEdge;
        float filterAngle;
        hh::needle::FxRippleParameter ripple;
        hh::needle::FxDropParameter drop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxRainParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxRainParameter* pInstance);
        static void Clean(FxRainParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxWeatherParameter {
        float wetness;
        hh::needle::FxPuddleParameter puddle;
        hh::needle::FxRainParameter rain;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxWeatherParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxWeatherParameter* pInstance);
        static void Clean(FxWeatherParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSceneEnvironmentParameter {
        float windRotationY;
        float windStrength;
        float windNoise;
        float windAmplitude;
        float windFrequencies[4];
        bool enableTreadGrass;
        csl::math::Vector4 grassLodDistance;
        bool enableHighLight;
        float highLightThreshold;
        float highLightObjectAmbientScale;
        float highLightObjectAlbedoHeighten;
        float highLightCharaAmbientScale;
        float highLightCharaAlbedoHeighten;
        float highLightCharaFalloffScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSceneEnvironmentParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSceneEnvironmentParameter* pInstance);
        static void Clean(FxSceneEnvironmentParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxTAAParameter {
        bool enableUpscaling;
        float jitterScale;
        float mipBias;
        float sharpnessPower;
        float baseWeight;
        float velocityVarianceBasedWeightBias;
        float colorSpaceClippingScale;
        float colorSpaceClippingScaleForStatic;
        float velocityVarianceMin;
        float velocityVarianceMax;
        bool enableCharaStencilMask;
        bool enableLiteMode;
        bool enablePassThrough;
        bool debugVisualizeVelcotiyVariance;
        csl::math::Vector4 debug;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxTAAParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxTAAParameter* pInstance);
        static void Clean(FxTAAParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxChromaticAberrationParameter {
        bool enable;
        float offsetR;
        float offsetG;
        float offsetB;
        float curve;
        float scaleX;
        float scaleY;
        float centerX;
        float centerY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxChromaticAberrationParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxChromaticAberrationParameter* pInstance);
        static void Clean(FxChromaticAberrationParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxVfImageCircleParameter {
        float centerX;
        float centerY;
        float scaleX;
        float scaleY;
        float scale;
        float rotation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxVfImageCircleParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxVfImageCircleParameter* pInstance);
        static void Clean(FxVfImageCircleParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxVfLineParameter {
        float centerX;
        float centerY;
        float directionX;
        float directionY;
        float rotation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxVfLineParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxVfLineParameter* pInstance);
        static void Clean(FxVfLineParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxVfDepthParameter {
        bool enable;
        float minPenumbraScale;
        float maxPenumbraScale;
        float bokehScale;
        float minDofOpacityScale;
        float maxDofOpacityScale;
        float minOpacityScale;
        float maxOpacityScale;
        float minOpacityDist;
        float maxOpacityDist;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxVfDepthParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxVfDepthParameter* pInstance);
        static void Clean(FxVfDepthParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxVignetteParameter {
        enum class GradationMode : int8_t {
            GRADATION_MODE_CIRCLE = 0,
            GRADATION_MODE_LINE = 1,
        };

        enum class BlendMode : int8_t {
            BLEND_MODE_ALPHA_BLEND = 0,
            BLEND_MODE_ADD = 1,
            BLEND_MODE_MUL = 2,
            BLEND_MODE_SCREEN = 3,
            BLEND_MODE_OVERLAY = 4,
        };

        bool enable;
        GradationMode gradationType;
        BlendMode blendMode;
        csl::math::Vector3 color;
        float opacity;
        hh::needle::FxVfImageCircleParameter imageCircle;
        hh::needle::FxVfLineParameter line;
        float penumbraScale;
        float intensity;
        hh::needle::FxVfDepthParameter depth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxVignetteParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxVignetteParameter* pInstance);
        static void Clean(FxVignetteParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxWindComputeDebugParameter {
        bool debugEnable;
        bool debugSpace;
        bool debugGlobal;
        bool debugGlobalMap;
        bool debugSpaceAll;
        int32_t spaceIndex;
        float spaceThreshold;
        float min;
        float max;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxWindComputeDebugParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxWindComputeDebugParameter* pInstance);
        static void Clean(FxWindComputeDebugParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxWindComputeParameter {
        bool enableAll;
        bool enableDynamicWind;
        bool enableGlobalWind;
        float timeScale;
        float decreaseRate;
        csl::math::Vector3 globalWind;
        float globalWindPower;
        float globalWindSpeed;
        float globalWindOffset;
        csl::math::Vector3 globalSecondWind;
        float globalSecondWindPower;
        float globalSecondWindSpeed;
        float globalSecondWindOffset;
        csl::math::Vector3 globalWindMapSize;
        csl::math::Vector3 globalWindMapCenter;
        csl::math::Vector3 globalWindMapOffset;
        float globalWindMapPower;
        float globalWindMapTimeScale;
        hh::needle::FxWindComputeDebugParameter debugParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxWindComputeParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxWindComputeParameter* pInstance);
        static void Clean(FxWindComputeParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxTerrainMaterialBlendingParameter {
        bool enable;
        float blendPower;
        float blendHightPower;
        float cullingDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxTerrainMaterialBlendingParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxTerrainMaterialBlendingParameter* pInstance);
        static void Clean(FxTerrainMaterialBlendingParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxInteractionDebugParameter {
        bool enable;
        bool collisionEnable;
        float threshold;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxInteractionDebugParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxInteractionDebugParameter* pInstance);
        static void Clean(FxInteractionDebugParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxInteractionParameter {
        bool enable;
        float power;
        float decrease;
        float timeScale;
        hh::needle::FxInteractionDebugParameter debug;
        float tremorPower;
        float tremorSpeed;
        float tremorScaleCriterion;
        float tremorScaleReduce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxInteractionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxInteractionParameter* pInstance);
        static void Clean(FxInteractionParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxGpuEnvironmentParameter {
        float grassDitherStart;
        float grassDitherEnd;
        hh::needle::FxInteractionParameter interaction;
        bool enableZoomBias;
        float zoomBias;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxGpuEnvironmentParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxGpuEnvironmentParameter* pInstance);
        static void Clean(FxGpuEnvironmentParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxInteractiveWaveParameter {
        bool enable;
        bool enableDebugDisplay;
        float waveDamping;
        float waveReduceRange;
        float waveSpeed;
        float simurationScale;
        float playerMaxSpeed;
        bool isInWaterDummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxInteractiveWaveParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxInteractiveWaveParameter* pInstance);
        static void Clean(FxInteractiveWaveParameter* pInstance);
    };
}

namespace heur::rfl {
    struct UVShift {
        float blockLNoiseSizeX;
        float blockLNoiseSizeY;
        float blockHNoiseSizeX;
        float blockHNoiseSizeY;
        float bNoiseHighRate;
        float intensity;
        float pixelShiftIntensity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(UVShift* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(UVShift* pInstance);
        static void Clean(UVShift* pInstance);
    };
}

namespace hh::needle {
    struct ColorShift {
        float blockLNoiseSize;
        float blockHNoiseSize;
        float bNoiseHighRate;
        float intensity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ColorShift* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ColorShift* pInstance);
        static void Clean(ColorShift* pInstance);
    };
}

namespace heur::rfl {
    struct InterlaceNoise {
        float blockLNoiseSize;
        float blockHNoiseSize;
        float bNoiseHighRate;
        float intensity;
        float dropout;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(InterlaceNoise* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(InterlaceNoise* pInstance);
        static void Clean(InterlaceNoise* pInstance);
    };
}

namespace hh::needle {
    struct ColorDropout {
        float blockLNoiseSizeX;
        float blockLNoiseSizeY;
        float blockHNoiseSizeX;
        float blockHNoiseSizeY;
        float bNoiseHighRate;
        float intensity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ColorDropout* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ColorDropout* pInstance);
        static void Clean(ColorDropout* pInstance);
    };
}

namespace heur::rfl {
    struct InvertColor {
        float blockLNoiseSizeX;
        float blockLNoiseSizeY;
        float blockHNoiseSizeX;
        float blockHNoiseSizeY;
        float bNoiseHighRate;
        float intensity;
        float invertAllRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(InvertColor* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(InvertColor* pInstance);
        static void Clean(InvertColor* pInstance);
    };
}

namespace heur::rfl {
    struct GlayScaleColor {
        float blockLNoiseSizeX;
        float blockLNoiseSizeY;
        float blockHNoiseSizeX;
        float blockHNoiseSizeY;
        float bNoiseHighRate;
        float intensity;
        float invertAllRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GlayScaleColor* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GlayScaleColor* pInstance);
        static void Clean(GlayScaleColor* pInstance);
    };
}

namespace hh::needle {
    struct FxCyberSpaceStartNoiseParameter {
        bool enable;
        heur::rfl::UVShift uvShift;
        hh::needle::ColorShift colorShift;
        heur::rfl::InterlaceNoise interlaceNoise;
        hh::needle::ColorDropout colorDrop;
        heur::rfl::InvertColor invertColor;
        heur::rfl::GlayScaleColor glayscaleColor;
        float noiseSpeed;
        float noiseBias;
        float noiseWaveAmplitude;
        float noiseWaveCycle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxCyberSpaceStartNoiseParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxCyberSpaceStartNoiseParameter* pInstance);
        static void Clean(FxCyberSpaceStartNoiseParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxFieldScanEffectRenderParameter {
        bool enable;
        csl::math::Vector3 centerPos;
        csl::ut::Color8 color;
        float radius1;
        float radius2;
        float radius3;
        float intensity1;
        float intensity2;
        float intensity3;
        float gridIntensity;
        float innerWidth;
        float gridLineWidth;
        float gridLineSpan;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxFieldScanEffectRenderParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxFieldScanEffectRenderParameter* pInstance);
        static void Clean(FxFieldScanEffectRenderParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxColorAccessibilityFilterParameter {
        enum class ColorblinidSimulationType : int8_t {
            COLORBLIND_SIM_NONE = 0,
            COLORBLIND_SIM_PROTANOPIA = 1,
            COLORBLIND_SIM_DEUTERANOPIA = 2,
            COLORBLIND_SIM_TRITANOPIA = 3,
            COLORBLIND_SIM_ALL = 4,
        };

        bool enable;
        float daltonizeFactor;
        float protanopiaFactor;
        float deuteranopiaFactor;
        float tritanopiaFactor;
        float brightness;
        float contrast;
        float maskIntensity[5];
        ColorblinidSimulationType simulationType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxColorAccessibilityFilterParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxColorAccessibilityFilterParameter* pInstance);
        static void Clean(FxColorAccessibilityFilterParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSeparableSSSParameter {
        bool enable;
        float width;
        float normalOffset;
        float blurOffsetMax;
        csl::math::Vector4 strength[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSeparableSSSParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSeparableSSSParameter* pInstance);
        static void Clean(FxSeparableSSSParameter* pInstance);
    };
}

namespace hh::needle {
    struct NeedleFxParameter {
        hh::needle::FxRenderOption renderOption;
        hh::needle::FxSGGIParameter sggi;
        hh::needle::FxRLRParameter rlr;
        hh::needle::FxSSGIParameter ssgi;
        hh::needle::FxPlanarReflectionParameter planarReflection;
        hh::needle::FxBloomParameter bloom;
        hh::needle::FxCameraControlParameter cameraControl;
        hh::needle::FxToneMapParameter tonemap;
        hh::needle::FxColorContrastParameter colorContrast;
        hh::needle::FxLightScatteringParameter lightscattering;
        hh::needle::FxDOFParameter dof;
        hh::needle::FxShadowMapParameter shadowmap;
        hh::needle::FxShadowHeightMapParameter shadowHeightMap;
        hh::needle::FxVolumetricShadowParameter volShadow;
        hh::needle::FxSSAOParameter ssao;
        hh::needle::FxSHLightFieldParameter shlightfield;
        hh::needle::FxScreenBlurParameter blur;
        hh::needle::FxOcclusionCapsuleParameter occlusionCapsule;
        hh::needle::FxEffectParameter effect;
        hh::needle::FxScreenSpaceGodrayParameter ssGodray;
        hh::needle::FxGodrayParameter godray;
        hh::needle::FxHeatHazeParameter heatHaze;
        hh::needle::FxAtmosphereParameter atmosphere;
        hh::needle::FxWeatherParameter weather;
        hh::needle::FxSceneEnvironmentParameter sceneEnv;
        hh::needle::FxTAAParameter taa;
        hh::needle::FxDensityParameter density;
        hh::needle::FxChromaticAberrationParameter chromaticAberration;
        hh::needle::FxVignetteParameter vignette;
        hh::needle::FxWindComputeParameter wind;
        hh::needle::FxTerrainMaterialBlendingParameter terrainBlend;
        hh::needle::FxGpuEnvironmentParameter gpuEnvironment;
        hh::needle::FxInteractiveWaveParameter interactiveWave;
        hh::needle::FxCyberNoiseEffectParameter cyberNoise;
        hh::needle::FxCyberSpaceStartNoiseParameter cyberStartNoise;
        hh::needle::FxCyberNPCSSEffectRenderParameter cyberNPCSS;
        hh::needle::FxFieldScanEffectRenderParameter fieldScan;
        hh::needle::FxColorAccessibilityFilterParameter colorAccessibility;
        hh::gfx::FxDentParameter dent;
        hh::needle::FxSeparableSSSParameter ssss;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NeedleFxParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NeedleFxParameter* pInstance);
        static void Clean(NeedleFxParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxAntiAliasing {
        enum class AntiAliasingType : int8_t {
            AATYPE_NONE = 0,
            AATYPE_TAA = 1,
            AATYPE_FXAA = 2,
            AATYPE_SMAA = 3,
            AATYPE_LAST = 4,
        };

        enum class UpscaleType : int8_t {
            USTYPE_LINEAR = 0,
            USTYPE_FSR_FAST = 1,
            USTYPE_FSR_EASU = 2,
            USTYPE_FSR_RCAS = 3,
        };

        AntiAliasingType aaType;
        UpscaleType usType;
        float fsrSharpness;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxAntiAliasing* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxAntiAliasing* pInstance);
        static void Clean(FxAntiAliasing* pInstance);
    };
}

namespace hh::gfx {
    struct StageCommonAtmosphereParameter {
        float illuminanceScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageCommonAtmosphereParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageCommonAtmosphereParameter* pInstance);
        static void Clean(StageCommonAtmosphereParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxLODParameter {
        bool enableDebugDrawLayerRange;
        float layerRange[32];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxLODParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxLODParameter* pInstance);
        static void Clean(FxLODParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxDetailParameter {
        float detailDistance;
        float detailFadeRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDetailParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDetailParameter* pInstance);
        static void Clean(FxDetailParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxDynamicResolutionParameter {
        enum class Mode : int8_t {
            DISABLE = 0,
            ENABLE = 1,
            FIXED_RESOLUTION = 2,
        };

        Mode mode;
        float fixedResolutionRatio;
        float minResolutionRatio;
        float minTargetTimeDifference;
        float maxTargetTimeDifference;
        float increaseRate;
        float decreaseRate;
        float increaseMaxScaleDelta;
        float decreaseMaxScaleDelta;
        bool debugSineFluctuation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDynamicResolutionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDynamicResolutionParameter* pInstance);
        static void Clean(FxDynamicResolutionParameter* pInstance);
    };
}

namespace heur::rfl {
    struct TimeIntervalData {
        heur::rfl::HourMinuteData beginTime;
        heur::rfl::HourMinuteData endTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TimeIntervalData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TimeIntervalData* pInstance);
        static void Clean(TimeIntervalData* pInstance);
    };
}

namespace heur::rfl {
    struct ProgressTimePairData : heur::rfl::TimeIntervalData {
        float hourlyTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ProgressTimePairData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ProgressTimePairData* pInstance);
        static void Clean(ProgressTimePairData* pInstance);
    };
}

namespace hh::gfx {
    struct StageCommonTimeProgressParameter {
        bool enable;
        float solarRadiusScale;
        float azimuthAngle;
        float latitude;
        float longitude;
        int32_t month;
        int32_t day;
        float time;
        float hourlyTime;
        heur::rfl::ProgressTimePairData overrideSpeeds[8];
        heur::rfl::TimeIntervalData night;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageCommonTimeProgressParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageCommonTimeProgressParameter* pInstance);
        static void Clean(StageCommonTimeProgressParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StageCommonWeatherProgressParameter {
        bool enable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageCommonWeatherProgressParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageCommonWeatherProgressParameter* pInstance);
        static void Clean(StageCommonWeatherProgressParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxTerrainParameter {
        bool enableDrawGrid;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxTerrainParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxTerrainParameter* pInstance);
        static void Clean(FxTerrainParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxModelParameter {
        bool zprepass;
        bool ditherAsBlueNoize;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxModelParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxModelParameter* pInstance);
        static void Clean(FxModelParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StageCommonDecalModelParameter {
        float cullingRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageCommonDecalModelParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageCommonDecalModelParameter* pInstance);
        static void Clean(StageCommonDecalModelParameter* pInstance);
    };
}

namespace heur::rfl {
    struct PerformanceSetting {
        float smallCullingThreshold;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PerformanceSetting* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PerformanceSetting* pInstance);
        static void Clean(PerformanceSetting* pInstance);
    };
}

namespace hh::needle {
    struct NeedleFxSceneConfig {
        hh::gfx::FxRenderTargetSetting rendertarget;
        hh::needle::FxAntiAliasing antialiasing;
        hh::gfx::StageCommonAtmosphereParameter atmosphere;
        hh::needle::FxLODParameter lod;
        hh::needle::FxDetailParameter detail;
        hh::needle::FxDynamicResolutionParameter dynamicResolution;
        hh::gfx::StageCommonTimeProgressParameter timeProgress;
        heur::rfl::StageCommonWeatherProgressParameter weatherProgress;
        hh::needle::FxTerrainParameter terrain;
        hh::needle::FxModelParameter modelParam;
        heur::rfl::StageCommonDecalModelParameter decalModelParam;
        heur::rfl::PerformanceSetting performance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NeedleFxSceneConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NeedleFxSceneConfig* pInstance);
        static void Clean(NeedleFxSceneConfig* pInstance);
    };
}

namespace heur::rfl {
    struct TimeProgressAtmosphereParameter {
        hh::needle::FxSkyCommon commonSkyParam;
        hh::needle::FxBrunetonSky brunetonSkyParam;
        hh::needle::FxSebastienSky sebastienSkyParam;
        heur::rfl::FxCloudParameter cloudParam;
        hh::needle::FxCrepuscularRay crepuscularRayParam;
        hh::needle::FxHeightFog heightFogParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TimeProgressAtmosphereParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TimeProgressAtmosphereParameter* pInstance);
        static void Clean(TimeProgressAtmosphereParameter* pInstance);
    };
}

namespace heur::rfl {
    struct TimeProgressNeedleFxParam {
        bool enable;
        float time;
        hh::needle::FxBloomParameter bloom;
        hh::needle::FxCameraControlParameter cameraControl;
        hh::needle::FxCameraControlParameter cameraControlEvent;
        hh::needle::FxToneMapParameter tonemap;
        hh::needle::FxColorContrastParameter colorContrast;
        hh::needle::FxLightScatteringParameter lightscattering;
        hh::needle::FxEffectParameter effect;
        hh::needle::FxScreenSpaceGodrayParameter ssGodray;
        hh::needle::FxGodrayParameter godray;
        hh::needle::FxHeatHazeParameter heatHaze;
        heur::rfl::TimeProgressAtmosphereParameter atmosphere;
        hh::needle::FxWeatherParameter weather;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TimeProgressNeedleFxParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TimeProgressNeedleFxParam* pInstance);
        static void Clean(TimeProgressNeedleFxParam* pInstance);
    };
}

namespace heur::rfl {
    struct WeatherFxParameter {
        bool enable;
        hh::needle::FxBloomParameter bloom;
        hh::needle::FxCameraControlParameter cameraControl;
        hh::needle::FxCameraControlParameter cameraControlEvent;
        hh::needle::FxToneMapParameter tonemap;
        hh::needle::FxColorContrastParameter colorContrast;
        hh::needle::FxLightScatteringParameter lightscattering;
        hh::needle::FxEffectParameter effect;
        hh::needle::FxScreenSpaceGodrayParameter ssGodray;
        hh::needle::FxGodrayParameter godray;
        hh::needle::FxHeatHazeParameter heatHaze;
        heur::rfl::TimeProgressAtmosphereParameter atmosphere;
        hh::needle::FxWeatherParameter weather;
        hh::needle::FxWindComputeParameter wind;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherFxParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherFxParameter* pInstance);
        static void Clean(WeatherFxParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StageCommonParameter {
        float deadline;
        float oceanSurface;
        float deadFallTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageCommonParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageCommonParameter* pInstance);
        static void Clean(StageCommonParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StageCameraParameter {
        float zNear;
        float zFar;
        float fovy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageCameraParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageCameraParameter* pInstance);
        static void Clean(StageCameraParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StageTerrainPrecisionParameter {
        float heightRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageTerrainPrecisionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageTerrainPrecisionParameter* pInstance);
        static void Clean(StageTerrainPrecisionParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StageTerrainMaterialParameter {
        float uvScaleDetail;
        float uvScaleBase;
        float detailDistance;
        float detailFadeRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageTerrainMaterialParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageTerrainMaterialParameter* pInstance);
        static void Clean(StageTerrainMaterialParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StageTerrainParameter {
        bool useHeightMapTerrain;
        bool useHalfPrecision;
        heur::rfl::StageTerrainPrecisionParameter precision;
        int32_t worldSize;
        int32_t heightMapTexelDensity;
        float heightScale;
        float smallestCellSize;
        float slopeClipThrethold;
        csl::math::Vector2 aabbMin;
        csl::math::Vector2 aabbMax;
        heur::rfl::StageTerrainMaterialParameter material;
        bool enableGbufferBlending;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageTerrainParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageTerrainParameter* pInstance);
        static void Clean(StageTerrainParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StageConfig {
        heur::rfl::StageCommonParameter common;
        heur::rfl::StageCameraParameter camera;
        heur::rfl::StageTerrainParameter terrain;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StageConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StageConfig* pInstance);
        static void Clean(StageConfig* pInstance);
    };
}

namespace hh::needle {
    struct NeedleFxSceneData {
        hh::needle::NeedleFxSceneConfig config;
        hh::needle::NeedleFxParameter items[16];
        heur::rfl::TimeProgressNeedleFxParam timeItems[24];
        heur::rfl::WeatherFxParameter weatherItems[7];
        heur::rfl::StageConfig stageConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NeedleFxSceneData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NeedleFxSceneData* pInstance);
        static void Clean(NeedleFxSceneData* pInstance);
    };
}

namespace heur::rfl {
    struct CapsuleParam {
        enum class VolumeType : int8_t {
            VOLUME_SPHERE = 0,
            VOLUME_CAPSULE = 1,
        };

        enum class LODLevel : int8_t {
            LOD_HIGH = 0,
            LOD_MIDDLE = 1,
            LOD_LOW = 2,
        };

        csl::ut::VariableString type;
        VolumeType volume;
        int32_t priority;
        csl::math::Vector3 translation;
        csl::math::Vector3 rotation;
        csl::math::Vector3 scale;
        csl::math::Vector3 rate;
        float radius;
        LODLevel lod;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CapsuleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CapsuleParam* pInstance);
        static void Clean(CapsuleParam* pInstance);
    };
}

namespace hh::needle {
    struct FxDistanceFogParameter {
        bool enable;
        csl::math::Vector3 color;
        float intensity;
        float nearDist;
        float farDist;
        float influence;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDistanceFogParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDistanceFogParameter* pInstance);
        static void Clean(FxDistanceFogParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxHeightFogParameter {
        bool enable;
        csl::math::Vector3 color;
        float intensity;
        float minHeight;
        float maxHeight;
        float nearDist;
        float farDist;
        float influence;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxHeightFogParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxHeightFogParameter* pInstance);
        static void Clean(FxHeightFogParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxFogParameter {
        hh::needle::FxDistanceFogParameter distanceFogParam;
        hh::needle::FxHeightFogParameter heightFogParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxFogParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxFogParameter* pInstance);
        static void Clean(FxFogParameter* pInstance);
    };
}

namespace heur::rfl {
    struct OcclusionCapsuleList {
        heur::rfl::CapsuleParam capsules[64];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OcclusionCapsuleList* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OcclusionCapsuleList* pInstance);
        static void Clean(OcclusionCapsuleList* pInstance);
    };
}

namespace hh::needle {
    struct FxDirectionalRadialBlurParameter {
        bool enable;
        csl::math::Vector3 center;
        csl::math::Vector3 direction;
        float blurPowerMax;
        float blurPowerMin;
        float focusRange;
        float alphaSlope;
        int32_t sampleNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxDirectionalRadialBlurParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxDirectionalRadialBlurParameter* pInstance);
        static void Clean(FxDirectionalRadialBlurParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxFXAAParameter {
        enum class QualityType : int8_t {
            QUALITY_LOW = 0,
            QUALITY_MEDIUM = 1,
            QUALITY_HIGH = 2,
            QUALITY_COUNT = 3,
        };

        QualityType qualityType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxFXAAParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxFXAAParameter* pInstance);
        static void Clean(FxFXAAParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxHeightMapParameter {
        bool enable;
        bool enableMultiHeightmap;
        bool debugDrawFrustum;
        bool reprojection;
        uint32_t renderTargetWidth;
        uint32_t renderTargetHeight;
        float referenceValue;
        float heightScale;
        float fadeTime;
        float colorMask;
        csl::math::Matrix44 viewMatrix;
        csl::math::Matrix44 projMatrix;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxHeightMapParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxHeightMapParameter* pInstance);
        static void Clean(FxHeightMapParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxPlanarProjectionShadowParameter {
        bool enable;
        csl::math::Vector4 projectionPlane;
        csl::math::Vector3 lightPosition[4];
        int8_t lightCount;
        float vanishStart;
        float vanishDistance;
        float projectionBias;
        csl::math::Vector3 shadowMapBoxSize;
        csl::math::Vector3 shadowMapBoxOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxPlanarProjectionShadowParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxPlanarProjectionShadowParameter* pInstance);
        static void Clean(FxPlanarProjectionShadowParameter* pInstance);
    };
}

namespace hh::needle {
    struct FxSMAAParameter {
        enum class Preset : int8_t {
            PRESET_SPEED = 0,
            PRESET_QUALITY = 1,
        };

        enum class TestMode : int8_t {
            TEST_MODE_DISABLE = 0,
            TEST_MODE_1 = 1,
            TEST_MODE_2 = 2,
        };

        Preset preset;
        TestMode testMode;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FxSMAAParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FxSMAAParameter* pInstance);
        static void Clean(FxSMAAParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ViewSpaceOffsetRflParam {
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 eyeOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ViewSpaceOffsetRflParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ViewSpaceOffsetRflParam* pInstance);
        static void Clean(ViewSpaceOffsetRflParam* pInstance);
    };
}

namespace heur::rfl {
    struct SwayParamCollision {
        enum class CollisionType : int8_t {
            SWAY_COLLISTION_TYPE_NONE = 0,
            SWAY_COLLISTION_TYPE_SPHERE = 1,
        };

        CollisionType type;
        csl::math::Vector3 translation;
        csl::math::Vector3 rotation;
        csl::math::Vector3 scale;
        int32_t modelPartId;
        csl::ut::VariableString modelNodeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SwayParamCollision* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SwayParamCollision* pInstance);
        static void Clean(SwayParamCollision* pInstance);
    };
}

namespace heur::rfl {
    struct SwayParamNode {
        bool enable;
        float gravity;
        float resist;
        float resist_decay;
        float recover;
        float recover_decay;
        float spring;
        float radius;
        float transmit;
        float inertia;
        float angle_limit;
        csl::ut::VariableString nodeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SwayParamNode* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SwayParamNode* pInstance);
        static void Clean(SwayParamNode* pInstance);
    };
}

namespace heur::rfl {
    struct SwayParamNodeCollision {
        heur::rfl::SwayParamCollision collisionParam[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SwayParamNodeCollision* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SwayParamNodeCollision* pInstance);
        static void Clean(SwayParamNodeCollision* pInstance);
    };
}

namespace heur::rfl {
    struct SwayParamIndivisual {
        csl::ut::VariableString idName;
        heur::rfl::SwayParamNode nodeParam[16];
        heur::rfl::SwayParamNodeCollision collisionParam[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SwayParamIndivisual* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SwayParamIndivisual* pInstance);
        static void Clean(SwayParamIndivisual* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDarumaDropSpawner {
        int8_t partCount;
        bool isEnableHoming;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDarumaDropSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDarumaDropSpawner* pInstance);
        static void Clean(ObjDarumaDropSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ActionNotification {
        enum class Type : int8_t {
            Start = 0,
            On = 1,
            Off = 2,
            Finish = 3,
            NumTypes = 4,
            Invalid = -1,
        };

        Type action;
        csl::ut::MoveArray<hh::game::ObjectId> objectIds;
        float delayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionNotification* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionNotification* pInstance);
        static void Clean(ActionNotification* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFlashSwitchSpawner {
        int32_t no;
        bool eventDriven;
        float offTime;
        float phase;
        float stopTime;
        int8_t timeStopGroupID;
        bool isHomingAttack;
        bool isConstrain;
        heur::rfl::ActionNotification actions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFlashSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFlashSwitchSpawner* pInstance);
        static void Clean(ObjFlashSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossItemBoxSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossItemBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossItemBoxSpawner* pInstance);
        static void Clean(ObjBossItemBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossSpringSpawner {
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossSpringSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossSpringSpawner* pInstance);
        static void Clean(ObjBossSpringSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonChasePathInfo {
        csl::ut::VariableString bossPathName;
        csl::ut::VariableString playerPathName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonChasePathInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonChasePathInfo* pInstance);
        static void Clean(BossDragonChasePathInfo* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonSpawner {
        csl::ut::VariableString cruisePathName;
        csl::ut::VariableString patrolPathName;
        csl::ut::VariableString approachPathName;
        csl::ut::VariableString climbPathName;
        csl::ut::VariableString climbEndPathName;
        csl::ut::VariableString roadPathName;
        csl::ut::VariableString battlePathName;
        csl::ut::VariableString bossPathName;
        csl::ut::VariableString playerPathName;
        bool eventDriven;
        csl::ut::MoveArray<hh::game::ObjectId> releaseMapPos;
        heur::rfl::BossDragonChasePathInfo chasePathInfos[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonSpawner* pInstance);
        static void Clean(BossDragonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BossGiantSpawner {
        csl::ut::VariableString guidePathName;
        csl::ut::MoveArray<hh::game::ObjectId> objectIds;
        csl::ut::MoveArray<hh::game::ObjectId> ringSupplyPos;
        csl::ut::MoveArray<hh::game::ObjectId> releaseMapPos;
        bool isEvent;
        bool isDebugMotionTest;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossGiantSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossGiantSpawner* pInstance);
        static void Clean(BossGiantSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossGiantDollSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossGiantDollSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossGiantDollSpawner* pInstance);
        static void Clean(ObjBossGiantDollSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct KnightGrindTrapInfo {
        enum class Lane : uint8_t {
            LaneA = 0,
            LaneB = 1,
            LaneC = 2,
        };

        bool enable;
        Lane lane;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightGrindTrapInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightGrindTrapInfo* pInstance);
        static void Clean(KnightGrindTrapInfo* pInstance);
    };
}

namespace heur::rfl {
    struct BossKnightSpawner {
        csl::ut::VariableString pathNameClimb;
        hh::game::ObjectId locatorClimb;
        heur::rfl::KnightGrindTrapInfo traps[16];
        csl::ut::VariableString pathNameBattle2;
        hh::game::ObjectId locatorBattle2Start;
        csl::ut::MoveArray<hh::game::ObjectId> locatorBattle2CyFloatWarp;
        csl::ut::MoveArray<hh::game::ObjectId> releaseMapPos;
        bool slamBySwitch;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossKnightSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossKnightSpawner* pInstance);
        static void Clean(BossKnightSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleSpawner {
        csl::ut::VariableString guidePathName;
        csl::ut::MoveArray<hh::game::ObjectId> objectIds;
        csl::ut::MoveArray<hh::game::ObjectId> ringSupplyPos;
        csl::ut::MoveArray<hh::game::ObjectId> releaseMapPos;
        csl::ut::MoveArray<hh::game::ObjectId> normalModeBitWaveIds;
        csl::ut::MoveArray<hh::game::ObjectId> alwaysBitWaveIds;
        bool isEvent;
        bool isDebugMotionTest;
        hh::game::ObjectId beastId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleSpawner* pInstance);
        static void Clean(BossRifleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastSpawner {
        csl::ut::VariableString guidePathName;
        hh::game::ObjectId barrier;
        csl::ut::MoveArray<hh::game::ObjectId> releaseMapPos;
        bool isEvent;
        bool isDebugMotionTest;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastSpawner* pInstance);
        static void Clean(BossRifleBeastSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBarrierSpawner {
        float size;
        csl::ut::MoveArray<hh::game::ObjectId> friendsList;
        hh::game::ObjectId boss;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBarrierSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBarrierSpawner* pInstance);
        static void Clean(ObjBarrierSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBarrierNPCSpawner {
        enum class NPCType : int8_t {
            Amy = 0,
            Knuckles = 1,
            Tails = 2,
            Sage = 3,
            EggMobileRide = 4,
            NPCType_NUM = 5,
        };

        NPCType type;
        csl::math::Vector3 riflePos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBarrierNPCSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBarrierNPCSpawner* pInstance);
        static void Clean(ObjBarrierNPCSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BossTheEndSpawner {
        bool isEvent;
        csl::math::Vector3 blockCollisionPos;
        float modelPosDepth;
        float modelScale;
        float blockColliderRadius;
        float HitColliderRadius;
        csl::ut::MoveArray<hh::game::ObjectId> target;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossTheEndSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossTheEndSpawner* pInstance);
        static void Clean(BossTheEndSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossTheEndTargetSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossTheEndTargetSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossTheEndTargetSpawner* pInstance);
        static void Clean(ObjBossTheEndTargetSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMoonSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMoonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMoonSpawner* pInstance);
        static void Clean(ObjMoonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BossRingSupplyBaseSpawner {
        csl::ut::MoveArray<hh::game::ObjectId> children;
        bool isUpdateTransform;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRingSupplyBaseSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRingSupplyBaseSpawner* pInstance);
        static void Clean(BossRingSupplyBaseSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BossRingSupplyStartPosSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRingSupplyStartPosSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRingSupplyStartPosSpawner* pInstance);
        static void Clean(BossRingSupplyStartPosSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraSpawner {
        bool IsCameraView;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraSpawner* pInstance);
        static void Clean(ObjCameraSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCamera3DSpawner : heur::rfl::ObjCameraSpawner {
        float offsetUp;
        float distanceMin;
        float distanceMax;
        float elevationMin;
        float elevationMax;
        float fovy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCamera3DSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCamera3DSpawner* pInstance);
        static void Clean(ObjCamera3DSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraClassicSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        float distance;
        float screenUpLimit;
        float screenDownLimit;
        bool limitViewField;
        float viewFieldBottom;
        float azimuth;
        float elevation;
        csl::math::Vector3 targetOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraClassicSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraClassicSpawner* pInstance);
        static void Clean(ObjCameraClassicSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct VolumeTriggerSpawner {
        enum class Shape : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CYLINDER = 2,
            SHAPE_CAPSULE = 3,
        };

        enum class BasePoint : int8_t {
            BASE_CENTER = 0,
            BASE_Z_PLANE = 1,
            BASE_X_PLANE = 2,
            BASE_Y_PLANE = 3,
        };

        enum class ColliFilter : int8_t {
            FILTER_DEFAULT = 0,
            FILTER_ONLYENEMY = 1,
            FILTER_HITENEMY = 2,
            FILTER_ALL = 3,
        };

        Shape ShapeType;
        BasePoint basePoint;
        ColliFilter CollisionFilter;
        float CollisionWidth;
        float CollisionHeight;
        float CollisionDepth;
        csl::math::Vector3 CollisionOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(VolumeTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(VolumeTriggerSpawner* pInstance);
        static void Clean(VolumeTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraClassicChangeParamVolumeSpawner {
        hh::game::ObjectId target;
        int32_t priority;
        float viewFieldBottom;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraClassicChangeParamVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraClassicChangeParamVolumeSpawner* pInstance);
        static void Clean(ObjCameraClassicChangeParamVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraClassicLimitSpawner : heur::rfl::ObjCameraSpawner {
        csl::ut::VariableString pathName;
        hh::game::ObjectId limitPointA;
        hh::game::ObjectId limitPointB;
        float fovy;
        float distance;
        float screenUpLimit;
        float screenDownLimit;
        bool limitViewField;
        float viewFieldBottom;
        float azimuth;
        float elevation;
        csl::math::Vector3 targetOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraClassicLimitSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraClassicLimitSpawner* pInstance);
        static void Clean(ObjCameraClassicLimitSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraCyberPrototypeSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        float zRot;
        float distance;
        csl::ut::VariableString pathName;
        float pathOffset;
        bool reversePathFront;
        float azimuthSensitivity;
        float elevationUpSensitivity;
        float elevationDownSensitivity;
        float azimuthOffset;
        float elevationOffset;
        float targetUpOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraCyberPrototypeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraCyberPrototypeSpawner* pInstance);
        static void Clean(ObjCameraCyberPrototypeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraCyberStandardSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        float zRot;
        float distance;
        csl::ut::VariableString pathName;
        float pathOffset;
        bool reversePathFront;
        float azimuthSensitivity;
        float elevationUpSensitivity;
        float elevationDownSensitivity;
        float azimuthOffset;
        float elevationOffset;
        float targetUpOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraCyberStandardSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraCyberStandardSpawner* pInstance);
        static void Clean(ObjCameraCyberStandardSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraCylindricalInnerSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        csl::ut::VariableString gravityPathName;
        float distance;
        float azimuthOffsetDeg;
        float elevationOffsetDeg;
        float gravityOffset;
        float fixBorderAngleDeg;
        float rollSensitivity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraCylindricalInnerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraCylindricalInnerSpawner* pInstance);
        static void Clean(ObjCameraCylindricalInnerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraCylindricalOuterSpawner : heur::rfl::ObjCameraSpawner {
        csl::ut::VariableString gravityPathName;
        float pitch;
        float dist;
        float offset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraCylindricalOuterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraCylindricalOuterSpawner* pInstance);
        static void Clean(ObjCameraCylindricalOuterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraFixSpawner : heur::rfl::ObjCameraSpawner {
        enum class TargetType : int8_t {
            TARGETTYPE_ABS_COORD = 0,
            TARGETTYPE_LOCATOR = 1,
        };

        float Fovy;
        float ZRot;
        TargetType targetType;
        csl::math::Vector3 TargetPosition;
        hh::game::ObjectId targetID;
        float targetDistance;
        csl::math::Vector3 offsetFromObject;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraFixSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraFixSpawner* pInstance);
        static void Clean(ObjCameraFixSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraFollowSpawner : heur::rfl::ObjCameraSpawner {
        float Fovy;
        float ZRot;
        float Distance;
        float Yaw;
        float Pitch;
        csl::math::Vector3 targetOffset;
        float gravityOffset;
        csl::math::Vector3 playerOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraFollowSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraFollowSpawner* pInstance);
        static void Clean(ObjCameraFollowSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraObjectPanSpawner : heur::rfl::ObjCameraSpawner {
        csl::math::Vector3 target;
        float fovy;
        bool enableLimitAngle;
        float azimuthLimitAngle;
        float elevationLimitAngle;
        csl::math::Vector3 worldOffset;
        float targetDistance;
        float targetFocusDistance;
        bool useDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraObjectPanSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraObjectPanSpawner* pInstance);
        static void Clean(ObjCameraObjectPanSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraPanSpawner : heur::rfl::ObjCameraSpawner {
        enum class PositionMode : int8_t {
            POS_MODE_FIX = 0,
            POS_MODE_MAINTAIN_DISTANCE = 1,
        };

        float fovy;
        bool enableLimitAngle;
        float azimuthLimitAngle;
        float elevationLimitAngle;
        float gravityOffset;
        csl::math::Vector3 playerOffset;
        csl::math::Vector3 worldOffset;
        PositionMode positionMode;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraPanSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraPanSpawner* pInstance);
        static void Clean(ObjCameraPanSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraPointSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        float distance;
        float gravityOffset;
        csl::math::Vector3 playerOffset;
        csl::math::Vector3 worldOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraPointSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraPointSpawner* pInstance);
        static void Clean(ObjCameraPointSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraRailSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        csl::ut::VariableString pathName;
        float pathOffset;
        float gravityOffset;
        csl::math::Vector3 playerOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraRailSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraRailSpawner* pInstance);
        static void Clean(ObjCameraRailSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraRailAnimationSpawner : heur::rfl::ObjCameraSpawner {
        enum class UpDirectionType : int8_t {
            UPDIR_Y_UP = 0,
            UPDIR_OBJ_TRANSFORM = 1,
        };

        enum class Type : int8_t {
            TIME_DRIVEN = 0,
            PLAYER_POSITION_DRIVEN = 1,
            EYE_PATH_NEAREST_BASE = 2,
            AT_PATH_NEAREST_BASE = 3,
        };

        float fovy;
        UpDirectionType upDirType;
        float zRot;
        csl::ut::VariableString eyePathName;
        float eyePathOffset;
        csl::ut::VariableString atPathName;
        float atPathOffset;
        Type type;
        float motionLength;
        bool reversePathAdvance;
        bool correctTargetPoint;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraRailAnimationSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraRailAnimationSpawner* pInstance);
        static void Clean(ObjCameraRailAnimationSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraRailDivingSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        csl::ut::VariableString pathName;
        float distance;
        float distanceBoost;
        float horzFollowRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraRailDivingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraRailDivingSpawner* pInstance);
        static void Clean(ObjCameraRailDivingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraRailForwardViewSpawner : heur::rfl::ObjCameraSpawner {
        enum class PlayerOffsetType : int8_t {
            PLAYER_OFFSET_NORMAL = 0,
            PLAYER_OFFSET_ABSOLUTE = 1,
        };

        float fovy;
        float zRot;
        float distance;
        csl::ut::VariableString pathName;
        float pathOffset;
        bool reversePathFront;
        bool usePathVerticalComponent;
        bool usePathNormal;
        bool usePathSmooth;
        float angleSensitivity;
        float angleSensitivityBoost;
        float azimuthOffsetDeg;
        float elevationOffsetDeg;
        float gravityOffset;
        csl::math::Vector3 playerOffset;
        PlayerOffsetType playerOffsetType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraRailForwardViewSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraRailForwardViewSpawner* pInstance);
        static void Clean(ObjCameraRailForwardViewSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraRailLookSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        float distance;
        csl::ut::VariableString pathName;
        float pathOffset;
        float gravityOffset;
        csl::math::Vector3 playerOffset;
        csl::math::Vector3 worldOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraRailLookSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraRailLookSpawner* pInstance);
        static void Clean(ObjCameraRailLookSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraRailSideViewSpawner : heur::rfl::ObjCameraSpawner {
        enum class OrientationMode : int8_t {
            GRAVITY = 0,
            PATH_NORMAL = 1,
        };

        float fovy;
        float distance;
        csl::ut::VariableString pathName;
        float elevation;
        float azimuth;
        float limitLeftRatio;
        float limitRightRatio;
        float upScrollRatio;
        float limitUpScrollDistance;
        float downScrollRatio;
        float limitDownScrollDistance;
        bool isLimitPathDistance;
        float limitPathDistanceMin;
        float limitPathDistanceMax;
        OrientationMode orientationMode;
        bool isSmoothPath;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraRailSideViewSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraRailSideViewSpawner* pInstance);
        static void Clean(ObjCameraRailSideViewSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraShakeTriggerSpawner {
        enum class Type : int8_t {
            TYPE_ONESHOT = 0,
            TYPE_CONTINUANCE = 1,
        };

        enum class Shake : int8_t {
            Directional = 0,
            Random = 1,
        };

        enum class ShapeType : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CYLINDER = 2,
            SHAPE_EVENT = 3,
        };

        Type type;
        float shakeTime;
        float shakeRange;
        bool oneTimeOnly;
        Shake shakeType;
        float magnitude;
        int32_t freq;
        float zRot;
        float attnRatio;
        bool distanceDecayEnabled;
        ShapeType shape;
        float width;
        float height;
        float depth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraShakeTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraShakeTriggerSpawner* pInstance);
        static void Clean(ObjCameraShakeTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraSliderSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        float distance;
        float distanceAir;
        float elevationAir;
        float angleSensitive;
        float elevationOffset;
        float pathOffset;
        float targetOffsetY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraSliderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraSliderSpawner* pInstance);
        static void Clean(ObjCameraSliderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraStandardCommonParameter {
        float distance;
        float azimuthSensitivity;
        float elevationUpSensitivity;
        float elevationDownSensitivity;
        float elevationOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraStandardCommonParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraStandardCommonParameter* pInstance);
        static void Clean(ObjCameraStandardCommonParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraStandardDashParameter {
        float minDistance;
        float maxDistance;
        float elevationOffset;
        float azimuthSensitivity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraStandardDashParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraStandardDashParameter* pInstance);
        static void Clean(ObjCameraStandardDashParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraStandardLockonParameter {
        float distance;
        float elevationOffset;
        float targetUpOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraStandardLockonParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraStandardLockonParameter* pInstance);
        static void Clean(ObjCameraStandardLockonParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraStandardSpawner : heur::rfl::ObjCameraSpawner {
        heur::rfl::ObjCameraStandardCommonParameter common;
        heur::rfl::ObjCameraStandardDashParameter dash;
        heur::rfl::ObjCameraStandardLockonParameter lockon;
        bool disabledBattleState;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraStandardSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraStandardSpawner* pInstance);
        static void Clean(ObjCameraStandardSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraSubVolumeSpawner {
        hh::game::ObjectId target;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraSubVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraSubVolumeSpawner* pInstance);
        static void Clean(ObjCameraSubVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraTiltSpawner : heur::rfl::ObjCameraSpawner {
        enum class PositionMode : int8_t {
            POS_MODE_FIX = 0,
            POS_MODE_MAINTAIN_DISTANCE = 1,
        };

        float fovy;
        bool enableLimitAngle;
        float azimuthLimitAngle;
        float gravityOffset;
        csl::math::Vector3 playerOffset;
        float lineOffset;
        PositionMode positionMode;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraTiltSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraTiltSpawner* pInstance);
        static void Clean(ObjCameraTiltSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraVerticalSpawner : heur::rfl::ObjCameraSpawner {
        float fovy;
        float distance;
        float elevationOffsetDeg;
        float gravityOffset;
        csl::math::Vector3 playerOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraVerticalSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraVerticalSpawner* pInstance);
        static void Clean(ObjCameraVerticalSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraVolumeSpawner {
        enum class InterpolateType : int8_t {
            INTERPOLATE_RELATIVE = 0,
            INTERPOLATE_ABSOLUTE = 1,
            INTERPOLATE_ABSOLUTE_COORD = 2,
            INTERPOLATE_ABSOLUTE_STABLE = 3,
        };

        enum class StateType : int8_t {
            DEFAULTSTATE_ON = 0,
            DEFAULTSTATE_OFF = 1,
        };

        enum class ActionType : int8_t {
            ACTION_EACHTIME = 0,
            ACTION_ONCE = 1,
        };

        hh::game::ObjectId target;
        uint32_t priority;
        bool useHighPriority;
        float easeTimeEnter;
        float easeTimeLeave;
        InterpolateType interpolateTypeEnter;
        InterpolateType interpolateTypeLeave;
        StateType state;
        ActionType action;
        bool disableFreeMode;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraVolumeSpawner* pInstance);
        static void Clean(ObjCameraVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraVolumeOnceSpawner {
        enum class InterpolateType : int8_t {
            INTERPOLATE_RELATIVE = 0,
            INTERPOLATE_ABSOLUTE = 1,
            INTERPOLATE_ABSOLUTE_COORD = 2,
            INTERPOLATE_ABSOLUTE_STABLE = 3,
        };

        hh::game::ObjectId target;
        uint32_t priority;
        bool useHighPriority;
        float easeTimeEnter;
        float easeTimeLeave;
        InterpolateType interpolateTypeEnter;
        InterpolateType interpolateTypeLeave;
        bool disableFreeMode;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraVolumeOnceSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraVolumeOnceSpawner* pInstance);
        static void Clean(ObjCameraVolumeOnceSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDefaultCameraSettingSpawner {
        hh::game::ObjectId cameraObjectID;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDefaultCameraSettingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDefaultCameraSettingSpawner* pInstance);
        static void Clean(ObjDefaultCameraSettingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFarChangeVolumeSpawner {
        float farDist;
        uint32_t priority;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFarChangeVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFarChangeVolumeSpawner* pInstance);
        static void Clean(ObjFarChangeVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PuzzleSize {
        uint8_t numRows;
        uint8_t numColumns;
        uint8_t numLayers;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PuzzleSize* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PuzzleSize* pInstance);
        static void Clean(PuzzleSize* pInstance);
    };
}

namespace heur::rfl {
    struct CSRow {
        enum class Color : uint8_t {
            Blue = 0,
            LightBlue = 1,
            Green = 2,
            Purple = 3,
            Red = 4,
            White = 5,
            Yellow = 6,
            Transparent = 7,
            NumColors = 8,
        };

        Color columns[15];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CSRow* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CSRow* pInstance);
        static void Clean(CSRow* pInstance);
    };
}

namespace heur::rfl {
    struct CSLayer {
        heur::rfl::CSRow rows[15];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CSLayer* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CSLayer* pInstance);
        static void Clean(CSLayer* pInstance);
    };
}

namespace heur::rfl {
    struct CorrectShape {
        heur::rfl::CSLayer layers[15];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CorrectShape* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CorrectShape* pInstance);
        static void Clean(CorrectShape* pInstance);
    };
}

namespace heur::rfl {
    struct Obj3DPuzzleSpawner {
        enum class CorrectModelType : uint8_t {
            isl_obj_3DpuzzleA = 0,
            isl_obj_3DpuzzleB = 1,
            isl_obj_3DpuzzleC = 2,
            isl_obj_3DpuzzleD = 3,
            isl_obj_3DpuzzleE = 4,
            isl_obj_3DpuzzleF = 5,
            isl_obj_3DpuzzleG = 6,
            NumCorrectModelTypes = 7,
        };

        enum class ModelType : int8_t {
            None = -1,
            isl_obj_3DpuzzleA_piece1 = 0,
            isl_obj_3DpuzzleA_piece2 = 1,
            isl_obj_3DpuzzleA_piece3 = 2,
            isl_obj_3DpuzzleB_piece1 = 3,
            isl_obj_3DpuzzleB_piece2 = 4,
            isl_obj_3DpuzzleB_piece3 = 5,
            isl_obj_3DpuzzleC_piece1 = 6,
            isl_obj_3DpuzzleC_piece2 = 7,
            isl_obj_3DpuzzleC_piece3 = 8,
            isl_obj_3DpuzzleD_piece1 = 9,
            isl_obj_3DpuzzleD_piece2 = 10,
            isl_obj_3DpuzzleD_piece3 = 11,
            isl_obj_3DpuzzleD_piece4 = 12,
            isl_obj_3DpuzzleD_piece5 = 13,
            isl_obj_3DpuzzleE_piece1 = 14,
            isl_obj_3DpuzzleE_piece2 = 15,
            isl_obj_3DpuzzleE_piece3 = 16,
            isl_obj_3DpuzzleE_piece4 = 17,
            isl_obj_3DpuzzleE_piece5 = 18,
            isl_obj_3DpuzzleF_piece1 = 19,
            isl_obj_3DpuzzleF_piece2 = 20,
            isl_obj_3DpuzzleF_piece3 = 21,
            isl_obj_3DpuzzleF_piece4 = 22,
            isl_obj_3DpuzzleF_piece5 = 23,
            isl_obj_3DpuzzleG_piece1 = 24,
            isl_obj_3DpuzzleG_piece2 = 25,
            isl_obj_3DpuzzleG_piece3 = 26,
            isl_obj_3DpuzzleG_piece4 = 27,
            isl_obj_3DpuzzleG_piece5 = 28,
            NumModelTypes = 29,
        };

        int32_t no;
        CorrectModelType modelType;
        csl::math::Vector3 modelOffset;
        hh::game::ObjectId locator;
        ModelType correctModelOrder[5];
        heur::rfl::PuzzleSize maxPossiblePuzzleSize;
        uint8_t totalNumBlocksAvailable;
        uint8_t numVerticalCellsOfCorrectAnswer;
        uint8_t numCellsFromBlockPosForWarpEffect;
        uint8_t copyPosOffsetFromCurAnswerTop;
        uint8_t numCellsToLevitate;
        float effectScaleOnRewind;
        float effectSpeedOnRewind;
        heur::rfl::CorrectShape correctShape;
        csl::ut::MoveArray<hh::game::ObjectId> blockList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Obj3DPuzzleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Obj3DPuzzleSpawner* pInstance);
        static void Clean(Obj3DPuzzleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct WarpInfo {
        uint8_t row;
        uint8_t column;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WarpInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WarpInfo* pInstance);
        static void Clean(WarpInfo* pInstance);
    };
}

namespace heur::rfl {
    struct RotationInfo {
        enum class Rotation : uint8_t {
            Rotate_0 = 0,
            Rotate_90 = 1,
            Rotate_180 = 2,
            Rotate_270 = 3,
            NumRotations = 4,
        };

        Rotation rotationAroundY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RotationInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RotationInfo* pInstance);
        static void Clean(RotationInfo* pInstance);
    };
}

namespace heur::rfl {
    struct Obj3DPuzzleBlockSpawner {
        enum class ModelType : int8_t {
            None = -1,
            isl_obj_3DpuzzleA_piece1 = 0,
            isl_obj_3DpuzzleA_piece2 = 1,
            isl_obj_3DpuzzleA_piece3 = 2,
            isl_obj_3DpuzzleB_piece1 = 3,
            isl_obj_3DpuzzleB_piece2 = 4,
            isl_obj_3DpuzzleB_piece3 = 5,
            isl_obj_3DpuzzleC_piece1 = 6,
            isl_obj_3DpuzzleC_piece2 = 7,
            isl_obj_3DpuzzleC_piece3 = 8,
            isl_obj_3DpuzzleD_piece1 = 9,
            isl_obj_3DpuzzleD_piece2 = 10,
            isl_obj_3DpuzzleD_piece3 = 11,
            isl_obj_3DpuzzleD_piece4 = 12,
            isl_obj_3DpuzzleD_piece5 = 13,
            isl_obj_3DpuzzleE_piece1 = 14,
            isl_obj_3DpuzzleE_piece2 = 15,
            isl_obj_3DpuzzleE_piece3 = 16,
            isl_obj_3DpuzzleE_piece4 = 17,
            isl_obj_3DpuzzleE_piece5 = 18,
            isl_obj_3DpuzzleF_piece1 = 19,
            isl_obj_3DpuzzleF_piece2 = 20,
            isl_obj_3DpuzzleF_piece3 = 21,
            isl_obj_3DpuzzleF_piece4 = 22,
            isl_obj_3DpuzzleF_piece5 = 23,
            isl_obj_3DpuzzleG_piece1 = 24,
            isl_obj_3DpuzzleG_piece2 = 25,
            isl_obj_3DpuzzleG_piece3 = 26,
            isl_obj_3DpuzzleG_piece4 = 27,
            isl_obj_3DpuzzleG_piece5 = 28,
            NumModelTypes = 29,
        };

        enum class Color : uint8_t {
            Blue = 0,
            LightBlue = 1,
            Green = 2,
            Purple = 3,
            Red = 4,
            White = 5,
            Yellow = 6,
            Transparent = 7,
            NumColors = 8,
        };

        enum class PresetShape : uint8_t {
            OneBlock = 0,
            TBlock = 1,
            KuBlock = 2,
            ZBlock = 3,
            NumPresetShapes = 4,
        };

        ModelType modelType;
        uint8_t shapeID;
        hh::game::ObjectId cameraUUIDForAscendingBlock;
        hh::game::ObjectId cameraUUIDForDescendingBlock;
        float cameraSwitchDistance;
        float warpEffectScale;
        float numCellsFromOrigBaseToTop;
        heur::rfl::WarpInfo warpInfo;
        Color color;
        PresetShape presetShape;
        bool usePreset;
        heur::rfl::RotationInfo rotationInfo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Obj3DPuzzleBlockSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Obj3DPuzzleBlockSpawner* pInstance);
        static void Clean(Obj3DPuzzleBlockSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjActionChainSpawner {
        int32_t no;
        hh::game::ObjectId cameraUUID;
        float cameraEaseIn;
        float cameraEaseOut;
        float clearWaitTime;
        float cameraTime;
        uint16_t objectNumber;
        int32_t viewNo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjActionChainSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjActionChainSpawner* pInstance);
        static void Clean(ObjActionChainSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjChainBoosterSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjChainBoosterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjChainBoosterSpawner* pInstance);
        static void Clean(ObjChainBoosterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAirFloorSpawner {
        enum class SizeType : int8_t {
            SMALL = 0,
            MIDDLE = 1,
            LARGE = 2,
            SIZETYPE_NUM = 3,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        enum class EventType : int8_t {
            EVENT_NONE = 0,
            EVENT_HIDE = 1,
            EVENT_NO_MOVE = 2,
        };

        enum class ModelType : int8_t {
            MODEL_DEFAULT = 0,
            MODEL_AMY = 1,
            MODEL_KNUCKLES = 2,
            MODEL_TAILS = 3,
            MODEL_AMY_TIMESTOP = 4,
            MODELTYPE_NUM = 5,
        };

        int32_t no;
        SizeType size;
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        EventType eventDriven;
        bool isFall;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        bool isPressDead;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;
        bool isPlayMovingSE;
        bool isEnableTimeStop;
        float stopTime;
        int8_t timeStopGroupID;
        ModelType modelType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAirFloorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAirFloorSpawner* pInstance);
        static void Clean(ObjAirFloorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct AirOneWayPanelStart {
        bool eventDriven;
        bool keepLightOnFail;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AirOneWayPanelStart* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AirOneWayPanelStart* pInstance);
        static void Clean(AirOneWayPanelStart* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAirOneWayPanelSpawner {
        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class MoveStartType : int8_t {
            MOVE_START_SPAWN = 0,
            MOVE_START_STARTPANEL = 1,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        bool isStart;
        heur::rfl::AirOneWayPanelStart startParam;
        MoveType moveType;
        MoveStartType moveStartType;
        PatrolType patrolType;
        TimeType timeType;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        bool isPressDead;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAirOneWayPanelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAirOneWayPanelSpawner* pInstance);
        static void Clean(ObjAirOneWayPanelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAirOneWayPanelManagerSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> panelList;
        hh::game::ObjectId firstStartPanel;
        bool useTimer;
        float time;
        hh::game::ObjectId camActivator;
        float startWaitTime;
        float playerDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAirOneWayPanelManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAirOneWayPanelManagerSpawner* pInstance);
        static void Clean(ObjAirOneWayPanelManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAirWallSpawner {
        enum class SizeType : int8_t {
            SMALL = 0,
            MIDDLE = 1,
            LARGE = 2,
            SIZETYPE_NUM = 3,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        enum class WallType : int8_t {
            NORMAL_WALL = 0,
            PARKOUR_WALL = 1,
            AMY_WALL = 2,
            KNUCKLES_WALL = 3,
            TAILS_WALL = 4,
        };

        enum class EventType : int8_t {
            EVENT_NONE = 0,
            EVENT_HIDE = 1,
            EVENT_NO_MOVE = 2,
        };

        int32_t no;
        SizeType size;
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        WallType wallType;
        EventType eventDriven;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        bool isPressDead;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;
        bool useConvex;
        bool useShadowCast;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAirWallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAirWallSpawner* pInstance);
        static void Clean(ObjAirWallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjApproachStatueSpawner {
        float noticeDistance;
        float gravity;
        float angularVelocity;
        float moveVelocity;
        float moveDuration;
        float moveBeforeWait;
        float moveAfterWait;
        float blowPowerZ;
        float blowPowerY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjApproachStatueSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjApproachStatueSpawner* pInstance);
        static void Clean(ObjApproachStatueSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PassPlaneTriggerSpawner {
        float width;
        float height;
        csl::math::Vector3 offset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PassPlaneTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PassPlaneTriggerSpawner* pInstance);
        static void Clean(PassPlaneTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct AutorunTriggerSpawner {
        enum class ActionType : int8_t {
            ACT_START = 0,
            ACT_FINISH = 1,
        };

        enum class JumpMode : int8_t {
            WorldSpace = 0,
            PathSpace = 1,
            NoneJump = 2,
        };

        ActionType action;
        csl::ut::VariableString pathName;
        float speed;
        float speedMin;
        float boostSpeed;
        float boostSpeedMin;
        float boostLvMaxSpeed;
        float boostLvMaxSpeedMin;
        float initialSpeed;
        float outOfControlTime;
        float width;
        float limitTime;
        JumpMode jumpMode;
        bool forceFall;
        bool endByAir;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AutorunTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AutorunTriggerSpawner* pInstance);
        static void Clean(AutorunTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct AutorunVolumeSpawner {
        enum class StateType : int8_t {
            DEFAULTSTATE_ON = 0,
            DEFAULTSTATE_OFF = 1,
        };

        enum class ActionType : int8_t {
            ACTION_EACHTIME = 0,
            ACTION_ONCE = 1,
        };

        enum class JumpMode : int8_t {
            WorldSpace = 0,
            PathSpace = 1,
            NoneJump = 2,
        };

        enum class MoveMode : int8_t {
            MoveWorldSpace = 0,
            MovePathSpace = 1,
        };

        csl::ut::VariableString pathName;
        float speed;
        float speedMin;
        float boostSpeed;
        float boostSpeedMin;
        float boostLvMaxSpeed;
        float boostLvMaxSpeedMin;
        float initialSpeed;
        float outOfControlTime;
        float width;
        StateType state;
        ActionType action;
        JumpMode jumpMode;
        MoveMode moveMode;
        bool forceFall;
        bool endByAir;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AutorunVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AutorunVolumeSpawner* pInstance);
        static void Clean(AutorunVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBallLaunchTriggerSpawner {
        csl::ut::VariableString pathName;
        float minSpeed;
        float maxSpeed;
        bool reverse;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBallLaunchTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBallLaunchTriggerSpawner* pInstance);
        static void Clean(ObjBallLaunchTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBallMoveTriggerSpawner {
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBallMoveTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBallMoveTriggerSpawner* pInstance);
        static void Clean(ObjBallMoveTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBatterBoxSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBatterBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBatterBoxSpawner* pInstance);
        static void Clean(ObjBatterBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GimmickCameraOptionalParam {
        bool useCameraParam;
        float interoplateTimeActivate;
        float interoplateTimeDeactivate;
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraPosOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GimmickCameraOptionalParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GimmickCameraOptionalParam* pInstance);
        static void Clean(GimmickCameraOptionalParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBattingMachineManagerSpawner {
        int32_t no;
        float limitTime;
        int32_t boundingTotalNum;
        hh::game::ObjectId batterBox;
        hh::game::ObjectId pitchingMachine;
        heur::rfl::GimmickCameraOptionalParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBattingMachineManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBattingMachineManagerSpawner* pInstance);
        static void Clean(ObjBattingMachineManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPitchingMachineSpawner {
        int32_t no;
        float coolDown;
        float coolDownRandom;
        float shootVelocity;
        float lifeTime;
        hh::game::ObjectId batterBox;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPitchingMachineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPitchingMachineSpawner* pInstance);
        static void Clean(ObjPitchingMachineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BeetonIMoveParam {
        enum class BeetonMoveType : int8_t {
            FIXED = 0,
            TWO_POINT = 1,
            PATH = 2,
        };

        BeetonMoveType moveType;
        csl::math::Vector3 destOffset;
        csl::ut::VariableString pathName;
        float moveSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BeetonIMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BeetonIMoveParam* pInstance);
        static void Clean(BeetonIMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct BeetonIAttackParam {
        bool isAttack;
        float bulletSpeed;
        float prepareTime;
        int32_t shotsNum;
        float fireRate;
        float fireInterval;
        float searchDistance;
        float searchAngle;
        float bulletLifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BeetonIAttackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BeetonIAttackParam* pInstance);
        static void Clean(BeetonIAttackParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBeetonISpawner {
        bool isFV;
        heur::rfl::BeetonIMoveParam moveParam;
        heur::rfl::BeetonIAttackParam attackParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBeetonISpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBeetonISpawner* pInstance);
        static void Clean(ObjBeetonISpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBlockageVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBlockageVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBlockageVolumeSpawner* pInstance);
        static void Clean(ObjBlockageVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBlockColliderSpawner {
        enum class Shape : int8_t {
            Box = 0,
            Sphere = 1,
            Capsule = 2,
            NumShapes = 3,
        };

        Shape shape;
        csl::math::Vector3 offset;
        csl::math::Vector3 extents;
        float radius;
        float height;
        bool collidesWithCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBlockColliderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBlockColliderSpawner* pInstance);
        static void Clean(ObjBlockColliderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBlockObjectSpawner {
        enum class ActionType : int8_t {
            ACT_TERRAIN = 0,
            ACT_RAYBLOCK = 1,
        };

        csl::math::Vector3 size;
        bool initial;
        bool unsupported;
        ActionType action;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBlockObjectSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBlockObjectSpawner* pInstance);
        static void Clean(ObjBlockObjectSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBombSpawner {
        enum class Visual : int8_t {
            ContactBomb = 0,
            TimeBomb = 1,
            ContactTimeBomb = 2,
            Num = 3,
        };

        Visual visual;
        float timeTilExplode;
        float timeFlickerGetFasterAt;
        float flickerInterval;
        float explosionColliderDuration;
        float detectionRadius;
        float explosionRadius;
        float flickerSpeed1;
        float flickerSpeed2;
        float damageVelocityMultiplier;
        float velocityYOnStumble;
        float velocityYOnBlowup;
        float blowupSonicSpeedThreshold;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBombSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBombSpawner* pInstance);
        static void Clean(ObjBombSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBombBoxSpawner {
        bool isTimer;
        float detectionRange;
        float bombTime;
        float alertTime;
        float stopTime;
        bool eventDriven;
        float releaseAngle;
        float releaseSpeed;
        float gravity;
        float cyActionOffsetY;
        bool isRespawn;
        float respawnTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBombBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBombBoxSpawner* pInstance);
        static void Clean(ObjBombBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBombBreakBoxSpawner {
        enum class BoxSize : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_NUM = 3,
        };

        BoxSize size;
        bool eventDriven;
        bool isRespawn;
        float respawnTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBombBreakBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBombBreakBoxSpawner* pInstance);
        static void Clean(ObjBombBreakBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBombBreakWallSpawner {
        enum class WallSize : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_NUM = 3,
        };

        WallSize size;
        bool eventDriven;
        bool isRespawn;
        float respawnTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBombBreakWallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBombBreakWallSpawner* pInstance);
        static void Clean(ObjBombBreakWallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossBitManagerSpawner {
        bool use;
        csl::ut::MoveArray<hh::game::ObjectId> bitIds;
        csl::ut::VariableString waveName;
        bool turnToTarget;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossBitManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossBitManagerSpawner* pInstance);
        static void Clean(ObjBossBitManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossLargeBitSpawner {
        float offsetHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossLargeBitSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossLargeBitSpawner* pInstance);
        static void Clean(ObjBossLargeBitSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossSmallBitSpawner {
        int32_t patternIndexs[64];
        float offsetHeight;
        bool isOutsideDirFix;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossSmallBitSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossSmallBitSpawner* pInstance);
        static void Clean(ObjBossSmallBitSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossMinionSpawner {
        float speed;
        float liveTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossMinionSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossMinionSpawner* pInstance);
        static void Clean(ObjBossMinionSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBreakableColumnSpawner {
        int32_t no;
        bool alreadyBroken;
        float breakTimeLimit;
        float breakExtendTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBreakableColumnSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBreakableColumnSpawner* pInstance);
        static void Clean(ObjBreakableColumnSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBreakBoxSpawner {
        enum class BoxSize : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_NUM = 3,
        };

        BoxSize size;
        bool isHATarget;
        int32_t maxHits;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBreakBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBreakBoxSpawner* pInstance);
        static void Clean(ObjBreakBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBreakWallSpawner {
        enum class WallSize : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_NUM = 3,
        };

        enum class RespawnType : int8_t {
            None = 0,
            Time = 1,
            TimeAndRangeOut = 2,
        };

        WallSize size;
        bool isHATarget;
        int32_t maxHits;
        RespawnType respawn;
        float respawnTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBreakWallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBreakWallSpawner* pInstance);
        static void Clean(ObjBreakWallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct InterpolateSettings {
        enum class InterpolateType : int8_t {
            INTERPOLATE_RELATIVE = 0,
            INTERPOLATE_ABSOLUTE = 1,
            INTERPOLATE_ABSOLUTE_COORD = 2,
        };

        float easeTimeOn;
        float easeTimeOff;
        InterpolateType interpolateTypeOn;
        InterpolateType interpolateTypeOff;
        bool useReturnCamera;
        hh::game::ObjectId returnCameraTarget;
        float returnCameraHeight;
        float returnCameraInterpolateRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(InterpolateSettings* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(InterpolateSettings* pInstance);
        static void Clean(InterpolateSettings* pInstance);
    };
}

namespace heur::rfl {
    struct FadeSettings {
        float fadeOutTimeOn;
        float fadeStayTimeOn;
        float fadeInTimeOn;
        float fadeOutTimeOff;
        float fadeStayTimeOff;
        float fadeInTimeOff;
        bool stopWhenFade;
        float resumeDelayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FadeSettings* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FadeSettings* pInstance);
        static void Clean(FadeSettings* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraActivatorSpawner {
        enum class ActivateType : int8_t {
            INTERPOLATE = 0,
            FADE = 1,
        };

        enum class PlayerDisableType : int8_t {
            FROZEN = 0,
            HOLD = 1,
        };

        enum class PurposeOfUseCameraActivator : int8_t {
            Normal = 0,
            Quest = 1,
            NumUses = 2,
        };

        enum class Value : int8_t {
            KodamaCollection01 = 0,
            Mowing = 1,
            KodamaEscort = 2,
            KodamaCollection02 = 3,
            DarumaBattle = 4,
            CollectItem = 5,
            DrawBridge = 6,
            NumQuestTypes = 7,
        };

        hh::game::ObjectId target;
        ActivateType type;
        uint32_t priority;
        bool useHighPriority;
        float delayTime;
        bool enableLifeTime;
        float lifeTime;
        bool disableControl;
        PlayerDisableType disableType;
        bool isPause;
        heur::rfl::InterpolateSettings interpolate;
        heur::rfl::FadeSettings fade;
        PurposeOfUseCameraActivator purposeOfUse;
        Value questType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraActivatorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraActivatorSpawner* pInstance);
        static void Clean(ObjCameraActivatorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCannonTypeSpawner {
        enum class AimingType : int8_t {
            Direction = 0,
            Player = 1,
        };

        AimingType aimingType;
        csl::math::Vector3 aimingDirection;
        int8_t continuousShootingCount;
        float continuousShootingInterval;
        float shootingInterval;
        float cannonballSpeed;
        float cannonballSpeedReverse;
        float searchingRange;
        float cannonballLifeTime;
        float cannonballLifeRange;
        bool canHomingAttack;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCannonTypeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCannonTypeSpawner* pInstance);
        static void Clean(ObjCannonTypeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCannonTypeCannonballSpawner {
        int8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCannonTypeCannonballSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCannonTypeCannonballSpawner* pInstance);
        static void Clean(ObjCannonTypeCannonballSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCautionVolumeSpawner {
        enum class CautionType : int8_t {
            CAUTIONTYPE_NONE = -1,
            CAUTIONTYPE_EXCLAMATION = 0,
            CAUTIONTYPE_QUICK_STEP = 1,
            CAUTIONTYPE_DRIFT = 2,
        };

        enum class NaviType : int8_t {
            NAVITYPE_NONE = 0,
            NAVITYPE_JUMP = 1,
            NAVITYPE_SLIDING = 2,
            NAVITYPE_BOOST = 3,
            NAVITYPE_STEP_BOTH = 4,
            NAVITYPE_STEP_L = 5,
            NAVITYPE_STEP_R = 6,
            NAVITYPE_HORMING_ATTACK = 7,
            NAVITYPE_STOMPING = 8,
            NAVITYPE_SPIN_DASH = 9,
            NAVITYPE_GRIND_MOVE = 10,
            NAVITYPE_BADDY_CHANGE = 11,
            NAVITYPE_COUNT = 12,
        };

        bool isHideIfInput;
        CautionType cautionType;
        NaviType naviType;
        bool isSwitch;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCautionVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCautionVolumeSpawner* pInstance);
        static void Clean(ObjCautionVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDropChaosEmeraldSpawner {
        int32_t no;
        int32_t chaosEmeraldType;
        csl::math::Vector3 velocity;
        float horzDamp;
        float reflection;
        bool geditSet;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDropChaosEmeraldSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDropChaosEmeraldSpawner* pInstance);
        static void Clean(ObjDropChaosEmeraldSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjChaosEmeraldPillarSpawner {
        enum class Value : int8_t {
            Blue = 0,
            LightBlue = 1,
            Green = 2,
            Purple = 3,
            Red = 4,
            White = 5,
            Yellow = 6,
            Num = 7,
        };

        enum class OverrideEffectType : int8_t {
            NONE = 0,
            PYRAMID_LONG = 1,
            PYRAMID_SHORT = 2,
        };

        int32_t no;
        Value color;
        OverrideEffectType overrideEffectType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjChaosEmeraldPillarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjChaosEmeraldPillarSpawner* pInstance);
        static void Clean(ObjChaosEmeraldPillarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBreakChaosEmeraldStorageSpawner {
        enum class Value : int8_t {
            Blue = 0,
            LightBlue = 1,
            Green = 2,
            Purple = 3,
            Red = 4,
            White = 5,
            Yellow = 6,
            Num = 7,
        };

        int32_t no;
        bool isSequence;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;
        Value color;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBreakChaosEmeraldStorageSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBreakChaosEmeraldStorageSpawner* pInstance);
        static void Clean(ObjBreakChaosEmeraldStorageSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjChaosEmeraldStorageSpawner {
        enum class Value : int8_t {
            Blue = 0,
            LightBlue = 1,
            Green = 2,
            Purple = 3,
            Red = 4,
            White = 5,
            Yellow = 6,
            Num = 7,
        };

        int32_t no;
        Value color;
        int8_t unlockOrder;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjChaosEmeraldStorageSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjChaosEmeraldStorageSpawner* pInstance);
        static void Clean(ObjChaosEmeraldStorageSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjClimbingPointSpawner {
        float radius;
        bool terminal;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjClimbingPointSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjClimbingPointSpawner* pInstance);
        static void Clean(ObjClimbingPointSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCyActionSignSpawner {
        enum class Visual : int8_t {
            Normal = 0,
            Sky = 1,
        };

        enum class HoleDirection : int8_t {
            CyActionSignDir = 0,
            ObjectDir = 1,
        };

        Visual visual;
        csl::ut::MoveArray<hh::game::ObjectId> objAmyList;
        csl::ut::MoveArray<hh::game::ObjectId> objKnucklesList;
        csl::ut::MoveArray<hh::game::ObjectId> objTailsList;
        HoleDirection holeDirection;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCyActionSignSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCyActionSignSpawner* pInstance);
        static void Clean(ObjCyActionSignSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCyloopTraceManagerSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> volumeList;
        hh::game::ObjectId samplePoint;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCyloopTraceManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCyloopTraceManagerSpawner* pInstance);
        static void Clean(ObjCyloopTraceManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCyloopTracePointSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCyloopTracePointSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCyloopTracePointSpawner* pInstance);
        static void Clean(ObjCyloopTracePointSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCyloopTraceVolumeSpawner {
        enum class AdditionalColliderShape : int8_t {
            Cylinder = 0,
            Box = 1,
            NumShapes = 2,
        };

        int32_t no;
        AdditionalColliderShape additionalColliderShape;
        csl::math::Vector3 extents;
        float radius;
        float height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCyloopTraceVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCyloopTraceVolumeSpawner* pInstance);
        static void Clean(ObjCyloopTraceVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct DamegeVolumeTarget {
        csl::ut::MoveArray<hh::game::ObjectId> objects;
        int32_t damagePoint;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DamegeVolumeTarget* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DamegeVolumeTarget* pInstance);
        static void Clean(DamegeVolumeTarget* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDamageVolumeSpawner {
        enum class Type : int8_t {
            TypeOnce = 0,
            TypeReuse = 1,
        };

        Type type;
        bool eventDriven;
        heur::rfl::VolumeTriggerSpawner volume;
        heur::rfl::DamegeVolumeTarget targets[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDamageVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDamageVolumeSpawner* pInstance);
        static void Clean(ObjDamageVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct DashPanelPathAdjustParameter {
        csl::ut::VariableString pathname;
        float adjustSpeed;
        float adjustTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DashPanelPathAdjustParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DashPanelPathAdjustParameter* pInstance);
        static void Clean(DashPanelPathAdjustParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDashPanelSpawner {
        enum class ChangeType : int8_t {
            CHANGE_NONE = 0,
            CHANGE_BOARDING = 1,
            CHANGE_RUN = 2,
        };

        float ocTime;
        float speed;
        bool isVisible;
        heur::rfl::ActionNotification actions[3];
        heur::rfl::DashPanelPathAdjustParameter adjustPath;
        bool isCyloopOn;
        float cyloopSignDistance;
        float cyloopSignTolerance;
        bool isCyKnuckleOn;
        ChangeType changeType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDashPanelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDashPanelSpawner* pInstance);
        static void Clean(ObjDashPanelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDashRollerSpawner : heur::rfl::ObjDashPanelSpawner {
        enum class Visual : int8_t {
            NORMAL = 0,
            GR = 1,
            SV = 2,
            NUM_VISUALS = 3,
        };

        Visual visual;
        bool isCyloopOn;
        float cyloopSignDistance;
        float cyloopSignTolerance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDashRollerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDashRollerSpawner* pInstance);
        static void Clean(ObjDashRollerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PathMovement {
        enum class MoveType : int8_t {
            FIXED = 0,
            PATH = 1,
            TWO_POINT = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
            PATROL_ONEWAY_KILL = 3,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        MoveType moveType;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        csl::math::Vector3 twoPointOffset;
        PatrolType patrolType;
        TimeType timeType;
        bool eventDriven;
        bool isReverse;
        float waitTime;
        float phase;
        float speed;
        float killWaitTSecOneway;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathMovement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathMovement* pInstance);
        static void Clean(PathMovement* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDashRingSpawner {
        enum class Visual : int8_t {
            DashRing = 0,
            RainbowRing = 1,
            HeartRing = 2,
            None = 3,
            Num = 4,
        };

        Visual visual;
        float OutOfControl;
        float KeepVelocity;
        float Speed;
        bool PosConst;
        bool VeloConst;
        bool Spin;
        bool AirTrick;
        heur::rfl::ActionNotification actions[3];
        heur::rfl::PathMovement pathMovement;
        csl::math::Vector3 collisionScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDashRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDashRingSpawner* pInstance);
        static void Clean(ObjDashRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjIgnoreDeadlineSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjIgnoreDeadlineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjIgnoreDeadlineSpawner* pInstance);
        static void Clean(ObjIgnoreDeadlineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDebugNoteSpawner {
        enum class ColorType : int8_t {
            TYPE_WHITE = 0,
            TYPE_BLACK = 1,
            TYPE_RED = 2,
            TYPE_GREEN = 3,
            TYPE_BLUE = 4,
            TYPE_YELLOW = 5,
        };

        csl::ut::VariableString memoText;
        ColorType colorType;
        float radius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDebugNoteSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDebugNoteSpawner* pInstance);
        static void Clean(ObjDebugNoteSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDimensionVolumeSpawner {
        enum class StateType : int8_t {
            DEFAULTSTATE_ON = 0,
            DEFAULTSTATE_OFF = 1,
        };

        enum class ActionType : int8_t {
            ACTION_EACHTIME = 0,
            ACTION_ONCE = 1,
        };

        bool isSideview;
        uint32_t priority;
        csl::ut::VariableString pathName;
        StateType state;
        ActionType action;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDimensionVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDimensionVolumeSpawner* pInstance);
        static void Clean(ObjDimensionVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDivingVolumeSpawner {
        enum class StateType : int8_t {
            DEFAULTSTATE_ON = 0,
            DEFAULTSTATE_OFF = 1,
        };

        enum class ActionType : int8_t {
            ACTION_EACHTIME = 0,
            ACTION_ONCE = 1,
        };

        bool limit;
        float easeTimeEnter;
        float easeTimeLeave;
        float outOfControlTime;
        float waitTime;
        bool velocityReset;
        StateType state;
        ActionType action;
        heur::rfl::VolumeTriggerSpawner volume;
        bool isEnableHomingAttack;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDivingVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDivingVolumeSpawner* pInstance);
        static void Clean(ObjDivingVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDoveSpawner {
        int32_t no;
        bool enableEscape;
        float searchDistance;
        float destroyTime;
        float flySpeed;
        csl::math::Vector3 flyForceOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDoveSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDoveSpawner* pInstance);
        static void Clean(ObjDoveSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct RingParameter {
        float suckedTime;
        float launchAngle;
        float launchMaxSpeed;
        float launchMinSpeed;
        float randomRangeMin;
        float randomRangeMax;
        float lifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RingParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RingParameter* pInstance);
        static void Clean(RingParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDroppedItemSpawner {
        enum class ItemType : int8_t {
            RING = 0,
            SKILL_PIECE = 1,
            PORTAL_BIT = 2,
            POWER_SEED = 3,
            GUARD_SEED = 4,
            SEQUENCE_ITEM = 5,
        };

        int32_t no;
        ItemType type;
        int32_t viewItemNum;
        int32_t getItemNum;
        bool cyloopDriven;
        float cyloopSignDistance;
        float cyloopSignTolerance;
        heur::rfl::RingParameter ringParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDroppedItemSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDroppedItemSpawner* pInstance);
        static void Clean(ObjDroppedItemSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEffectFlowDustSpawner {
        bool wind;
        float emitInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEffectFlowDustSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEffectFlowDustSpawner* pInstance);
        static void Clean(ObjEffectFlowDustSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjElectricLineSpawner {
        int32_t no;
        csl::ut::VariableString pathName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjElectricLineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjElectricLineSpawner* pInstance);
        static void Clean(ObjElectricLineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEscapeLightSpawner {
        int32_t no;
        bool eventDriven;
        csl::ut::VariableString pathName;
        float velocity;
        float duration;
        float catchDistance;
        float markerDistance;
        float progressReduction;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEscapeLightSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEscapeLightSpawner* pInstance);
        static void Clean(ObjEscapeLightSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EventCameraParam {
        float camInterpolateTimeOnStart;
        float camInterpolateTimeOnFinish;
        bool setCameraLookAt;
        hh::game::ObjectId cameraLookAtTarget;
        csl::math::Vector3 cameraLookAt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EventCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EventCameraParam* pInstance);
        static void Clean(EventCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEventSpawner {
        int32_t no;
        csl::ut::VariableString eventID;
        csl::ut::VariableString pageName;
        int32_t pageIndex;
        bool useDefaultPath;
        bool showEnemy;
        bool playerAfterIdle;
        bool isSkipDisable;
        bool isFrozen;
        heur::rfl::EventCameraParam camera;
        hh::game::ObjectId playerTrans;
        bool limitFps30;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEventSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEventSpawner* pInstance);
        static void Clean(ObjEventSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EventOrder {
        enum class ConditionType : int8_t {
            CONDITION_ALL = 0,
            CONDITION_OR = 1,
        };

        csl::ut::MoveArray<hh::game::ObjectId> targetList;
        ConditionType condition;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EventOrder* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EventOrder* pInstance);
        static void Clean(EventOrder* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEventOrderHubSpawner {
        csl::ut::VariableString puzzleID;
        heur::rfl::EventOrder orders[8];
        csl::ut::VariableString correctLuaName;
        csl::ut::VariableString incorrectLuaName;
        heur::rfl::ActionNotification correctActions[5];
        heur::rfl::ActionNotification incorrectActions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEventOrderHubSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEventOrderHubSpawner* pInstance);
        static void Clean(ObjEventOrderHubSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEventSetterSpawner {
        enum class TriggerType : int8_t {
            TRIGERTYPE_DEAD = 0,
            TRIGGERTYPE_ON = 1,
            TRIGGERTYPE_OFF = 2,
            TRIGGERTYPE_OFF_TO_ON = 3,
            TRIGGERTYPE_ON_TO_OFF = 4,
        };

        enum class ConditionType : int8_t {
            CONDITION_ALL = 0,
            CONDITION_OR = 1,
        };

        enum class Time : int8_t {
            TIMESTYPE_ONCE = 0,
            TIMESTYPE_SEVERAL = 1,
        };

        int32_t no;
        csl::ut::VariableString puzzleID;
        csl::ut::MoveArray<hh::game::ObjectId> TargetList;
        TriggerType Trigger;
        ConditionType Condition;
        Time TimesType;
        csl::ut::VariableString luaName;
        heur::rfl::ActionNotification actions[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEventSetterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEventSetterSpawner* pInstance);
        static void Clean(ObjEventSetterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEventVolumeSpawner {
        int32_t no;
        heur::rfl::VolumeTriggerSpawner volume;
        csl::ut::VariableString enterEvent;
        csl::ut::VariableString leaveEvent;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEventVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEventVolumeSpawner* pInstance);
        static void Clean(ObjEventVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PassPlaneCylinderTriggerSpawner {
        float radius;
        csl::math::Vector3 offset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PassPlaneCylinderTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PassPlaneCylinderTriggerSpawner* pInstance);
        static void Clean(PassPlaneCylinderTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjExDashRingSpawner {
        float OutOfControl;
        float KeepVelocity;
        float Speed;
        bool VeloConst;
        csl::math::Vector3 collisionScale;
        bool eventDriven;
        heur::rfl::ActionNotification actions[3];
        heur::rfl::PassPlaneCylinderTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjExDashRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjExDashRingSpawner* pInstance);
        static void Clean(ObjExDashRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjExtendPillarSpawner {
        int32_t no;
        float minHeight;
        float maxHeight;
        bool isUseTime;
        float extendTime;
        heur::rfl::GimmickCameraOptionalParam cameraParam;
        bool isUpdPlayerHold;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjExtendPillarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjExtendPillarSpawner* pInstance);
        static void Clean(ObjExtendPillarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFallDeadTriggerSpawner {
        enum class DrivenType : int8_t {
            DRIVE_RANGE = 0,
            DRIVE_EVENT = 1,
        };

        DrivenType drive;
        float distance;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFallDeadTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFallDeadTriggerSpawner* pInstance);
        static void Clean(ObjFallDeadTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFallReturnVolumeSpawner {
        hh::game::ObjectId returnPoint;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFallReturnVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFallReturnVolumeSpawner* pInstance);
        static void Clean(ObjFallReturnVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFanSpawner {
        enum class Type : int8_t {
            TYPE_ON = 0,
            TYPE_CYCLE = 1,
        };

        enum class Place : int8_t {
            ON_GROUND = 0,
            IN_AIR = 1,
            NUM_PLACES = 2,
        };

        Type type;
        Place place;
        float length;
        float velocity;
        float durOn;
        float durOff;
        float phase;
        bool eventDriven;
        bool isConstrain;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFanSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFanSpawner* pInstance);
        static void Clean(ObjFanSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFireworkCactusSpawner {
        int32_t no;
        hh::game::ObjectId cactusManager;
        bool respawnableByMeteorShower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFireworkCactusSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFireworkCactusSpawner* pInstance);
        static void Clean(ObjFireworkCactusSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFireworkCactusManagerSpawner {
        enum class CameraType : uint8_t {
            CHARA = 0,
            FIX = 1,
            OBJECT = 2,
        };

        int32_t no;
        float time;
        CameraType cameraType;
        csl::math::Vector3 cameraPos;
        hh::game::ObjectId cameraLocator;
        heur::rfl::GimmickCameraOptionalParam cameraParam;
        int32_t dropRingNum[5];
        float dropRingHeight;
        heur::rfl::RingParameter ringParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFireworkCactusManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFireworkCactusManagerSpawner* pInstance);
        static void Clean(ObjFireworkCactusManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFishCASpawner {
        enum class FishKind : int8_t {
            Salmon = 0,
            Carp = 1,
            Blackbass = 2,
            FISH_KIND_NUM = 3,
        };

        FishKind kind;
        float scale;
        float offsetY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFishCASpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFishCASpawner* pInstance);
        static void Clean(ObjFishCASpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFishingPortalSpawner {
        int32_t no;
        int32_t spotId;
        hh::game::ObjectId fastTravelLocator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFishingPortalSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFishingPortalSpawner* pInstance);
        static void Clean(ObjFishingPortalSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFlaggedSwitchVolumeSpawner {
        enum class Condition : int8_t {
            COND_ON_TRIGGER = 0,
            COND_PULSE = 1,
            COND_TIMER_ONCE = 2,
            COND_TIMER = 3,
            COND_ON_STAY = 4,
        };

        int32_t no;
        Condition condition;
        float lifetime;
        bool eventDriven;
        heur::rfl::VolumeTriggerSpawner volume;
        heur::rfl::ActionNotification actions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFlaggedSwitchVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFlaggedSwitchVolumeSpawner* pInstance);
        static void Clean(ObjFlaggedSwitchVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFloatIslandSpawner {
        enum class SizeType : int8_t {
            SMALL = 0,
            MIDDLE = 1,
            LARGE = 2,
            SIZETYPE_NUM = 3,
        };

        SizeType size;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFloatIslandSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFloatIslandSpawner* pInstance);
        static void Clean(ObjFloatIslandSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFloatTopSpawner {
        float moveSpeed;
        float driveTime;
        float widthLimit;
        float depthLimit;
        hh::game::ObjectId cameraActivator;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFloatTopSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFloatTopSpawner* pInstance);
        static void Clean(ObjFloatTopSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFloorPuzzleSwitchSpawner {
        enum class Condition : int8_t {
            COND_ENTER = 0,
            COND_TIMER = 1,
            COND_STAY = 2,
        };

        enum class ObjectWeightType : int8_t {
            OBJECT_WEIGHT_NONE = 0,
            OBJECT_WEIGHT_LIGHT = 1,
            OBJECT_WEIGHT_NORMAL = 2,
            OBJECT_WEIGHT_HEAVY = 3,
        };

        int32_t no;
        bool eventDriven;
        Condition condition;
        float activateTime;
        ObjectWeightType weightType;
        bool isViewTimer;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFloorPuzzleSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFloorPuzzleSwitchSpawner* pInstance);
        static void Clean(ObjFloorPuzzleSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFriendsEmeraldEngineSpawner {
        enum class ChaosEmeraldColor : int8_t {
            Blue = 0,
            LightBlue = 1,
            Green = 2,
            Purple = 3,
            Red = 4,
            White = 5,
            Yellow = 6,
        };

        enum class Value : int8_t {
            Invalid = -1,
            Sonic = 0,
            Amy = 1,
            Knuckles = 2,
            Tails = 3,
            Num = 4,
            Default = 0,
        };

        int32_t no;
        ChaosEmeraldColor color;
        Value characterType;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;
        bool scriptOperation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFriendsEmeraldEngineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFriendsEmeraldEngineSpawner* pInstance);
        static void Clean(ObjFriendsEmeraldEngineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGameEndVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;
        bool isReleaseOnly;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGameEndVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGameEndVolumeSpawner* pInstance);
        static void Clean(ObjGameEndVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GateDefaultCamera {
        csl::math::Vector3 camEyeOffset;
        float easeTimeOn;
        float easeTimeOff;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GateDefaultCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GateDefaultCamera* pInstance);
        static void Clean(GateDefaultCamera* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGateSpawner {
        int32_t no;
        bool useExternalCam;
        heur::rfl::GateDefaultCamera defaultCam;
        float scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGateSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGateSpawner* pInstance);
        static void Clean(ObjGateSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGaugePuzzleSwitchSpawner {
        enum class Condition : int8_t {
            COND_ONCE = 0,
            COND_TIMER = 1,
        };

        int32_t no;
        Condition condition;
        float activateTime;
        float upTime;
        float downTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGaugePuzzleSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGaugePuzzleSwitchSpawner* pInstance);
        static void Clean(ObjGaugePuzzleSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantCannonSpawner_Camera {
        enum class OffsetSpace : int32_t {
            Base = 0,
            Turret = 1,
            Barrel = 2,
        };

        OffsetSpace offsetSpace;
        csl::math::Vector3 positionOffset;
        csl::math::Vector3 targetOffset;
        float fovy;
        float interpolateTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantCannonSpawner_Camera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantCannonSpawner_Camera* pInstance);
        static void Clean(ObjGiantCannonSpawner_Camera* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantCannonSpawner {
        heur::rfl::ObjGiantCannonSpawner_Camera loadingCamera;
        heur::rfl::ObjGiantCannonSpawner_Camera aimCamera;
        heur::rfl::ObjGiantCannonSpawner_Camera shootCamera;
        float loadingTriggerRadius;
        hh::game::ObjectId loadingPlayerPosition;
        float loadingWaitTime;
        float turretRotateSpeed;
        float barrelRotateSpeed;
        float shootSpeed;
        float waitResultLimitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantCannonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantCannonSpawner* pInstance);
        static void Clean(ObjGiantCannonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantDrainPlugSpawner {
        float eventWaitTime;
        csl::ut::MoveArray<hh::game::ObjectId> eventHiddenList;
        hh::game::ObjectId afterEventPosition;
        hh::game::ObjectId afterEventLookAt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantDrainPlugSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantDrainPlugSpawner* pInstance);
        static void Clean(ObjGiantDrainPlugSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantIncidentPillarSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantIncidentPillarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantIncidentPillarSpawner* pInstance);
        static void Clean(ObjGiantIncidentPillarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGimmickInfoSpawner {
        enum class PlayType : int8_t {
            TYPE_ANYTIME = 0,
            TYPE_NOONONLY = 1,
            TYPE_NIGHTONLY = 2,
            TYPE_WAITTIME = 3,
        };

        int32_t no;
        bool eventDriven;
        csl::ut::VariableString puzzleID;
        csl::ut::MoveArray<hh::game::ObjectId> childInfo;
        csl::ut::MoveArray<hh::game::ObjectId> childLogic;
        csl::ut::MoveArray<hh::game::ObjectId> childEvent;
        csl::ut::VariableString luaName;
        bool isHideMapIcon;
        bool isPuzzle;
        PlayType playType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGimmickInfoSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGimmickInfoSpawner* pInstance);
        static void Clean(ObjGimmickInfoSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGimmickScriptSpawner {
        int32_t no;
        csl::ut::VariableString luaName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGimmickScriptSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGimmickScriptSpawner* pInstance);
        static void Clean(ObjGimmickScriptSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct DropItemParam {
        enum class ItemType : int8_t {
            NONE = 0,
            RING = 1,
            SKILL_PIECE = 2,
            POWER_SEED = 3,
            GUARD_SEED = 4,
            QUEST_ITEM = 5,
            SKILL_PIECE_AMY = 6,
            SKILL_PIECE_KNUCKLES = 7,
            SKILL_PIECE_TAILS = 8,
        };

        ItemType dropItem;
        int32_t dropNum;
        int32_t dropSuperRingNum;
        float velocity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DropItemParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DropItemParam* pInstance);
        static void Clean(DropItemParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGismoSpawner {
        int32_t no;
        csl::ut::VariableString name;
        float scale;
        bool enableInstance;
        csl::ut::VariableString giTextureName;
        csl::ut::VariableString giOcclusionTextureName;
        heur::rfl::DropItemParam dropItemParam;
        bool isMovable;
        bool respawnableByMeteorShower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGismoSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGismoSpawner* pInstance);
        static void Clean(ObjGismoSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGrindBoosterSpawner {
        float ocTime;
        float speed;
        float keepVelocityTime;
        bool isVisible;
        bool reverse;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGrindBoosterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGrindBoosterSpawner* pInstance);
        static void Clean(ObjGrindBoosterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGrindLaserSpawner {
        enum class LaserType : int8_t {
            Permanent = 0,
            Time = 1,
        };

        float standHeight;
        csl::math::Vector3 endPos;
        LaserType laserType;
        float endTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGrindLaserSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGrindLaserSpawner* pInstance);
        static void Clean(ObjGrindLaserSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGrowFlowerSpawner {
        int32_t no;
        bool isFlower;
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGrowFlowerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGrowFlowerSpawner* pInstance);
        static void Clean(ObjGrowFlowerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGuideLightSpawner {
        enum class SetType : int8_t {
            EquallySpaced = 0,
            NodeID = 1,
        };

        int32_t no;
        csl::ut::VariableString pathName;
        SetType setType;
        int8_t num;
        csl::ut::MoveArray<hh::game::ObjectId> setNodeList;
        bool isLimitedTime;
        uint32_t startHour;
        uint32_t startMin;
        uint32_t endHour;
        uint32_t endMin;
        float delayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGuideLightSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGuideLightSpawner* pInstance);
        static void Clean(ObjGuideLightSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHackingConsoleSpawner {
        int32_t no;
        bool eventDriven;
        csl::ut::VariableString stageCode;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHackingConsoleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHackingConsoleSpawner* pInstance);
        static void Clean(ObjHackingConsoleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHackingPlayerMachineSpawner {
        float rightLimit;
        float leftLimit;
        float frontLimit;
        float backLimit;
        bool enableDepth;
        hh::game::ObjectId targetManager;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHackingPlayerMachineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHackingPlayerMachineSpawner* pInstance);
        static void Clean(ObjHackingPlayerMachineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTheEndPlayerMachineSpawner {
        float rightLimit;
        float leftLimit;
        float frontLimit;
        float backLimit;
        bool enableDepth;
        hh::game::ObjectId targetManager;
        float pitchRotate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTheEndPlayerMachineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTheEndPlayerMachineSpawner* pInstance);
        static void Clean(ObjTheEndPlayerMachineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHeroSagePointSpawner {
        float accessDistance;
        csl::math::Vector3 offsetPos;
        csl::math::Vector3 offsetRot;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHeroSagePointSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHeroSagePointSpawner* pInstance);
        static void Clean(ObjHeroSagePointSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHintRingSpawner {
        enum class Visual : int8_t {
            HintRing = 0,
            Num = 1,
        };

        Visual visual;
        csl::ut::VariableString headerLabel;
        csl::ut::VariableString bodyLabel;
        float animSpeed;
        float respawnTime;
        csl::math::Vector3 box;
        csl::math::Vector3 offset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHintRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHintRingSpawner* pInstance);
        static void Clean(ObjHintRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHoverStoneSpawner {
        bool withBase;
        bool hoverOnStart;
        float hoverHeight;
        float fallWaitTime;
        bool useHoverLimit;
        float hoverLimitTime;
        bool doBoundBackOnHoverUp;
        float bounceBackOnHoverUp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHoverStoneSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHoverStoneSpawner* pInstance);
        static void Clean(ObjHoverStoneSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjImpactPuzzleSwitchSpawner {
        enum class Condition : int8_t {
            COND_ONCE = 0,
            COND_TIMER = 1,
        };

        int32_t no;
        bool eventDriven;
        Condition condition;
        float activateTime;
        bool deactivateOnAttacked;
        float haBounceY;
        float haBounceZ;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjImpactPuzzleSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjImpactPuzzleSwitchSpawner* pInstance);
        static void Clean(ObjImpactPuzzleSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ClrearCameraParam {
        float interoplateTimeActivate;
        float interoplateTimeDeactivate;
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraPosOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ClrearCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ClrearCameraParam* pInstance);
        static void Clean(ClrearCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjImpactTargetSpawner {
        int32_t no;
        float activateTime;
        float cancelDistance;
        int32_t impact;
        heur::rfl::ClrearCameraParam cameraParam;
        float extreamRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjImpactTargetSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjImpactTargetSpawner* pInstance);
        static void Clean(ObjImpactTargetSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjIronBoxSpawner {
        int32_t BoxNumX;
        int32_t BoxNumY;
        int32_t BoxNumZ;
        bool dropShadow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjIronBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjIronBoxSpawner* pInstance);
        static void Clean(ObjIronBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct IslandCannonLaunch {
        csl::math::Vector3 direction;
        float firstSpeed;
        float keepVelocityDistance;
        float outOfControl;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IslandCannonLaunch* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IslandCannonLaunch* pInstance);
        static void Clean(IslandCannonLaunch* pInstance);
    };
}

namespace heur::rfl {
    struct ObjIslandCannonSpawner {
        enum class ModelType : int8_t {
            FV = 0,
            FV_BASELESS = 1,
            SV = 2,
            SV_BASELESS = 3,
            MODEL_NUM = 4,
        };

        enum class RotateType : int8_t {
            UpDown = 0,
            LeftRight = 1,
            NoMove = 2,
        };

        ModelType modelType;
        RotateType rotateType;
        float rotateRangeStart;
        float rotateRangeEnd;
        float rotateSpeed;
        float verticalAngle;
        int32_t numOfDirections;
        heur::rfl::IslandCannonLaunch launchParam[5];
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjIslandCannonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjIslandCannonSpawner* pInstance);
        static void Clean(ObjIslandCannonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjIslandJumpBoardPathSpawner {
        enum class SizeType : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_COUNT = 3,
        };

        int32_t no;
        float distance;
        float distanceX;
        float height;
        float outStrength;
        float inStrength;
        float inAngle;
        float impulseSpeedOn;
        float outOfControl;
        float motionTime;
        bool isEventOn;
        bool airtrick;
        SizeType size;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjIslandJumpBoardPathSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjIslandJumpBoardPathSpawner* pInstance);
        static void Clean(ObjIslandJumpBoardPathSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjIslandNormalFloorSpawner {
        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        float width;
        float height;
        float depth;
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        bool eventDriven;
        bool isFall;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        bool isPressDead;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjIslandNormalFloorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjIslandNormalFloorSpawner* pInstance);
        static void Clean(ObjIslandNormalFloorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjIslandSpringSpawner {
        enum class Visual : int8_t {
            Normal = 0,
            Sky = 1,
        };

        int32_t no;
        Visual visual;
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;
        bool isEventOn;
        bool isHorizon;
        bool isVisible;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjIslandSpringSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjIslandSpringSpawner* pInstance);
        static void Clean(ObjIslandSpringSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjIslandUpReelSpawner {
        int32_t no;
        float length;
        float upSpeedMax;
        float firstSpeed;
        float outOfControl;
        bool isOneTimeUp;
        bool eventDriven;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjIslandUpReelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjIslandUpReelSpawner* pInstance);
        static void Clean(ObjIslandUpReelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjJingleSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjJingleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjJingleSpawner* pInstance);
        static void Clean(ObjJingleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjJumpBoardPathSpawner {
        enum class SizeType : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_COUNT = 3,
        };

        float distance;
        float distanceX;
        float height;
        float outStrength;
        float inStrength;
        float inAngle;
        float impulseSpeedOn;
        float outOfControl;
        float motionTime;
        bool airtrick;
        SizeType size;
        heur::rfl::ActionNotification actions[3];
        bool isCyloopOn;
        float cyloopSignDistance;
        float cyloopSignTolerance;
        bool isCyKnuckleOn;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjJumpBoardPathSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjJumpBoardPathSpawner* pInstance);
        static void Clean(ObjJumpBoardPathSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaBombSpawner {
        int8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaBombSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaBombSpawner* pInstance);
        static void Clean(ObjKodamaBombSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLaserClearEffectSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLaserClearEffectSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLaserClearEffectSpawner* pInstance);
        static void Clean(ObjLaserClearEffectSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLaserRecieverSpawner {
        int32_t no;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLaserRecieverSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLaserRecieverSpawner* pInstance);
        static void Clean(ObjLaserRecieverSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLaserRelicSpawner {
        int32_t no;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLaserRelicSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLaserRelicSpawner* pInstance);
        static void Clean(ObjLaserRelicSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLightPoleSpawner {
        enum class Color : int8_t {
            COLOR_LIGHTBLUE = 0,
            COLOR_YELLOW = 1,
            COLOR_WHITE = 2,
            COLOR_NUM = 3,
        };

        enum class Condition : int8_t {
            COND_ONCE = 0,
            COND_TIMER = 1,
        };

        int32_t no;
        Color color;
        Condition condition;
        float activateTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLightPoleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLightPoleSpawner* pInstance);
        static void Clean(ObjLightPoleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLimitedTimeGateSpawner {
        enum class SetType : int8_t {
            EquallySpaced = 0,
            NodeID = 1,
        };

        int32_t no;
        csl::ut::VariableString pathName;
        SetType setType;
        int8_t num;
        csl::ut::MoveArray<hh::game::ObjectId> setNodeList;
        hh::game::ObjectId linkObj;
        float colSize;
        bool isRespawn;
        csl::ut::MoveArray<hh::game::ObjectId> respawnLTGates;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLimitedTimeGateSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLimitedTimeGateSpawner* pInstance);
        static void Clean(ObjLimitedTimeGateSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLineFlowerSpawner {
        enum class SetType : int8_t {
            EquallySpaced = 0,
            NodeID = 1,
        };

        int32_t no;
        csl::ut::VariableString pathName;
        SetType setType;
        int8_t num;
        csl::ut::MoveArray<hh::game::ObjectId> setNodeList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLineFlowerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLineFlowerSpawner* pInstance);
        static void Clean(ObjLineFlowerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLocatorSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLocatorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLocatorSpawner* pInstance);
        static void Clean(ObjLocatorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLoopAreaVolumeSpawner {
        csl::ut::VariableString pathName;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLoopAreaVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLoopAreaVolumeSpawner* pInstance);
        static void Clean(ObjLoopAreaVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMagneticVolumeSpawner {
        float radius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMagneticVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMagneticVolumeSpawner* pInstance);
        static void Clean(ObjMagneticVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSlotStarSpawner {
        enum class VisualType : uint8_t {
            Normal = 0,
            NumVisualTypes = 1,
        };

        VisualType visual;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSlotStarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSlotStarSpawner* pInstance);
        static void Clean(ObjSlotStarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMeteorShowerKodamaSpawner {
        enum class VisualType : uint8_t {
            Normal = 0,
            NumVisualTypes = 1,
        };

        VisualType visual;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMeteorShowerKodamaSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMeteorShowerKodamaSpawner* pInstance);
        static void Clean(ObjMeteorShowerKodamaSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMeteorShowerPowerupSeedSpawner {
        enum class VisualType : uint8_t {
            Normal = 0,
            NumVisualTypes = 1,
        };

        enum class SeedType : int8_t {
            Power = 0,
            Guard = 1,
        };

        VisualType visual;
        SeedType type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMeteorShowerPowerupSeedSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMeteorShowerPowerupSeedSpawner* pInstance);
        static void Clean(ObjMeteorShowerPowerupSeedSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMineSpawner {
        float scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMineSpawner* pInstance);
        static void Clean(ObjMineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMonologueVolumeSpawner {
        enum class InterpolateType : int8_t {
            INTERPOLATE_RELATIVE = 0,
            INTERPOLATE_ABSOLUTE = 1,
            INTERPOLATE_ABSOLUTE_COORD = 2,
            INTERPOLATE_ABSOLUTE_STABLE = 3,
        };

        enum class HoldType : int8_t {
            AllHolded = 0,
            EaseInHolded = 1,
            NoneHolded = 2,
        };

        int32_t no;
        csl::ut::VariableString labelName;
        hh::game::ObjectId target;
        uint32_t priority;
        bool useHighPriority;
        float easeTimeEnter;
        float easeTimeLeave;
        InterpolateType interpolateTypeEnter;
        InterpolateType interpolateTypeLeave;
        bool endByLeave;
        bool endByTime;
        float endTime;
        bool endByCaption;
        HoldType hold;
        bool useLetterBox;
        heur::rfl::VolumeTriggerSpawner volume;
        float margin;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMonologueVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMonologueVolumeSpawner* pInstance);
        static void Clean(ObjMonologueVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMotoraISpawner {
        enum class Placement : uint8_t {
            WhereItsSet = 0,
            InAir = 1,
            NumPlacements = 2,
        };

        enum class Movement : uint8_t {
            Immobile = 0,
            TwoPoint = 1,
            NumMovements = 2,
        };

        Placement placement;
        Movement movement;
        csl::math::Vector3 destination;
        float movementSpeed;
        float rushSpeed;
        float knockbackSpeed;
        float tireRotAnglePerSecWhenMoving;
        float tireRotAnglePerSecWhenChargingup;
        float tireRotAnglePerSecWhenRushing;
        float searchDistance;
        float searchAngle;
        float respawnTime;
        float chargeupTime;
        float timeTilLoseSight;
        float heightToRecognizeAsCliff;
        float distanceToRecognizeObstable;
        float degreeToRotatePerSec;
        bool eventDriven;
        bool doesRespawn;
        bool doesAttack;
        bool useFindMotion;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMotoraISpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMotoraISpawner* pInstance);
        static void Clean(ObjMotoraISpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMusicBoxSpawner {
        int32_t no;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMusicBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMusicBoxSpawner* pInstance);
        static void Clean(ObjMusicBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMusicMemorySpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMusicMemorySpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMusicMemorySpawner* pInstance);
        static void Clean(ObjMusicMemorySpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNumberObjectSpawner {
        enum class NumberType : int8_t {
            TYPE_ONE = 0,
            TYPE_TWO = 1,
            TYPE_THREE = 2,
            TYPE_FOUR = 3,
            TYPE_FIVE = 4,
            TYPE_NUM = 5,
        };

        int32_t no;
        NumberType number;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNumberObjectSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNumberObjectSpawner* pInstance);
        static void Clean(ObjNumberObjectSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAirCubeSpawner {
        enum class Type : int32_t {
            CubeA = 0,
            CubeB = 1,
            CubeC = 2,
            CubeD = 3,
            CubeA3x3 = 4,
            CubeA4x4 = 5,
            Num = 6,
        };

        Type type;
        float scale;
        bool movable;
        int32_t numX;
        int32_t numY;
        int32_t numZ;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAirCubeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAirCubeSpawner* pInstance);
        static void Clean(ObjAirCubeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjObjectLayerTriggerSpawner {
        csl::ut::VariableString layerName;
        bool enabled;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjObjectLayerTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjObjectLayerTriggerSpawner* pInstance);
        static void Clean(ObjObjectLayerTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct OneWayPanelStart {
        bool eventDriven;
        bool keepLightOnFail;
        csl::ut::MoveArray<hh::game::ObjectId> panelIds;
        csl::ut::MoveArray<hh::game::ObjectId> actionIds;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OneWayPanelStart* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OneWayPanelStart* pInstance);
        static void Clean(OneWayPanelStart* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOneWayPanelSpawner {
        bool isStart;
        heur::rfl::OneWayPanelStart startParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOneWayPanelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOneWayPanelSpawner* pInstance);
        static void Clean(ObjOneWayPanelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOneWayPanelManagerSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> panelList;
        hh::game::ObjectId firstStartPanel;
        csl::ut::MoveArray<hh::game::ObjectId> dummyList;
        bool useTimer;
        float time;
        hh::game::ObjectId camActivator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOneWayPanelManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOneWayPanelManagerSpawner* pInstance);
        static void Clean(ObjOneWayPanelManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOutOfControlTriggerSpawner {
        float outOfControlTime;
        bool releaseByGround;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOutOfControlTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOutOfControlTriggerSpawner* pInstance);
        static void Clean(ObjOutOfControlTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOutOfControlVolumeSpawner {
        bool releaseByGround;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOutOfControlVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOutOfControlVolumeSpawner* pInstance);
        static void Clean(ObjOutOfControlVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjParticleBaseSoundParam {
        csl::ut::VariableString name;
        bool is3D;
        float volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjParticleBaseSoundParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjParticleBaseSoundParam* pInstance);
        static void Clean(ObjParticleBaseSoundParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjParticleBaseRumbleParam {
        csl::ut::VariableString name;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjParticleBaseRumbleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjParticleBaseRumbleParam* pInstance);
        static void Clean(ObjParticleBaseRumbleParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjParticleBaseSpawner {
        csl::ut::VariableString effectName;
        float scale;
        uint8_t colorR;
        uint8_t colorG;
        uint8_t colorB;
        uint8_t colorA;
        heur::rfl::ObjParticleBaseSoundParam sound;
        heur::rfl::ObjParticleBaseRumbleParam rumble;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjParticleBaseSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjParticleBaseSpawner* pInstance);
        static void Clean(ObjParticleBaseSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjParticleSpawner : heur::rfl::ObjParticleBaseSpawner {
        enum class TriggerType : int8_t {
            RANGE = 0,
            MESSAGE = 1,
        };

        TriggerType trigger;
        int32_t sectorId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjParticleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjParticleSpawner* pInstance);
        static void Clean(ObjParticleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjParticleExtentSpawner {
        enum class Shape : int8_t {
            SHAPE_SPHERE = 0,
            SHAPE_BOX = 1,
        };

        enum class Emit : int8_t {
            EMIT_VOLUME = 0,
            EMIT_FACE = 1,
        };

        enum class Direction : int8_t {
            DIRECTION_Y_UP = 0,
            DIRECTION_NORMAL = 1,
            DIRECTION_RANDOM = 2,
        };

        enum class ActiveType : int8_t {
            TYPE_ACTIVE = 0,
            TYPE_NONACTIVE = 1,
        };

        csl::ut::VariableString effectName;
        float scale;
        uint8_t colorR;
        uint8_t colorG;
        uint8_t colorB;
        uint8_t colorA;
        Shape shapeType;
        csl::math::Vector3 extents;
        Emit emitPointType;
        Direction directionType;
        float interval;
        float loopTime;
        bool bottomExclusion;
        bool upperHalfOnly;
        ActiveType active;
        int32_t sectorId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjParticleExtentSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjParticleExtentSpawner* pInstance);
        static void Clean(ObjParticleExtentSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjParticleVolumeSpawner : heur::rfl::ObjParticleBaseSpawner {
        enum class Shape : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
        };

        enum class Emit : int8_t {
            EMIT_OBJECT = 0,
            EMIT_PLAYER = 1,
            EMIT_CONTACT = 2,
            EMIT_CAMERA = 3,
        };

        enum class Gravity : int8_t {
            GRAVITY_OBJECT = 0,
            GRAVITY_EMIT = 1,
        };

        Shape shapeType;
        float width;
        float height;
        float depth;
        float zOffset;
        bool isStay;
        Emit emitPointType;
        Gravity gravityPointType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjParticleVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjParticleVolumeSpawner* pInstance);
        static void Clean(ObjParticleVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPipeMoveTriggerSpawner {
        enum class SpeedType : int8_t {
            SPEED_FIX = 0,
            SPEED_MIN = 1,
        };

        csl::ut::VariableString pathName;
        SpeedType speedType;
        float speed;
        float outOfControlTime;
        float launchSpeed;
        float attackTime;
        bool isPoseToReverseGravity;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPipeMoveTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPipeMoveTriggerSpawner* pInstance);
        static void Clean(ObjPipeMoveTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPlayerNavigateInfoSpawner {
        float moveSpeed;
        float maxMoveTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPlayerNavigateInfoSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPlayerNavigateInfoSpawner* pInstance);
        static void Clean(ObjPlayerNavigateInfoSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MoveParameter {
        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_CONSTANT = 1,
            MOVE_ROTATE = 2,
        };

        MoveType type;
        float distance;
        float cycle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MoveParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MoveParameter* pInstance);
        static void Clean(MoveParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPointLightSpawner {
        float colorR;
        float colorG;
        float colorB;
        float sourceRadius;
        float halfLength;
        float attenuationRadius;
        bool enableShadow;
        heur::rfl::MoveParameter move;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPointLightSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPointLightSpawner* pInstance);
        static void Clean(ObjPointLightSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPointMarkerSpawner {
        enum class ViewType : int8_t {
            FORWARDVIEW = 0,
            SIDEVIEW = 1,
            SIDEVIEW_REV = 2,
        };

        enum class RestartType : int8_t {
            Standard = 0,
            Boarding = 1,
        };

        float Width;
        ViewType StageType;
        heur::rfl::PassPlaneTriggerSpawner passPlane;
        RestartType restartType;
        hh::game::ObjectId camera;
        float cameraLimit;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPointMarkerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPointMarkerSpawner* pInstance);
        static void Clean(ObjPointMarkerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPopupSpringSpawner {
        float FirstSpeed;
        float OutOfControl;
        float KeepVelocityDistance;
        float VisibleTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPopupSpringSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPopupSpringSpawner* pInstance);
        static void Clean(ObjPopupSpringSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPortalSpawner {
        int32_t no;
        bool eventDriven;
        csl::ut::VariableString stageCode;
        int32_t portalBitActivateCount;
        hh::game::ObjectId fastTravelLocator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPortalSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPortalSpawner* pInstance);
        static void Clean(ObjPortalSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PortalBitParameter {
        enum class PortalBitType : uint8_t {
            PortalBitSensor = 0,
            ObjItem = 1,
        };

        float suckedTime;
        PortalBitType portalbitType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PortalBitParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PortalBitParameter* pInstance);
        static void Clean(PortalBitParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPortalBitSpawner {
        int32_t no;
        heur::rfl::PortalBitParameter portalBitPrameter;
        uint8_t bounceTime;
        csl::math::Vector3 velocity;
        float horzDamp;
        float reflection;
        bool geditSet;
        bool alwaysCheckGround;
        bool cyloopDriven;
        float cyloopSignDistance;
        float cyloopSignTolerance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPortalBitSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPortalBitSpawner* pInstance);
        static void Clean(ObjPortalBitSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPortalGateSpawner {
        bool eventDriven;
        uint32_t saveFlag;
        bool isGoal;
        float scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPortalGateSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPortalGateSpawner* pInstance);
        static void Clean(ObjPortalGateSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPortalGateSecretSpawner {
        bool eventDriven;
        uint32_t saveFlag;
        bool isGoal;
        float scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPortalGateSecretSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPortalGateSecretSpawner* pInstance);
        static void Clean(ObjPortalGateSecretSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PICameraParameter {
        float azimuth;
        float elevation;
        float distance;
        float zRoll;
        float fovy;
        csl::math::Vector3 frameOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PICameraParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PICameraParameter* pInstance);
        static void Clean(PICameraParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPositionIndicatorSpawner {
        enum class PurposeOfUse : uint8_t {
            QuestKodamaCollection01 = 0,
            QuestKodamaCollection02 = 1,
            ObjStriderGrindRail = 2,
            QuestFiledCenterLinePoint = 3,
            NumPurposes = 4,
        };

        PurposeOfUse purposeOfUse;
        bool useCamera;
        heur::rfl::PICameraParameter cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPositionIndicatorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPositionIndicatorSpawner* pInstance);
        static void Clean(ObjPositionIndicatorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPowerupSeedSpawner {
        enum class SeedType : int8_t {
            POWER = 0,
            GUARD = 1,
        };

        int32_t no;
        SeedType type;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPowerupSeedSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPowerupSeedSpawner* pInstance);
        static void Clean(ObjPowerupSeedSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPracticeNotifyVolumeSpawner {
        enum class UnlockStatus : int8_t {
            UNLOCK_NOT_LOCK = 0,
            UNLOCK_INFO_ACTIVATE = 1,
        };

        int32_t gimmickNo;
        int32_t practiceNo;
        int32_t tipsNo;
        heur::rfl::VolumeTriggerSpawner volume;
        float margin;
        UnlockStatus unlockStatus;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPracticeNotifyVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPracticeNotifyVolumeSpawner* pInstance);
        static void Clean(ObjPracticeNotifyVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPropellerSpawner {
        enum class Type : int8_t {
            TYPE_ON = 0,
            TYPE_CYCLE = 1,
        };

        enum class Place : int8_t {
            ON_GROUND = 0,
            IN_AIR = 1,
            NUM_PLACES = 2,
        };

        float duration;
        Type type;
        Place place;
        float length;
        float velocity;
        float durOn;
        float durOff;
        float phase;
        bool eventDriven;
        bool canHomingAttack;
        bool isConstrain;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPropellerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPropellerSpawner* pInstance);
        static void Clean(ObjPropellerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPropellerSpringSpawner {
        float firstSpeedHA;
        float outOfControlHA;
        float keepVelocityDistanceHA;
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;
        bool isEventOn;
        bool airtrick;
        float riseSpeed;
        float riseHeight;
        float maxHeight;
        float fallSpeed;
        float fallWaitTime;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPropellerSpringSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPropellerSpringSpawner* pInstance);
        static void Clean(ObjPropellerSpringSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPulleySpawner {
        csl::ut::VariableString pathName;
        float startPosition1D;
        float endPosition1D;
        bool isJumpCancel;
        csl::math::Vector3 offset;
        float minSpeed;
        float maxSpeed;
        float waitToReturnSec;
        float returnSpeed;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPulleySpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPulleySpawner* pInstance);
        static void Clean(ObjPulleySpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPulleyColumnSpawner {
        uint32_t height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPulleyColumnSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPulleyColumnSpawner* pInstance);
        static void Clean(ObjPulleyColumnSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPulley2Spawner {
        enum class ColumnType : int8_t {
            COLUMN_TYPE_SHORT = 0,
            COLUMN_TYPE_LONG = 1,
            NUM_COLUMN_TYPES = 2,
        };

        uint32_t pathID;
        csl::ut::MoveArray<hh::game::ObjectId> nodeList;
        float startPosition1D;
        float endPosition1D;
        float minSpeed;
        float maxSpeed;
        ColumnType columnType;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPulley2Spawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPulley2Spawner* pInstance);
        static void Clean(ObjPulley2Spawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPulley2NodeSpawner {
        enum class ColumnType : int8_t {
            COLUMN_TYPE_SHORT = 0,
            COLUMN_TYPE_LONG = 1,
            NUM_COLUMN_TYPES = 2,
        };

        ColumnType columnType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPulley2NodeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPulley2NodeSpawner* pInstance);
        static void Clean(ObjPulley2NodeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPushFloorSwitchSpawner {
        enum class Condition : int8_t {
            COND_ENTER = 0,
            COND_TIMER = 1,
        };

        int32_t no;
        bool eventDriven;
        Condition condition;
        float activateTime;
        bool isViewTimer;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPushFloorSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPushFloorSwitchSpawner* pInstance);
        static void Clean(ObjPushFloorSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPuzzleBarrierSpawner {
        enum class InitialState : int8_t {
            STATE_ON = 0,
            STATE_OFF = 1,
        };

        int32_t no;
        InitialState initialState;
        float radius;
        float aspectRatio;
        float height;
        int32_t numSides;
        bool isEnableCollision;
        bool isEnableCeil;
        bool useSubCameraAppear;
        hh::game::ObjectId cameraAppear;
        float appearWaitTime;
        bool useSubCameraDisappear;
        hh::game::ObjectId cameraDisappear;
        float disappearWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPuzzleBarrierSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPuzzleBarrierSpawner* pInstance);
        static void Clean(ObjPuzzleBarrierSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPuzzleBarrierOpacitySpawner {
        int32_t no;
        uint8_t numSides;
        csl::ut::MoveArray<hh::game::ObjectId> includeObj;
        bool useSubCameraDisappear;
        hh::game::ObjectId cameraDisappear;
        float disappearWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPuzzleBarrierOpacitySpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPuzzleBarrierOpacitySpawner* pInstance);
        static void Clean(ObjPuzzleBarrierOpacitySpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuickStepSpawner {
        enum class LineType : int8_t {
            LINE2_LEFT = 0,
            LINE2_RIGHT = 1,
            LINE3 = 2,
            LINE5 = 3,
        };

        enum class JumpMode : int8_t {
            WorldSpace = 0,
            PathSpace = 1,
            NoneJump = 2,
        };

        LineType line;
        csl::ut::VariableString pathName;
        float speed;
        float speedMin;
        float boostSpeed;
        float boostSpeedMin;
        float boostLvMaxSpeed;
        float boostLvMaxSpeedMin;
        float initialSpeed;
        float stepWidth;
        JumpMode jumpMode;
        bool endByAir;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuickStepSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuickStepSpawner* pInstance);
        static void Clean(ObjQuickStepSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuickStepTriggerSpawner : heur::rfl::ObjQuickStepSpawner {
        enum class ActionType : int8_t {
            ACT_START = 0,
            ACT_END = 1,
        };

        ActionType type;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuickStepTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuickStepTriggerSpawner* pInstance);
        static void Clean(ObjQuickStepTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuickStepVolumeSpawner : heur::rfl::ObjQuickStepSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuickStepVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuickStepVolumeSpawner* pInstance);
        static void Clean(ObjQuickStepVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRedRingSpawner {
        enum class ModelType : int8_t {
            NORMAL = 0,
            TRANSLUCENT = 1,
        };

        enum class Event : int8_t {
            EVENT_NONE = 0,
            EVENT_VISIBLE = 1,
            EVENT_INVISIBLE = 2,
        };

        enum class Rotate : int8_t {
            OBJ_Y_UP = 0,
            WORLD_Y_UP = 1,
        };

        ModelType modelType;
        int32_t ItemId;
        Event EventType;
        Rotate RotateType;
        bool SeparateTranslucent;
        heur::rfl::PathMovement pathMovement;
        float collisionRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRedRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRedRingSpawner* pInstance);
        static void Clean(ObjRedRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjReflexesPanelSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjReflexesPanelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjReflexesPanelSpawner* pInstance);
        static void Clean(ObjReflexesPanelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ReflexesPanelCamera {
        csl::math::Vector3 targetOffset;
        float distance;
        csl::math::Vector3 angle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ReflexesPanelCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ReflexesPanelCamera* pInstance);
        static void Clean(ReflexesPanelCamera* pInstance);
    };
}

namespace heur::rfl {
    struct ObjReflexesPanelManagerSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> panelIds;
        hh::game::ObjectId panelSwitchId;
        float timeLimit;
        uint32_t requestNum;
        float createPanelMinTime;
        float createPanelMaxTime;
        float lightPanelMinTime;
        float lightPanelMaxTime;
        heur::rfl::ReflexesPanelCamera cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjReflexesPanelManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjReflexesPanelManagerSpawner* pInstance);
        static void Clean(ObjReflexesPanelManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjReleaseMapSpawner {
        int32_t no;
        int32_t gimmickInfoNo;
        hh::game::ObjectId cameraUUID;
        float scanCameraEaseIn;
        float scanCameraEaseOut;
        float mapSensorDistance;
        int32_t viewNo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjReleaseMapSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjReleaseMapSpawner* pInstance);
        static void Clean(ObjReleaseMapSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjResonatorSpawner {
        enum class Condition : int8_t {
            COND_ENTER = 0,
            COND_TIMER = 1,
        };

        enum class PhraseType : int8_t {
            PHRASE_1 = 0,
            PHRASE_2 = 1,
            PHRASE_3 = 2,
            PHRASE_4 = 3,
            PHRASE_5 = 4,
        };

        int32_t no;
        bool eventDriven;
        Condition condition;
        float activateTime;
        PhraseType phraseType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjResonatorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjResonatorSpawner* pInstance);
        static void Clean(ObjResonatorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRingSpawner {
        enum class Visibility : int8_t {
            Visible = 0,
            Invisible = 1,
        };

        Visibility visibility;
        float respawnTime;
        heur::rfl::PathMovement pathMovement;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRingSpawner* pInstance);
        static void Clean(ObjRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSuperRingSpawner : heur::rfl::ObjRingSpawner {
        enum class RotateAxis : int8_t {
            WorldAxisY = 0,
            LocalAxisY = 1,
        };

        RotateAxis axis;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSuperRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSuperRingSpawner* pInstance);
        static void Clean(ObjSuperRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRingGateSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRingGateSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRingGateSpawner* pInstance);
        static void Clean(ObjRingGateSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct CameraParam {
        float interoplateTimeActivate;
        float interoplateTimeDeactivate;
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraPosOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CameraParam* pInstance);
        static void Clean(CameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRopeMachineSpawner {
        int32_t no;
        float maxSpeed;
        float minSpeed;
        float maxStopTime;
        float minStopTime;
        float activateTime;
        float startWaitTime;
        float doubleJump;
        bool randomJump;
        int32_t doubleJumpNumerator;
        int32_t doubleJumpDenominator;
        heur::rfl::CameraParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRopeMachineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRopeMachineSpawner* pInstance);
        static void Clean(ObjRopeMachineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRotatableMirrorSpawner {
        enum class RotateType : int32_t {
            HORIZANTAL = 0,
            VERTICAL = 1,
            FIXED = 2,
        };

        int32_t no;
        bool eventDriven;
        RotateType rotateType;
        float angularVelocity;
        int32_t initVerticalID;
        heur::rfl::GimmickCameraOptionalParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRotatableMirrorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRotatableMirrorSpawner* pInstance);
        static void Clean(ObjRotatableMirrorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRotatableStatueSpawner {
        enum class ModelType : int8_t {
            TYPE_NORMAL = 0,
            TYPE_LASER = 1,
        };

        enum class RotateType : int8_t {
            ROTATE_TYPE_45 = 0,
            ROTATE_TYPE_225 = 1,
            ROTATE_TYPE_RANDOM = 2,
        };

        enum class RotatePositionType : int32_t {
            COLLECT_TYPE_45 = 1,
            COLLECT_TYPE_90 = 2,
            COLLECT_TYPE_135 = 3,
            COLLECT_TYPE_180 = 4,
            COLLECT_TYPE_225 = 5,
            COLLECT_TYPE_270 = 6,
            COLLECT_TYPE_315 = 7,
        };

        ModelType type;
        int32_t no;
        bool eventDriven;
        bool rotatable;
        RotateType rotateType;
        RotatePositionType collectType;
        float angularVelocity;
        int32_t randomClearCount;
        int32_t randomRoundMin;
        int32_t randomRoundMax;
        csl::ut::MoveArray<hh::game::ObjectId> targetList;
        bool isUseEyeSightTarget;
        csl::ut::MoveArray<hh::game::ObjectId> eyeSightTargetList;
        heur::rfl::GimmickCameraOptionalParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRotatableStatueSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRotatableStatueSpawner* pInstance);
        static void Clean(ObjRotatableStatueSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRotatableTombStoneSpawner {
        enum class RotatePositionType : int32_t {
            COLLECT_TYPE_45 = 1,
            COLLECT_TYPE_90 = 2,
            COLLECT_TYPE_135 = 3,
            COLLECT_TYPE_180 = 4,
            COLLECT_TYPE_225 = 5,
            COLLECT_TYPE_270 = 6,
            COLLECT_TYPE_315 = 7,
            COLLECT_TYPE_0 = 8,
        };

        int32_t no;
        bool isLock;
        RotatePositionType collectType;
        float angularVelocity;
        csl::ut::MoveArray<hh::game::ObjectId> rotateList;
        hh::game::ObjectId rotatablemanager;
        hh::game::ObjectId tombStatue;
        csl::math::Vector3 cameraOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRotatableTombStoneSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRotatableTombStoneSpawner* pInstance);
        static void Clean(ObjRotatableTombStoneSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct RunningMachineMileage {
        float length;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RunningMachineMileage* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RunningMachineMileage* pInstance);
        static void Clean(RunningMachineMileage* pInstance);
    };
}

namespace heur::rfl {
    struct RunningMachineKeepFixedParam {
        float targetSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RunningMachineKeepFixedParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RunningMachineKeepFixedParam* pInstance);
        static void Clean(RunningMachineKeepFixedParam* pInstance);
    };
}

namespace heur::rfl {
    struct RunningMachineKeepSinParam {
        float offset;
        float amplitude;
        float period;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RunningMachineKeepSinParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RunningMachineKeepSinParam* pInstance);
        static void Clean(RunningMachineKeepSinParam* pInstance);
    };
}

namespace heur::rfl {
    struct RunningMachineKeepRandomParam {
        float min;
        float max;
        float period;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RunningMachineKeepRandomParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RunningMachineKeepRandomParam* pInstance);
        static void Clean(RunningMachineKeepRandomParam* pInstance);
    };
}

namespace heur::rfl {
    struct RunningMachineKeep {
        enum class TargetSpeedType : uint8_t {
            TypeFixed = 0,
            TypeSin = 1,
            TypeRandom = 2,
        };

        TargetSpeedType targetSpeedType;
        heur::rfl::RunningMachineKeepFixedParam fixed;
        heur::rfl::RunningMachineKeepSinParam sin;
        heur::rfl::RunningMachineKeepRandomParam random;
        float speedThreshold;
        float speedTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RunningMachineKeep* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RunningMachineKeep* pInstance);
        static void Clean(RunningMachineKeep* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRunningMachineSpawner {
        enum class ClearType : uint8_t {
            ClearTypeMileage = 0,
            ClearTypeKeep = 1,
        };

        int32_t no;
        ClearType clearType;
        heur::rfl::RunningMachineMileage mileage;
        heur::rfl::RunningMachineKeep keep;
        bool useTimer;
        float activateTime;
        float startWaitTime;
        hh::game::ObjectId cameraActivator;
        bool fixPlayerPos;
        float foremostSpeed;
        float backmostSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRunningMachineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRunningMachineSpawner* pInstance);
        static void Clean(ObjRunningMachineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct SaveDenyVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SaveDenyVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SaveDenyVolumeSpawner* pInstance);
        static void Clean(SaveDenyVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjScrapeBallSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjScrapeBallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjScrapeBallSpawner* pInstance);
        static void Clean(ObjScrapeBallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct SelectCannonLaunch {
        csl::math::Vector3 direction;
        float firstSpeed;
        float keepVelocityDistance;
        float outOfControl;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SelectCannonLaunch* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SelectCannonLaunch* pInstance);
        static void Clean(SelectCannonLaunch* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSelectCannonSpawner {
        bool isLimitOn;
        float limitTime;
        int32_t selectNum;
        heur::rfl::SelectCannonLaunch launchParam[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSelectCannonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSelectCannonSpawner* pInstance);
        static void Clean(ObjSelectCannonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSequenceColliderSpawner {
        enum class Shape : int8_t {
            Box = 0,
            Sphere = 1,
            Capsule = 2,
            NumShapes = 3,
        };

        int32_t no;
        Shape shape;
        csl::math::Vector3 offset;
        csl::math::Vector3 extents;
        float radius;
        float height;
        bool collidesWithCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSequenceColliderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSequenceColliderSpawner* pInstance);
        static void Clean(ObjSequenceColliderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSequenceItemSpawner {
        int32_t no;
        bool cyloopDriven;
        float cyloopSignDistance;
        float cyloopSignTolerance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSequenceItemSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSequenceItemSpawner* pInstance);
        static void Clean(ObjSequenceItemSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSequenceSwitchVolumeSpawner {
        int32_t no;
        bool eventDriven;
        heur::rfl::VolumeTriggerSpawner volume;
        bool menuDisabled;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSequenceSwitchVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSequenceSwitchVolumeSpawner* pInstance);
        static void Clean(ObjSequenceSwitchVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSetPathNodeSpawner {
        enum class LineType : int8_t {
            LINETYPE_SNS = 0,
            LINETYPE_STRAIGHT = 1,
            NUM = 2,
        };

        uint32_t nodeId;
        LineType lineType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSetPathNodeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSetPathNodeSpawner* pInstance);
        static void Clean(ObjSetPathNodeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ConnectParameter {
        enum class ConnectType : int8_t {
            CONNECT_SNS = 0,
            CONNECT_STRAIGHT = 1,
        };

        bool isConnect;
        ConnectType connectType;
        float splineTangentLength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ConnectParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ConnectParameter* pInstance);
        static void Clean(ConnectParameter* pInstance);
    };
}

namespace heur::rfl {
    struct PathParameterCommon {
        enum class PathType : int8_t {
            OBJ_PATH = 0,
            GR_PATH = 1,
            SV_PATH = 2,
        };

        enum class GrindCapVisible : int8_t {
            Both = 0,
            Head = 1,
            Tail = 2,
            None = 3,
        };

        enum class ParamType : int8_t {
            PARAM_NONE = 0,
            PARAM_LINE = 1,
            PARAM_LOOP = 2,
            PARAM_SPIRAL = 3,
            PARAM_SET_PATH = 4,
            PARAM_POLYGON = 5,
            PARAM_CIRCLE = 6,
        };

        int32_t pathUID;
        PathType pathType;
        GrindCapVisible capVisible;
        float grindUnitLength;
        ParamType paramType;
        bool isMovable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathParameterCommon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathParameterCommon* pInstance);
        static void Clean(PathParameterCommon* pInstance);
    };
}

namespace heur::rfl {
    struct PathSetPathParameter : heur::rfl::PathParameterCommon {
        enum class LineType : int8_t {
            LINETYPE_SNS = 0,
            LINETYPE_STRAIGHT = 1,
        };

        csl::ut::MoveArray<hh::game::ObjectId> nodeList;
        bool isLoopPath;
        LineType startLineType;
        float divideLength;
        heur::rfl::ConnectParameter connectParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathSetPathParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathSetPathParameter* pInstance);
        static void Clean(PathSetPathParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSetPathSpawner {
        heur::rfl::PathSetPathParameter setParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSetPathSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSetPathSpawner* pInstance);
        static void Clean(ObjSetPathSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PathLoopParameter : heur::rfl::PathParameterCommon {
        enum class EasingPoint : int8_t {
            BothPoint = 0,
            BeginPoint = 1,
            EndPonit = 2,
        };

        float inRadius;
        float outRadius;
        float angle;
        float shiftDistance;
        float inDistance;
        float outDistance;
        float easingForce;
        EasingPoint easingPoint;
        heur::rfl::ConnectParameter connectParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathLoopParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathLoopParameter* pInstance);
        static void Clean(PathLoopParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSetPathLoopSpawner {
        heur::rfl::PathLoopParameter setParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSetPathLoopSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSetPathLoopSpawner* pInstance);
        static void Clean(ObjSetPathLoopSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PathSpiralParameter : heur::rfl::PathParameterCommon {
        enum class RotDir : int8_t {
            ROT_DIR_LEFT = 0,
            ROT_DIR_RIGHT = 1,
        };

        enum class EasingPoint : int8_t {
            BothPoint = 0,
            BeginPoint = 1,
            EndPonit = 2,
        };

        RotDir rotDir;
        float inRadius;
        float outRadius;
        float angle;
        float shiftDistance;
        float inDistance;
        float outDistance;
        float easingForce;
        EasingPoint easingPoint;
        heur::rfl::ConnectParameter connectParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathSpiralParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathSpiralParameter* pInstance);
        static void Clean(PathSpiralParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSetPathSpiralSpawner {
        heur::rfl::PathSpiralParameter setParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSetPathSpiralSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSetPathSpiralSpawner* pInstance);
        static void Clean(ObjSetPathSpiralSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PathLineParameter : heur::rfl::PathParameterCommon {
        float distance;
        float twistAngle;
        heur::rfl::ConnectParameter connectParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathLineParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathLineParameter* pInstance);
        static void Clean(PathLineParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSetPathLineSpawner {
        heur::rfl::PathLineParameter setParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSetPathLineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSetPathLineSpawner* pInstance);
        static void Clean(ObjSetPathLineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PathCircleParameter : heur::rfl::PathParameterCommon {
        enum class NormalType : int8_t {
            NOR_DEFAULT = 0,
            NOR_OUTSIDE = 1,
            NOR_INSIDE = 2,
        };

        NormalType normalType;
        float radius;
        float divideRate;
        bool isReverse;
        heur::rfl::ConnectParameter connectParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathCircleParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathCircleParameter* pInstance);
        static void Clean(PathCircleParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSetPathCircleSpawner {
        heur::rfl::PathCircleParameter setParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSetPathCircleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSetPathCircleSpawner* pInstance);
        static void Clean(ObjSetPathCircleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PathPolygonParameter : heur::rfl::PathParameterCommon {
        enum class PolygonType : int8_t {
            TRIANGLE_PATH = 0,
            SQUARE_PATH = 1,
        };

        enum class NormalType : int8_t {
            NOR_DEFAULT = 0,
            NOR_OUTSIDE = 1,
            NOR_INSIDE = 2,
        };

        PolygonType polygonType;
        NormalType normalType;
        float width;
        float height;
        float offsetHeight;
        heur::rfl::ConnectParameter connectParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathPolygonParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathPolygonParameter* pInstance);
        static void Clean(PathPolygonParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSetPathPolygonSpawner {
        heur::rfl::PathPolygonParameter setParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSetPathPolygonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSetPathPolygonSpawner* pInstance);
        static void Clean(ObjSetPathPolygonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSetPathConnectorSpawner {
        enum class PathType : int8_t {
            OBJ_PATH = 0,
            GR_PATH = 1,
            SV_PATH = 2,
        };

        int32_t pathUID;
        PathType pathType;
        csl::ut::MoveArray<hh::game::ObjectId> pathList;
        bool isLoopPath;
        float divideLength;
        bool isMovable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSetPathConnectorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSetPathConnectorSpawner* pInstance);
        static void Clean(ObjSetPathConnectorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShotgunTouchManagerSpawner {
        int32_t no;
        float createRadiusMin;
        float createRadiusMax;
        float createHeight;
        float createVelocity;
        hh::game::ObjectId switchId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShotgunTouchManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShotgunTouchManagerSpawner* pInstance);
        static void Clean(ObjShotgunTouchManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShotgunTouchSwitchSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShotgunTouchSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShotgunTouchSwitchSpawner* pInstance);
        static void Clean(ObjShotgunTouchSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShutterSpawner {
        int32_t no;
        csl::math::Vector3 shutterSize;
        float moveHeight;
        float moveSpeed;
        bool initOpen;
        csl::ut::MoveArray<hh::game::ObjectId> moveLinkList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShutterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShutterSpawner* pInstance);
        static void Clean(ObjShutterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSilverMoonRingSpawner {
        enum class ModelType : int8_t {
            NORMAL = 0,
            TRANSLUCENT = 1,
        };

        enum class Rotate : int8_t {
            OBJ_Y_UP = 0,
            WORLD_Y_UP = 1,
        };

        ModelType modelType;
        int32_t ItemId;
        Rotate RotateType;
        float collisionRadius;
        float removeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSilverMoonRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSilverMoonRingSpawner* pInstance);
        static void Clean(ObjSilverMoonRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSlashCommonSpawner {
        enum class ObjType : int8_t {
            BONFIRE = 0,
            LIGHT_LARGE = 1,
            LIGHT_MEDIUM = 2,
            LIGHT_SMALL = 3,
            CUTTREE = 4,
            DEADLEAVES = 5,
            SANDPILE = 6,
            ASHPILE = 7,
            LANTERN = 8,
            FLOWER = 9,
            LIGHT_TREE = 10,
            GIMMICK_LIGHT = 11,
            OBJTYPE_NUM = 12,
        };

        enum class Condition : int8_t {
            COND_ONCE = 0,
            COND_TIMER = 1,
        };

        int32_t no;
        bool eventDriven;
        ObjType type;
        Condition condition;
        float activateTime;
        bool isLimitedTime;
        uint32_t startHour;
        uint32_t startMin;
        uint32_t endHour;
        uint32_t endMin;
        bool timingBugFixEnable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSlashCommonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSlashCommonSpawner* pInstance);
        static void Clean(ObjSlashCommonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSliderParamTriggerSpawner {
        float speed;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSliderParamTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSliderParamTriggerSpawner* pInstance);
        static void Clean(ObjSliderParamTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSliderTriggerSpawner {
        enum class ActionType : int8_t {
            ACT_BEGIN = 0,
            ACT_END = 1,
        };

        ActionType action;
        float speed;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSliderTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSliderTriggerSpawner* pInstance);
        static void Clean(ObjSliderTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpinnerISpawner {
        enum class MoveType : int8_t {
            Fix = 0,
            Path = 1,
            TwoPoint = 2,
        };

        enum class RotateType : int8_t {
            ChangeByTime = 0,
            OnlyNormal = 1,
            OnlyHighSpeed = 2,
        };

        int32_t no;
        uint32_t level;
        MoveType moveType;
        csl::ut::VariableString pathName;
        csl::math::Vector3 twoPointOffset;
        float offsetPhase;
        float moveSpeed;
        float changeStartTime;
        float changeEndTime;
        float rotatePhase;
        bool rigidbody;
        RotateType rotateType;
        float rigidColliderRadius;
        float damageColliderRadius;
        float battleDistance;
        float rotateSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpinnerISpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpinnerISpawner* pInstance);
        static void Clean(ObjSpinnerISpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpotLightSpawner {
        float colorR;
        float colorG;
        float colorB;
        float innerConeAngle;
        float outerConeAngle;
        float attenuationRadius;
        bool enableShadow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpotLightSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpotLightSpawner* pInstance);
        static void Clean(ObjSpotLightSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderRollingParam {
        float speed;
        float phase;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderRollingParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderRollingParam* pInstance);
        static void Clean(ObjSpiderRollingParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpringSpawner {
        enum class Visual : int8_t {
            Normal = 0,
            Sky = 1,
        };

        Visual visual;
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;
        bool isHorming;
        bool isEventOn;
        bool isCyloopOn;
        float cyloopSignDistance;
        float cyloopSignTolerance;
        bool isCyKnuckleOn;
        bool isHorizon;
        bool airtrick;
        bool isVisible;
        bool isSmooth;
        heur::rfl::ActionNotification actions[3];
        heur::rfl::ObjSpiderRollingParam rollingParam;
        csl::math::Vector3 offsetCollision;
        csl::math::Vector3 scaleCollision;
        bool isConstrain;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpringSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpringSpawner* pInstance);
        static void Clean(ObjSpringSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpringPoleSpawner {
        float speedMin;
        float speedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpringPoleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpringPoleSpawner* pInstance);
        static void Clean(ObjSpringPoleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStartPositionSpawner {
        enum class StartType : int8_t {
            STAND = 0,
            RUNNING = 1,
            FALL = 2,
            DOWN = 3,
            BOARDING = 4,
        };

        StartType m_startType;
        float m_speed;
        float m_time;
        float m_outOfControlTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStartPositionSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStartPositionSpawner* pInstance);
        static void Clean(ObjStartPositionSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStorageKeySpawner {
        int32_t no;
        bool eventDriven;
        bool cyloopDriven;
        float cyloopSignDistance;
        float cyloopSignTolerance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStorageKeySpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStorageKeySpawner* pInstance);
        static void Clean(ObjStorageKeySpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSwitchVolumeSpawner {
        enum class Condition : int8_t {
            COND_ON_TRIGGER = 0,
            COND_PULSE = 1,
            COND_TIMER_ONCE = 2,
            COND_TIMER = 3,
            COND_ON_STAY = 4,
        };

        Condition condition;
        float lifetime;
        bool eventDriven;
        heur::rfl::VolumeTriggerSpawner volume;
        heur::rfl::ActionNotification actions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSwitchVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSwitchVolumeSpawner* pInstance);
        static void Clean(ObjSwitchVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTerrainBlockSpawner {
        enum class Block : int8_t {
            BLOCK_BOX = 0,
            BLOCK_ARCH_CURVE_UP = 1,
            BLOCK_ARCH_CURVE_DOWN = 2,
            BLOCK_ARCH_CURVE_RIGHT = 3,
            BLOCK_ARCH_CURVE_LEFT = 4,
        };

        enum class Layer : int8_t {
            LAYER_LAND = 0,
            LAYER_MOVELAND = 1,
        };

        enum class WallType : int8_t {
            WALL_NONE = 0,
            WALL_EXIST = 1,
            WALL_COLLISION = 2,
        };

        enum class Color : int8_t {
            COLOR_GREEN = 0,
            COLOR_BROWN = 1,
            COLOR_BLUE = 2,
            COLOR_WHITE = 3,
            COLOR_RED = 4,
            COLOR_YELLOW = 5,
        };

        Block BlockType;
        float BlockWidth;
        float BlockWidthEnd;
        float BlockHeight;
        float BlockDepth;
        float BlockDepthOffset;
        float ArchRadius;
        float ArchDegree;
        uint32_t ArchDivNum;
        float SlopeHeight;
        Layer LayerGroup;
        bool AttrParkour;
        bool AttrBreakable;
        bool AttrSlope;
        bool AttrWall;
        bool AttrLoop;
        bool AttrSlide;
        WallType WallLeft;
        WallType WallRight;
        WallType WallFront;
        WallType WallBack;
        float WallHeight;
        Color ColorType;
        float Interval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTerrainBlockSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTerrainBlockSpawner* pInstance);
        static void Clean(ObjTerrainBlockSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct Point {
        float z;
        float y;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Point* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Point* pInstance);
        static void Clean(Point* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTerrainBlocksSpawner {
        enum class Layer : int8_t {
            LAYER_LAND = 0,
            LAYER_MOVELAND = 1,
        };

        enum class WallType : int8_t {
            WALL_NONE = 0,
            WALL_EXIST = 1,
            WALL_COLLISION = 2,
        };

        enum class Color : int8_t {
            COLOR_GREEN = 0,
            COLOR_BROWN = 1,
            COLOR_BLUE = 2,
            COLOR_WHITE = 3,
            COLOR_RED = 4,
            COLOR_YELLOW = 5,
        };

        float Width;
        float Height;
        heur::rfl::Point Blocks[30];
        Layer LayerGroup;
        bool AttrEnableParkour;
        WallType WallLeft;
        WallType WallRight;
        WallType WallFront;
        WallType WallBack;
        float WallHeight;
        Color ColorType;
        float Interval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTerrainBlocksSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTerrainBlocksSpawner* pInstance);
        static void Clean(ObjTerrainBlocksSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTerrainPathSpawner {
        enum class WallType : int8_t {
            WALL_NONE = 0,
            WALL_EXIST = 1,
            WALL_COLLISION = 2,
        };

        enum class NormalType : int8_t {
            NORMAL_BY_YUP = 0,
            NORMAL_BY_PATH = 1,
        };

        csl::ut::VariableString pathName;
        float widthStart;
        float widthEnd;
        float height;
        float wallHeight;
        int32_t split;
        WallType rightWallType;
        WallType leftWallType;
        WallType frontWallType;
        WallType backWallType;
        bool attrLoop;
        NormalType normalType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTerrainPathSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTerrainPathSpawner* pInstance);
        static void Clean(ObjTerrainPathSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTerrainPathCylinderSpawner {
        csl::ut::VariableString pathName;
        float radius;
        int32_t numPlain;
        float splitDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTerrainPathCylinderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTerrainPathCylinderSpawner* pInstance);
        static void Clean(ObjTerrainPathCylinderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjThornSpawner {
        enum class MoveType : int8_t {
            TYPE_APPEAR = 0,
            TYPE_DISAPPEAR = 1,
            TYPE_MOVE = 2,
        };

        csl::math::Vector2 size;
        csl::math::Vector2 interval;
        float offTime;
        float onTime;
        float phase;
        MoveType type;
        bool eventDriven;
        bool hasRigidbody;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjThornSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjThornSpawner* pInstance);
        static void Clean(ObjThornSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjThornBallMoveParam {
        enum class Direction : int8_t {
            DIR_HORIZONTAL = 0,
            DIR_VERTICAL = 1,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        float time;
        float distance;
        float phase;
        Direction direction;
        TimeType timeType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjThornBallMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjThornBallMoveParam* pInstance);
        static void Clean(ObjThornBallMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjThornBallRollingParam {
        enum class Direction : int8_t {
            DIR_HORIZONTAL = 0,
            DIR_VERTICAL = 1,
        };

        float time;
        float radius;
        float phase;
        Direction direction;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjThornBallRollingParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjThornBallRollingParam* pInstance);
        static void Clean(ObjThornBallRollingParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjThornBallSpawner {
        enum class Type : int8_t {
            TYPE_NORMAL = 0,
            TYPE_MOVE = 1,
            TYPE_ROLLING = 2,
        };

        enum class ModelType : int8_t {
            MODEL_NORMAL = 0,
            MODEL_AMY = 1,
        };

        Type type;
        ModelType modelType;
        bool hitEnemy;
        heur::rfl::ObjThornBallMoveParam moveParam;
        heur::rfl::ObjThornBallRollingParam rollingParam;
        bool eventDriven;
        float collisionRate;
        bool isEnableTimeStop;
        float stopTime;
        int8_t timeStopGroupID;
        float offsetY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjThornBallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjThornBallSpawner* pInstance);
        static void Clean(ObjThornBallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjThornCylinderSpawner {
        enum class Type : int8_t {
            TYPE_SHORT = 0,
            TYPE_LONG = 1,
            NUM_TYPES = 2,
        };

        Type type;
        bool rigidbody;
        bool isMoveFloorEntry;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjThornCylinderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjThornCylinderSpawner* pInstance);
        static void Clean(ObjThornCylinderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeBallSpawner {
        float height;
        bool upd3flag;
        float gravity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeBallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeBallSpawner* pInstance);
        static void Clean(ObjTimeBallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeBallGeneratorSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeBallGeneratorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeBallGeneratorSpawner* pInstance);
        static void Clean(ObjTimeBallGeneratorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeBallGoalSpawner {
        int32_t no;
        float radius;
        float height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeBallGoalSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeBallGoalSpawner* pInstance);
        static void Clean(ObjTimeBallGoalSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeBallManagerSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> goals;
        hh::game::ObjectId ball;
        hh::game::ObjectId ballGenerator;
        float time;
        float maxDistance;
        bool isUseStartCamera;
        hh::game::ObjectId startCamera;
        float startWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeBallManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeBallManagerSpawner* pInstance);
        static void Clean(ObjTimeBallManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeBombSpawner_ActivationCamera {
        csl::math::Vector3 positionOffset;
        csl::math::Vector3 targetOffset;
        float fovy;
        float endInterpolateTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeBombSpawner_ActivationCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeBombSpawner_ActivationCamera* pInstance);
        static void Clean(ObjTimeBombSpawner_ActivationCamera* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeBombSpawner {
        heur::rfl::ObjTimeBombSpawner_ActivationCamera activationCamera;
        bool disableInputInCatching;
        float catchingMoveHeight;
        float limitTime;
        csl::math::Vector3 levitationOffset;
        float levitationAngleY;
        float levitationFollowFactor;
        float cameraDistance;
        float cameraInitialElevation;
        csl::math::Vector3 putOffset;
        float explodeRadius;
        float explodeTime;
        float despawnTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeBombSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeBombSpawner* pInstance);
        static void Clean(ObjTimeBombSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeBombGeneratorSpawner {
        heur::rfl::ObjTimeBombSpawner timeBomb;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeBombGeneratorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeBombGeneratorSpawner* pInstance);
        static void Clean(ObjTimeBombGeneratorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimerPanelSpawner {
        int32_t no;
        hh::game::ObjectId linkObj;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimerPanelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimerPanelSpawner* pInstance);
        static void Clean(ObjTimerPanelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimerPowerupSeedSpawner {
        enum class SeedType : int8_t {
            POWER = 0,
            GUARD = 1,
        };

        int32_t no;
        SeedType type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimerPowerupSeedSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimerPowerupSeedSpawner* pInstance);
        static void Clean(ObjTimerPowerupSeedSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimerRingSpawner {
        enum class SetType : int8_t {
            EquallySpaced = 0,
            NodeID = 1,
        };

        int32_t no;
        csl::ut::VariableString pathName;
        SetType setType;
        int8_t num;
        csl::ut::MoveArray<hh::game::ObjectId> setNodeList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimerRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimerRingSpawner* pInstance);
        static void Clean(ObjTimerRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimerSwitchSpawner {
        int32_t no;
        float activateTime;
        bool isUseStartCamera;
        hh::game::ObjectId startCamera;
        float startWaitTime;
        bool isFristSEPlay;
        bool individualTimer;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimerSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimerSwitchSpawner* pInstance);
        static void Clean(ObjTimerSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeStopVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeStopVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeStopVolumeSpawner* pInstance);
        static void Clean(ObjTimeStopVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTombStatueSpawner {
        int32_t no;
        bool isLock;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTombStatueSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTombStatueSpawner* pInstance);
        static void Clean(ObjTombStatueSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTombStoneManagerSpawner {
        csl::ut::MoveArray<hh::game::ObjectId> rotateList;
        hh::game::ObjectId cameraActivator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTombStoneManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTombStoneManagerSpawner* pInstance);
        static void Clean(ObjTombStoneManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTowerSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTowerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTowerSpawner* pInstance);
        static void Clean(ObjTowerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTraceStoneBuilderSpawner {
        csl::math::Vector3 size;
        hh::game::ObjectId controlBoard;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTraceStoneBuilderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTraceStoneBuilderSpawner* pInstance);
        static void Clean(ObjTraceStoneBuilderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTraceStoneBuildSwitchSpawner {
        csl::ut::MoveArray<hh::game::ObjectId> relatedObj;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTraceStoneBuildSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTraceStoneBuildSwitchSpawner* pInstance);
        static void Clean(ObjTraceStoneBuildSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTraceStoneControlBoardSpawner {
        int8_t recordNum;
        hh::game::ObjectId boardSwitch;
        csl::ut::MoveArray<hh::game::ObjectId> anchors;
        uint32_t developInput;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTraceStoneControlBoardSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTraceStoneControlBoardSpawner* pInstance);
        static void Clean(ObjTraceStoneControlBoardSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTreasureChestSpawner {
        enum class EventType : int8_t {
            EVENT_NONE = 0,
            EVENT_HIDE = 1,
            EVENT_NO_REACTION = 2,
        };

        int32_t no;
        EventType eventDriven;
        int32_t num;
        bool useSubCamera;
        csl::math::Vector3 subCameraPos;
        csl::math::Vector3 subCameraTarget;
        float subCameraDuration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTreasureChestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTreasureChestSpawner* pInstance);
        static void Clean(ObjTreasureChestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTutorialWallSpawner {
        csl::math::Vector3 scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTutorialWallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTutorialWallSpawner* pInstance);
        static void Clean(ObjTutorialWallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTutoIslandVolumeSpawner {
        enum class TutoIsland : uint8_t {
            CAMERA = 0,
            CHALLENGE = 1,
            PRACTICE = 2,
            SKILL_PIECE = 3,
            ENEMY_LEVEL = 4,
            NINJA = 5,
            PORTAL_PIECE = 6,
            PUZZLE = 7,
            CYLOOP = 8,
            CYLOOP_TEST = 9,
            CYLOOP_ENEMY = 10,
            PORTAL = 11,
            PARRY = 12,
            BRIDGE = 13,
            SPRING = 14,
            MAP = 15,
            NUM = 16,
        };

        enum class TutoAction : uint8_t {
            PHASE_NONE = 0,
            PHASE_START = 1,
            PHASE_START_AUTO_CLEAR = 2,
            PHASE_CLEAR = 3,
        };

        heur::rfl::VolumeTriggerSpawner volume;
        TutoIsland islandPhase;
        TutoAction enterAction;
        TutoAction leaveAction;
        bool showClearUI;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTutoIslandVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTutoIslandVolumeSpawner* pInstance);
        static void Clean(ObjTutoIslandVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct FrontParam {
        float frontOcTime;
        float frontSpeed;
        float frontKeepVelocityTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FrontParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FrontParam* pInstance);
        static void Clean(FrontParam* pInstance);
    };
}

namespace heur::rfl {
    struct BackParam {
        float backOcTime;
        float backSpeed;
        float backKeepVelocityTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BackParam* pInstance);
        static void Clean(BackParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTwoWayGrindBoosterSpawner {
        heur::rfl::FrontParam frontParam;
        heur::rfl::BackParam backParam;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTwoWayGrindBoosterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTwoWayGrindBoosterSpawner* pInstance);
        static void Clean(ObjTwoWayGrindBoosterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjUnmovedStatueSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjUnmovedStatueSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjUnmovedStatueSpawner* pInstance);
        static void Clean(ObjUnmovedStatueSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjUnmovedTombStoneSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> targetList;
        hh::game::ObjectId tombStatue;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjUnmovedTombStoneSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjUnmovedTombStoneSpawner* pInstance);
        static void Clean(ObjUnmovedTombStoneSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarpObjVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;
        hh::game::ObjectId target;
        hh::game::ObjectId transformLocator;
        bool is_use_disp;
        bool is_disp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarpObjVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarpObjVolumeSpawner* pInstance);
        static void Clean(ObjWarpObjVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarpTriggerSpawner {
        enum class StatusType : int8_t {
            RESET = 0,
            CONTINUANCE = 1,
        };

        hh::game::ObjectId warpPoint;
        StatusType status;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarpTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarpTriggerSpawner* pInstance);
        static void Clean(ObjWarpTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct WaterFallVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WaterFallVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WaterFallVolumeSpawner* pInstance);
        static void Clean(WaterFallVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWaterVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWaterVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWaterVolumeSpawner* pInstance);
        static void Clean(ObjWaterVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWaveCannonBoxSpawner {
        enum class BoxSize : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_NUM = 3,
        };

        BoxSize size;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWaveCannonBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWaveCannonBoxSpawner* pInstance);
        static void Clean(ObjWaveCannonBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWaveCannonWallSpawner {
        enum class WallSize : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_NUM = 3,
        };

        WallSize size;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWaveCannonWallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWaveCannonWallSpawner* pInstance);
        static void Clean(ObjWaveCannonWallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWeightSpawner {
        float scale;
        float offsetY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWeightSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWeightSpawner* pInstance);
        static void Clean(ObjWeightSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWeightSwitchSpawner {
        enum class TurnOnType : int8_t {
            TYPE_WEIGHT = 0,
            TYPE_STOMPING = 1,
            TYPE_NUM = 2,
        };

        enum class Condition : int8_t {
            COND_TIMER = 0,
            COND_ENTER = 1,
            COND_NUM = 2,
        };

        TurnOnType turnOnType;
        Condition condition;
        float activateTime;
        float cyHammerTime;
        bool isConstrain;
        heur::rfl::ActionNotification actions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWeightSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWeightSwitchSpawner* pInstance);
        static void Clean(ObjWeightSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWhirlpoolDrainageSpawner {
        float waterColliderRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWhirlpoolDrainageSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWhirlpoolDrainageSpawner* pInstance);
        static void Clean(ObjWhirlpoolDrainageSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWideSpringSpawner {
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWideSpringSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWideSpringSpawner* pInstance);
        static void Clean(ObjWideSpringSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWoodBoxSpawner {
        float offsetY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWoodBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWoodBoxSpawner* pInstance);
        static void Clean(ObjWoodBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAnimalSpawner {
        enum class ModelType : int8_t {
            Pocky = 0,
            Ricky = 1,
            Rocky = 2,
            Cookie = 3,
            Flicky = 4,
            Pecky = 5,
            Picky = 6,
            MODEL_NUM = 7,
        };

        ModelType type;
        hh::game::ObjectId target;
        float range;
        float jumpHeight;
        float jumpTime;
        int32_t displayOrder;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAnimalSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAnimalSpawner* pInstance);
        static void Clean(ObjAnimalSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAnimalRescueAreaSpawner {
        float scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAnimalRescueAreaSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAnimalRescueAreaSpawner* pInstance);
        static void Clean(ObjAnimalRescueAreaSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAppearBoxSpawner {
        bool eventDriven;
        uint32_t blockNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAppearBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAppearBoxSpawner* pInstance);
        static void Clean(ObjAppearBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBalloonSpawner {
        enum class Color : int8_t {
            COLOR_W9 = 0,
            COLOR_RED = 1,
            COLOR_BLUE = 2,
            COLOR_YELLOW = 3,
            COLOR_GREEN = 4,
            NUM_COLORS = 5,
        };

        enum class Dimension : int8_t {
            DIM_SV = 0,
            DIM_FV = 1,
        };

        Color balloonColor;
        Dimension dimension;
        float upSpeed;
        float speedMin;
        float speedMax;
        float respawnTime;
        float outOfControlTime;
        float keepVelocityTime;
        float ignoreSwingingTime;
        bool isDefaultPositionRespawn;
        bool isGroupSet;
        bool eventDriven;
        bool isHorming;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBalloonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBalloonSpawner* pInstance);
        static void Clean(ObjBalloonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBoardingJumpBoardSpawner {
        enum class SizeType : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_L = 2,
            SIZE_COUNT = 3,
        };

        enum class Trick : int8_t {
            NONE = 0,
            YES = 1,
            BUTTTON = 2,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        float distance;
        float height;
        float outStrength;
        float inStrength;
        float inAngle;
        float impulseSpeedOn;
        float outOfControl;
        float motionTime;
        SizeType size;
        heur::rfl::ActionNotification actions[3];
        Trick useTrick;
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        bool eventDriven;
        bool isFall;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;
        bool isChange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBoardingJumpBoardSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBoardingJumpBoardSpawner* pInstance);
        static void Clean(ObjBoardingJumpBoardSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBreakCliffSpawner {
        enum class TerminusType : int8_t {
            NONE = 0,
            RIGHT_ONRY = 1,
            LEFT_ONRY = 2,
            BOTH = 3,
        };

        float shakeWaitTime;
        float shakeTime;
        bool doesRespawn;
        float respawnTime;
        uint32_t num;
        TerminusType terminus;
        bool isFall;
        bool isLightVersion;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBreakCliffSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBreakCliffSpawner* pInstance);
        static void Clean(ObjBreakCliffSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCannonSpawner {
        enum class ModelType : int8_t {
            FV = 0,
            FV_BASELESS = 1,
            SV = 2,
            SV_BASELESS = 3,
            MODEL_NUM = 4,
        };

        enum class TargetType : int8_t {
            OBJECT = 0,
            COORDINATE = 1,
        };

        ModelType modelType;
        TargetType targetType;
        hh::game::ObjectId target;
        csl::math::Vector3 targetPos;
        float speed;
        float velocityRatio;
        float keepVelocity;
        bool isAutoShot;
        bool isMovableBarrel;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCannonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCannonSpawner* pInstance);
        static void Clean(ObjCannonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCarSpawner {
        enum class ActionType : int8_t {
            RUN = 0,
            BOARDING = 1,
        };

        enum class CarType : int8_t {
            MINIVAN = 0,
            HATCHBACK = 1,
            VAN = 2,
            TYPE_COUNT = 3,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        ActionType actionType;
        float addSpeed;
        float distance;
        float height;
        float outStrength;
        float inStrength;
        float inAngle;
        float impulseSpeedOn;
        float outOfControl;
        float motionTime;
        CarType carType;
        uint32_t color;
        float addTime;
        heur::rfl::ActionNotification actions[3];
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        bool eventDriven;
        bool isFall;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;
        bool optimized;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCarSpawner* pInstance);
        static void Clean(ObjCarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCarrierCarSpawner {
        enum class SizeType : int8_t {
            SIZE_S = 0,
            SIZE_M = 1,
            SIZE_COUNT = 2,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        float outOfControl;
        float keepVelocity;
        float launchSpeed;
        float launchAngle;
        bool posConst;
        bool veloConst;
        SizeType size;
        heur::rfl::ActionNotification actions[3];
        bool isUsingButtonAction;
        float addTime;
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        bool eventDriven;
        bool isFall;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCarrierCarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCarrierCarSpawner* pInstance);
        static void Clean(ObjCarrierCarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjChangeSwitchSpawner {
        enum class Condition : int8_t {
            COND_ON_TRIGGER = 0,
            COND_PULSE = 1,
            COND_TIMER_ONCE = 2,
            COND_TIMER = 3,
            COND_ON_STAY = 4,
        };

        Condition condition;
        float lifetime;
        bool eventDriven;
        heur::rfl::VolumeTriggerSpawner volume;
        heur::rfl::ActionNotification actions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjChangeSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjChangeSwitchSpawner* pInstance);
        static void Clean(ObjChangeSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCloudFloorSpawner {
        enum class Visual : int8_t {
            Cloud2m = 0,
            Cloud5m = 1,
            Cloud7m = 2,
            NumVisuals = 3,
        };

        enum class ActionOnEvent : int8_t {
            Appear = 0,
            Disappear = 1,
            NumActionsOnEvent = 2,
        };

        Visual visual;
        bool eventDriven;
        ActionOnEvent actionOnEvent;
        float timeTilDisappear;
        float upwardSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCloudFloorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCloudFloorSpawner* pInstance);
        static void Clean(ObjCloudFloorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct FigureEightMove {
        float rotateMaxspeed;
        float rotateMinSpeed;
        float diameter;
        float accelerationRate;
        float decelerationRate;
        float decelerationAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FigureEightMove* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FigureEightMove* pInstance);
        static void Clean(FigureEightMove* pInstance);
    };
}

namespace heur::rfl {
    struct CircleMove {
        float rotateMaxspeed;
        float rotateMinSpeed;
        float straightSpeed;
        float radius;
        float rotateAccelerationRate;
        float rotateDecelerationRate;
        float straightAccelerationRate;
        float rotateDecelerationAngle;
        float stayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CircleMove* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CircleMove* pInstance);
        static void Clean(CircleMove* pInstance);
    };
}

namespace heur::rfl {
    struct BulletParameter {
        float bulletSpeed;
        float bulletWaitTime;
        float bulletShotNum;
        float bulletInterval;
        float bulletRange;
        float bulletToPlayerOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BulletParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BulletParameter* pInstance);
        static void Clean(BulletParameter* pInstance);
    };
}

namespace heur::rfl {
    struct DashRingParameter {
        bool UseDashRing;
        float OutOfControl;
        float KeepVelocity;
        float Speed;
        bool PosConst;
        bool VeloConst;
        bool Spin;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DashRingParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DashRingParameter* pInstance);
        static void Clean(DashRingParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ConeCollision {
        float angle;
        float nearClip;
        float farClip;
        float offset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ConeCollision* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ConeCollision* pInstance);
        static void Clean(ConeCollision* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDivingAirPlaneSpawner {
        bool isEventDriven;
        heur::rfl::VolumeTriggerSpawner volume;
        float startStayTime;
        float lowDafaultPlayerSpeed;
        float lowFastPlayerSpeed;
        float highDafaultPlayerSpeed;
        float highFastPlayerSpeed;
        float verticalSpeed;
        heur::rfl::FigureEightMove figureEightMove;
        heur::rfl::CircleMove circleMove;
        float stayTime;
        float homingDistOffset;
        float setupWeaponTime;
        float attackWeaponTime;
        uint32_t circleWeaponNum;
        float cirlcleWeaponRange;
        uint32_t crossWeaponNum;
        float crossWeaponRange;
        float nextPatternTime;
        float targetToPlayerDist;
        float gameoverDist;
        float gameoverPlayerPos;
        csl::math::Vector3 firstNozzle;
        csl::math::Vector3 secondNozzle;
        heur::rfl::BulletParameter mainPattern;
        heur::rfl::BulletParameter subPattern;
        heur::rfl::DashRingParameter dishRingParam;
        csl::math::Vector3 scale;
        bool visiableCollision;
        bool visiableWeaponDebug;
        heur::rfl::ConeCollision lowSlipCol;
        heur::rfl::ConeCollision highSlipCol;
        heur::rfl::ConeCollision weaponCol;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDivingAirPlaneSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDivingAirPlaneSpawner* pInstance);
        static void Clean(ObjDivingAirPlaneSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDownReelSpawner {
        uint32_t standLegNum;
        uint32_t standStickNum;
        float maxLength;
        float shotLength;
        float downSpeedMax;
        float upSpeedMax;
        float firstSpeed;
        float shotAngle;
        float outOfControl;
        bool isExtendOver;
        bool isOneTimeUp;
        bool eventDriven;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDownReelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDownReelSpawner* pInstance);
        static void Clean(ObjDownReelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDriftEndVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDriftEndVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDriftEndVolumeSpawner* pInstance);
        static void Clean(ObjDriftEndVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDriftPanelSpawner {
        float speed;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDriftPanelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDriftPanelSpawner* pInstance);
        static void Clean(ObjDriftPanelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDropBridgeSpawner {
        bool isEventOn;
        float dropWaitTime;
        float animSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDropBridgeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDropBridgeSpawner* pInstance);
        static void Clean(ObjDropBridgeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDropBridgeSVSpawner : heur::rfl::ObjDropBridgeSpawner {
        enum class ModelType : int8_t {
            TYPE_A = 0,
            TYPE_B = 1,
            TYPE_E = 2,
            TYPE_F = 3,
        };

        ModelType modelType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDropBridgeSVSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDropBridgeSVSpawner* pInstance);
        static void Clean(ObjDropBridgeSVSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDropFloorSpawner {
        int32_t blockNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDropFloorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDropFloorSpawner* pInstance);
        static void Clean(ObjDropFloorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDropTowerSpawner {
        enum class PiecesType : int8_t {
            TYPE_A = 0,
            TYPE_B = 1,
            TYPE_C = 2,
            TYPE_D = 3,
        };

        int32_t piecesNum;
        float dropTime;
        PiecesType piecesType[29];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDropTowerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDropTowerSpawner* pInstance);
        static void Clean(ObjDropTowerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGoalTriggerSpawner {
        enum class GoalActionType : int8_t {
            GOALACTIONTYPE_STOP = 0,
            GOALACTIONTYPE_BRAKE = 1,
            GOALACTIONTYPE_DASH = 2,
        };

        float goalTime;
        GoalActionType actionType;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGoalTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGoalTriggerSpawner* pInstance);
        static void Clean(ObjGoalTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGrindThornSpawner {
        bool reverse;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGrindThornSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGrindThornSpawner* pInstance);
        static void Clean(ObjGrindThornSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GunTruckAppear {
        bool bySwitch;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GunTruckAppear* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GunTruckAppear* pInstance);
        static void Clean(GunTruckAppear* pInstance);
    };
}

namespace heur::rfl {
    struct GunTruckMove {
        enum class MoveType : uint8_t {
            Fixed = 0,
            TwoPt = 1,
            OnPath = 2,
        };

        MoveType moveType;
        float keepDistance;
        csl::math::Vector3 twoPtDest;
        csl::ut::VariableString pathName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GunTruckMove* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GunTruckMove* pInstance);
        static void Clean(GunTruckMove* pInstance);
    };
}

namespace heur::rfl {
    struct GunTruckAttack {
        bool changeParam;
        float shotStartAngle;
        float shotDuration;
        float shotAngVel;
        float shotRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GunTruckAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GunTruckAttack* pInstance);
        static void Clean(GunTruckAttack* pInstance);
    };
}

namespace heur::rfl {
    struct GunTruckDie {
        enum class DieType : uint8_t {
            Distance = 0,
            Time = 1,
            Unlimited = 2,
        };

        DieType dieType;
        float dieDistance;
        float dieTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GunTruckDie* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GunTruckDie* pInstance);
        static void Clean(GunTruckDie* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGunTruckSpawner {
        heur::rfl::GunTruckAppear appear;
        heur::rfl::GunTruckMove move;
        heur::rfl::GunTruckAttack attack[3];
        heur::rfl::GunTruckDie die;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGunTruckSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGunTruckSpawner* pInstance);
        static void Clean(ObjGunTruckSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHanggliderSpawner {
        enum class MoveType : int8_t {
            MOVE_POINT = 0,
            MOVE_PATH = 1,
        };

        MoveType moveType;
        csl::math::Vector3 moveVector;
        float waitTime;
        csl::ut::VariableString pathName;
        float finishDist;
        float moveSpeed;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHanggliderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHanggliderSpawner* pInstance);
        static void Clean(ObjHanggliderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct HelicopterMoveParam {
        enum class MoveType : int8_t {
            MOVE_POINT = 0,
            MOVE_PATH = 1,
        };

        MoveType moveType;
        csl::math::Vector3 moveVector;
        float finishVectorRatio;
        float waitTime;
        csl::ut::VariableString pathName;
        float finishDist;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HelicopterMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HelicopterMoveParam* pInstance);
        static void Clean(HelicopterMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHelicopterCarrySpawner {
        enum class CatchType : int8_t {
            RIGHT = 0,
            LEFT = 1,
        };

        heur::rfl::HelicopterMoveParam firstMove;
        heur::rfl::HelicopterMoveParam secondMove;
        CatchType catchType;
        bool eventDriven;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHelicopterCarrySpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHelicopterCarrySpawner* pInstance);
        static void Clean(ObjHelicopterCarrySpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ShotInfo {
        float distance;
        float height;
        float outStrength;
        float inStrength;
        float inAngle;
        float impulseSpeedOn;
        float outOfControl;
        float motionTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ShotInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ShotInfo* pInstance);
        static void Clean(ShotInfo* pInstance);
    };
}

namespace heur::rfl {
    struct ObjJumpPanelClassicSpawner {
        heur::rfl::ShotInfo lowShot;
        heur::rfl::ShotInfo highShot;
        float directionMoveSpeed;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjJumpPanelClassicSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjJumpPanelClassicSpawner* pInstance);
        static void Clean(ObjJumpPanelClassicSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct JumpSelectorLaunch {
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(JumpSelectorLaunch* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(JumpSelectorLaunch* pInstance);
        static void Clean(JumpSelectorLaunch* pInstance);
    };
}

namespace heur::rfl {
    struct ObjJumpSelectorSpawner {
        enum class JumpSelectorType : uint8_t {
            JUMP = 0,
            ATTACK = 1,
            SELECT = 2,
        };

        JumpSelectorType type;
        float inputTime;
        heur::rfl::JumpSelectorLaunch launchJump;
        heur::rfl::JumpSelectorLaunch launchAttack;
        float outOfControlMiss;
        float collisionRadius;
        bool reusable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjJumpSelectorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjJumpSelectorSpawner* pInstance);
        static void Clean(ObjJumpSelectorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLaserFenceSpawner {
        enum class ActionType : int8_t {
            ACT_LOOP = 0,
            ACT_ONCE = 1,
            ACT_KEEP = 2,
            NUM_ACT_TYPE = 3,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        ActionType actionType;
        TimeType timeType;
        float laserLength;
        float waitTime;
        float activeTime;
        float phase;
        bool isEventDriven;
        bool isSE;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLaserFenceSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLaserFenceSpawner* pInstance);
        static void Clean(ObjLaserFenceSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLineEffectGeneratorSpawner {
        bool bySwitch;
        csl::math::Vector3 appearRange;
        float intervalMin;
        float intervalMax;
        float distance;
        csl::math::Vector2 moveRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLineEffectGeneratorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLineEffectGeneratorSpawner* pInstance);
        static void Clean(ObjLineEffectGeneratorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNitroBottleSpawner {
        float respawnTime;
        bool canAirBoost;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNitroBottleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNitroBottleSpawner* pInstance);
        static void Clean(ObjNitroBottleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNormalFloorSpawner {
        enum class SizeType : int8_t {
            SIZE_A = 0,
            SIZE_B = 1,
            SIZE_C = 2,
            SIZE_D = 3,
            SIZE_E = 4,
            SIZE_F = 5,
            SIZE_G = 6,
            SIZE_H = 7,
            SIZE_I = 8,
            SIZE_J = 9,
            NUM_SIZE_TYPE = 10,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        SizeType sizeType;
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        bool eventDriven;
        bool isFall;
        float waitFallTime;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        bool isPressDead;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNormalFloorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNormalFloorSpawner* pInstance);
        static void Clean(ObjNormalFloorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjThroughFloorSpawner : heur::rfl::ObjNormalFloorSpawner {
        enum class Visual : int8_t {
            Floor2m = 0,
            Floor3m = 1,
            Floor5m = 2,
            Floor7m = 3,
            NumVisuals = 4,
        };

        Visual visual;
        bool canGoThrough;
        bool doesRespawn;
        float respawnTime;
        float height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjThroughFloorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjThroughFloorSpawner* pInstance);
        static void Clean(ObjThroughFloorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNormalFloorLSpawner {
        enum class SizeType : int8_t {
            SizeType_5x15 = 0,
            SizeType_5x25 = 1,
            SizeType_10x30 = 2,
            SizeType_10x50 = 3,
            SizeType_Num = 4,
        };

        SizeType sizeType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNormalFloorLSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNormalFloorLSpawner* pInstance);
        static void Clean(ObjNormalFloorLSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNumberRingSpawner {
        enum class NoType : int8_t {
            No1 = 0,
            No2 = 1,
            No3 = 2,
            No4 = 3,
            No5 = 4,
            Num_No = 5,
        };

        enum class Event : int8_t {
            EVENT_NONE = 0,
            EVENT_VISIBLE = 1,
            EVENT_INVISIBLE = 2,
        };

        NoType noType;
        Event EventType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNumberRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNumberRingSpawner* pInstance);
        static void Clean(ObjNumberRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOperationGuideVolumeSpawner {
        enum class GuideType : int32_t {
            SideStep = 0,
            Boarding = 1,
            Diving = 2,
            Drift = 3,
        };

        float lifetime;
        heur::rfl::VolumeTriggerSpawner volume;
        GuideType guideType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOperationGuideVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOperationGuideVolumeSpawner* pInstance);
        static void Clean(ObjOperationGuideVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPipeCapSpawner {
        hh::game::ObjectId springId;
        csl::ut::VariableString pathName;
        bool isRideOnOnly;
        float pipeMoveVelocity;
        float shotVelocity;
        float colliderHeight;
        float colliderRadius;
        float signalSec;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPipeCapSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPipeCapSpawner* pInstance);
        static void Clean(ObjPipeCapSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPipeSpringSpawner {
        float velocitySpring;
        float outOfControlSpring;
        float velocityPipeOut;
        float outOfControlPipeOut;
        float closeSec;
        bool isStartClose;
        float colliderHeight;
        float colliderRadius;
        float openSec;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPipeSpringSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPipeSpringSpawner* pInstance);
        static void Clean(ObjPipeSpringSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPoleSpawner {
        enum class Type : int8_t {
            FV = 0,
            SV = 1,
        };

        Type type;
        bool isHorming;
        bool usedPillar;
        uint32_t sideBarNum;
        uint32_t pillarNum;
        float distanceOffset;
        csl::math::Vector3 colloffset;
        csl::math::Vector3 collisionSize;
        csl::math::Vector3 successShotVelocity;
        csl::math::Vector3 failShotVelocity;
        float outOfControlTime;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPoleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPoleSpawner* pInstance);
        static void Clean(ObjPoleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPurpleRockSpawner {
        enum class ViewType : int8_t {
            SV = 0,
            FV = 1,
            NumViewTypes = 2,
        };

        ViewType viewType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPurpleRockSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPurpleRockSpawner* pInstance);
        static void Clean(ObjPurpleRockSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPushBlockSpawner {
        csl::math::Vector3 size;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPushBlockSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPushBlockSpawner* pInstance);
        static void Clean(ObjPushBlockSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRingGeneratorSpawner {
        float interval;
        heur::rfl::PathMovement pathMovement;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRingGeneratorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRingGeneratorSpawner* pInstance);
        static void Clean(ObjRingGeneratorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRollingFloorSpawner {
        enum class ViewType : int8_t {
            SV = 0,
            FV = 1,
            NumViewTypes = 2,
        };

        enum class FloorVisual : int8_t {
            FloorA = 0,
            FloorB = 1,
            FloorC = 2,
            FloorD = 3,
            FloorE = 4,
            FloorF = 5,
            FloorG = 6,
            NoFloor = 7,
            NumFloorVisuals = 8,
        };

        enum class PoleVisual : int8_t {
            PoleA = 0,
            NoPole = 1,
            NumPoleVisuals = 2,
        };

        ViewType viewType;
        FloorVisual floorVisual;
        PoleVisual poleVisual;
        float floorOffsetY;
        float rotateAnglePerSec;
        float initialAngle;
        float rotateRange;
        bool isClockwise;
        bool eventDriven;
        bool doesPlaySE;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRollingFloorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRollingFloorSpawner* pInstance);
        static void Clean(ObjRollingFloorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct RotateBlockJumpParam {
        bool isEnable;
        bool isSpin;
        float velocityMax;
        float velocityMin;
        float judgeHeightRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RotateBlockJumpParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RotateBlockJumpParam* pInstance);
        static void Clean(RotateBlockJumpParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRotateBlockSpawner {
        enum class BasePointType : int8_t {
            Center = 0,
            Edge = 1,
        };

        enum class StartType : int8_t {
            Diagonal_1 = 0,
            Diagonal_2 = 1,
            Diagonal_3 = 2,
            Diagonal_4 = 3,
            Line_1 = 4,
            Line_2 = 5,
            Line_3 = 6,
            Line_4 = 7,
            Num = 8,
        };

        enum class MoveType : int8_t {
            None = 0,
            Once = 1,
            Loop = 2,
        };

        enum class AnimCurve : int8_t {
            Linear = 0,
            EaseIn = 1,
            EaseOut = 2,
            EaseInOut = 3,
        };

        enum class PressType : int8_t {
            None = 0,
            DeadAll = 1,
            DeadEdge = 2,
        };

        float blockExtents;
        int32_t numBlock;
        BasePointType basePointType;
        StartType startType;
        MoveType moveType;
        bool isClockWise;
        AnimCurve animCurve;
        float rotateTime;
        float rotateWaitTime;
        float rotateAngle;
        float offsetRatio;
        float moveRatio;
        bool eventDriven;
        bool rideOnDriven;
        PressType pressType;
        heur::rfl::RotateBlockJumpParam jumpParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRotateBlockSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRotateBlockSpawner* pInstance);
        static void Clean(ObjRotateBlockSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRotateThornBallAxisParam {
        float radius;
        uint32_t ballNum;
        float ballInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRotateThornBallAxisParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRotateThornBallAxisParam* pInstance);
        static void Clean(ObjRotateThornBallAxisParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRotateThornBallSpawner {
        enum class RotateType : int8_t {
            TYPE_RIGHT = 0,
            TYPE_LEFT = 1,
        };

        enum class StartType : int8_t {
            START_WAIT = 0,
            START_ROTATE = 1,
        };

        enum class PlaceType : int8_t {
            ON_GROUND = 0,
            IN_AIR = 1,
            NUM_PLACES = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        RotateType rotateType;
        float angularVelocity;
        StartType startType;
        PlaceType placeType;
        TimeType timeType;
        bool eventDriven;
        bool showCenterObj;
        uint32_t axisNum;
        heur::rfl::ObjRotateThornBallAxisParam axisParam[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRotateThornBallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRotateThornBallSpawner* pInstance);
        static void Clean(ObjRotateThornBallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShadowTailsSpawner {
        int32_t no;
        csl::ut::VariableString pathName;
        float moveSpeed;
        float modelSize;
        float railLength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShadowTailsSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShadowTailsSpawner* pInstance);
        static void Clean(ObjShadowTailsSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShadowTailsPlayerCompareSpawner {
        csl::ut::VariableString playerPathNames[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShadowTailsPlayerCompareSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShadowTailsPlayerCompareSpawner* pInstance);
        static void Clean(ObjShadowTailsPlayerCompareSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSideReelSpawner {
        bool visiableLegModel;
        uint32_t standLegNum;
        float length;
        float upSpeedMax;
        float firstSpeed;
        float shotAngle;
        float outOfControl;
        bool isOneTimeUp;
        bool eventDriven;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSideReelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSideReelSpawner* pInstance);
        static void Clean(ObjSideReelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSideViewPathVolumeSpawner {
        csl::ut::VariableString pathName;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSideViewPathVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSideViewPathVolumeSpawner* pInstance);
        static void Clean(ObjSideViewPathVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpringBoardSpawner {
        enum class Visual : int8_t {
            Normal = 0,
            Sky = 1,
        };

        Visual visual;
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;
        bool isEventOn;
        bool isHorizon;
        bool isVisible;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpringBoardSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpringBoardSpawner* pInstance);
        static void Clean(ObjSpringBoardSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpringClassicSpawner {
        enum class Visual : int8_t {
            Red = 0,
            Yellow = 1,
        };

        Visual visual;
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;
        bool usedYaw;
        bool isEventOn;
        bool isHorizon;
        bool isVisible;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpringClassicSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpringClassicSpawner* pInstance);
        static void Clean(ObjSpringClassicSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStopWatchSpawner {
        float extendTime;
        float collisionRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStopWatchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStopWatchSpawner* pInstance);
        static void Clean(ObjStopWatchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct SwingReelImpulse {
        float addSpeed;
        float outOfControl;
        float motionTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SwingReelImpulse* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SwingReelImpulse* pInstance);
        static void Clean(SwingReelImpulse* pInstance);
    };
}

namespace heur::rfl {
    struct SwingReelPath {
        hh::game::ObjectId targetObj;
        csl::math::Vector3 targetOffset;
        float outStrength;
        float inStrength;
        float outUpPower;
        float inElev;
        float pathRoll;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SwingReelPath* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SwingReelPath* pInstance);
        static void Clean(SwingReelPath* pInstance);
    };
}

namespace heur::rfl {
    struct SwingReelVertical {
        float moveRange;
        float launchAngleSum;
        float period;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SwingReelVertical* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SwingReelVertical* pInstance);
        static void Clean(SwingReelVertical* pInstance);
    };
}

namespace heur::rfl {
    struct SwingReelHorizontal {
        enum class RotateDirection : int8_t {
            Left = 0,
            Right = 1,
        };

        RotateDirection rotateDirection;
        float ropeTiltMax;
        float ropeTiltTime;
        float launchAngleSum;
        float period;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SwingReelHorizontal* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SwingReelHorizontal* pInstance);
        static void Clean(SwingReelHorizontal* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSwingReelSpawner {
        enum class SwingReelType : int8_t {
            TypeVertical = 0,
            TypeHorizontal = 1,
        };

        SwingReelType type;
        float ropeLength;
        bool eventDriven;
        float handleDownTime;
        heur::rfl::SwingReelImpulse impulseParam;
        heur::rfl::SwingReelPath pathParam;
        heur::rfl::SwingReelVertical vertParam;
        heur::rfl::SwingReelHorizontal horzParam;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSwingReelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSwingReelSpawner* pInstance);
        static void Clean(ObjSwingReelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSwitchUsualSpawner {
        enum class Condition : int8_t {
            COND_ON_TRIGGER = 0,
            COND_TIMER = 1,
            COND_ON_STAY = 2,
        };

        Condition condition;
        float lifetime;
        bool usedRigidCol;
        bool eventDriven;
        bool isConstrain;
        heur::rfl::ActionNotification actions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSwitchUsualSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSwitchUsualSpawner* pInstance);
        static void Clean(ObjSwitchUsualSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeStartVolumeSpawner {
        enum class Condition : int8_t {
            COND_ON_TRIGGER = 0,
            COND_PULSE = 1,
            COND_TIMER_ONCE = 2,
            COND_TIMER = 3,
            COND_ON_STAY = 4,
        };

        Condition condition;
        float lifetime;
        bool eventDriven;
        heur::rfl::VolumeTriggerSpawner volume;
        heur::rfl::ActionNotification actions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeStartVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeStartVolumeSpawner* pInstance);
        static void Clean(ObjTimeStartVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeStopWatchVolumeSpawner {
        enum class Condition : int8_t {
            COND_ON_TRIGGER = 0,
            COND_PULSE = 1,
            COND_TIMER_ONCE = 2,
            COND_TIMER = 3,
            COND_ON_STAY = 4,
        };

        Condition condition;
        float lifetime;
        bool eventDriven;
        heur::rfl::VolumeTriggerSpawner volume;
        heur::rfl::ActionNotification actions[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeStopWatchVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeStopWatchVolumeSpawner* pInstance);
        static void Clean(ObjTimeStopWatchVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ShotParam {
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ShotParam* pInstance);
        static void Clean(ShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTrampolineSpawner {
        float autoJumpTime;
        heur::rfl::ShotParam lowShot;
        heur::rfl::ShotParam middleShot;
        heur::rfl::ShotParam highShot;
        float size;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTrampolineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTrampolineSpawner* pInstance);
        static void Clean(ObjTrampolineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTrapBallSpawner {
        enum class MoveType : int8_t {
            Straight = 0,
            Half = 1,
            Quater = 2,
            Num = 3,
        };

        enum class NumType : int8_t {
            Type_1 = 0,
            Type_2 = 1,
            Type_3 = 2,
            Num = 3,
        };

        enum class LauncherType : int8_t {
            Straight = 0,
            CurveLeft = 1,
            CurveRight = 2,
            Num = 3,
        };

        MoveType moveType;
        NumType numType;
        float distance;
        float distanceHalf;
        float velocity;
        float velocityOnAnim;
        float waitSec;
        bool isBack;
        LauncherType launcherTypeA;
        LauncherType launcherTypeB;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTrapBallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTrapBallSpawner* pInstance);
        static void Clean(ObjTrapBallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjUpDownPoleSpawner {
        int32_t barLengthNum;
        float speed;
        float moveHeight;
        float phase;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjUpDownPoleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjUpDownPoleSpawner* pInstance);
        static void Clean(ObjUpDownPoleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjUpDownPolePillarSpawner {
        enum class BaseType : int8_t {
            Grond = 0,
            Sky = 1,
        };

        int32_t pillarLengthNum;
        BaseType baseType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjUpDownPolePillarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjUpDownPolePillarSpawner* pInstance);
        static void Clean(ObjUpDownPolePillarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjUpReelSpawner {
        float length;
        float upSpeedMax;
        float firstSpeed;
        float outOfControl;
        bool isOneTimeUp;
        bool eventDriven;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjUpReelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjUpReelSpawner* pInstance);
        static void Clean(ObjUpReelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWallJumpBlockSpawner {
        float width;
        float height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWallJumpBlockSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWallJumpBlockSpawner* pInstance);
        static void Clean(ObjWallJumpBlockSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarpStoneSpawner {
        enum class Visual : int8_t {
            SV = 0,
            FV = 1,
            NumVisuals = 2,
        };

        Visual visual;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarpStoneSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarpStoneSpawner* pInstance);
        static void Clean(ObjWarpStoneSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarpStoneEndSpawner {
        enum class Visual : int8_t {
            SV = 0,
            FV = 1,
            NumVisuals = 2,
        };

        Visual visual;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarpStoneEndSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarpStoneEndSpawner* pInstance);
        static void Clean(ObjWarpStoneEndSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWoodBridgeSpawner {
        enum class ViewType : int8_t {
            FV = 0,
            SV = 1,
        };

        ViewType viewType;
        float flexValue;
        uint32_t logNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWoodBridgeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWoodBridgeSpawner* pInstance);
        static void Clean(ObjWoodBridgeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWoodBridgeBreakSpawner : heur::rfl::ObjWoodBridgeSpawner {
        float shakeWaitTime;
        float shakeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWoodBridgeBreakSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWoodBridgeBreakSpawner* pInstance);
        static void Clean(ObjWoodBridgeBreakSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWoodSwingSpawner {
        enum class SizeType : int8_t {
            SIZE_3m = 0,
            SIZE_4m = 1,
            SIZE_5m = 2,
            SIZE_7m = 3,
            NUM_SIZE_TYPE = 4,
        };

        enum class StartType : int8_t {
            CENTER = 0,
            LEFT = 1,
            RIGHT = 2,
        };

        float speed;
        float width;
        float waitTime;
        float phase;
        bool eventDriven;
        SizeType sizeType;
        bool display;
        StartType stAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWoodSwingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWoodSwingSpawner* pInstance);
        static void Clean(ObjWoodSwingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWoodTunnelSpawner {
        enum class Type : int8_t {
            SMALL = 0,
            LARGE = 1,
            NUM_TYPE = 2,
        };

        Type type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWoodTunnelSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWoodTunnelSpawner* pInstance);
        static void Clean(ObjWoodTunnelSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyPracticeNotifierConfig {
        bool usePracticeNotifier;
        int8_t practiceNo;
        int8_t tipsNo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyPracticeNotifierConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyPracticeNotifierConfig* pInstance);
        static void Clean(EnemyPracticeNotifierConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAquaballSpawner {
        int32_t no;
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool respawnableByMeteorShower;
        bool isSonicSet;
        csl::ut::VariableString movePathName;
        float captureLimitTimeOffset;
        float moveSpeedOffset;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAquaballSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAquaballSpawner* pInstance);
        static void Clean(EnemyAquaballSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBatabataSpawner {
        enum class ViewType : int8_t {
            FV = 0,
            SV = 1,
        };

        ViewType viewType;
        float velocity;
        float searchDistance;
        csl::math::Vector3 targetPos;
        bool isEventDriven;
        bool isRespawn;
        bool isHomingAttack;
        float respawnTime;
        float waitTime;
        float moveHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBatabataSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBatabataSpawner* pInstance);
        static void Clean(EnemyBatabataSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct BeetonMoveParam {
        enum class BeetonMoveType : int8_t {
            FIXED = 0,
            TWO_POINT = 1,
            PATH = 2,
        };

        BeetonMoveType moveType;
        csl::math::Vector3 destOffset;
        csl::ut::VariableString pathName;
        float moveSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BeetonMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BeetonMoveParam* pInstance);
        static void Clean(BeetonMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct BeetonAttackParam {
        bool isAttack;
        float bulletSpeed;
        float prepareTime;
        float searchDistance;
        float searchAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BeetonAttackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BeetonAttackParam* pInstance);
        static void Clean(BeetonAttackParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBeetonSpawner {
        bool isFV;
        bool doesRespawn;
        float respawnTime;
        heur::rfl::BeetonMoveParam moveParam;
        heur::rfl::BeetonAttackParam attackParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBeetonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBeetonSpawner* pInstance);
        static void Clean(EnemyBeetonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBirdSpawner {
        int32_t no;
        uint32_t level;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool respawnableByMeteorShower;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBirdSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBirdSpawner* pInstance);
        static void Clean(EnemyBirdSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBirdLaserSpawner {
        int8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBirdLaserSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBirdLaserSpawner* pInstance);
        static void Clean(ObjBirdLaserSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct SonicSetParam {
        bool isSonicSet;
        float searchRadiusOffset;
        float attackMoveSpeedOffset;
        float chaseMoveSpeedOffset;
        float moveDistanceFront;
        float moveDistanceBack;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SonicSetParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SonicSetParam* pInstance);
        static void Clean(SonicSetParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBommerSpawner {
        int32_t no;
        int32_t level;
        hh::game::ObjectId territoryId;
        bool respawnableByMeteorShower;
        bool appearEffectEnabled;
        heur::rfl::SonicSetParam sonicSetParam;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBommerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBommerSpawner* pInstance);
        static void Clean(EnemyBommerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleSpawner {
        int32_t no;
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool isSonicSet;
        float eyesightDistance;
        bool respawnableByMeteorShower;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleSpawner* pInstance);
        static void Clean(EnemyBubbleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyDefenderSpawner {
        int32_t no;
        int32_t level;
        hh::game::ObjectId territoryId;
        bool isSonicSet;
        float guardDistance;
        float boomerangDistance;
        bool respawnableByMeteorShower;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool isTrial;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyDefenderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyDefenderSpawner* pInstance);
        static void Clean(EnemyDefenderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EggRoboAppearParam {
        enum class AppearType : int8_t {
            Fix = 0,
            Path = 1,
            TwoPoint = 2,
        };

        enum class EasingType : uint8_t {
            LINEAR_EASEIN = 0,
            LINEAR_EASEOUT = 1,
            LINEAR_EASEINOUT = 2,
            QUADRATIC_EASEIN = 3,
            QUADRATIC_EASEOUT = 4,
            QUADRATIC_EASEINOUT = 5,
            CUBIC_EASEIN = 6,
            CUBIC_EASEOUT = 7,
            CUBIC_EASEINOUT = 8,
            QUARTIC_EASEIN = 9,
            QUARTIC_EASEOUT = 10,
            QUARTIC_EASEINOUT = 11,
            QUINTIC_EASEIN = 12,
            QUINTIC_EASEOUT = 13,
            QUINTIC_EASEINOUT = 14,
            SINE_EASEIN = 15,
            SINE_EASEOUT = 16,
            SINE_EASEINOUT = 17,
            EXPONENTAL_EASEIN = 18,
            EXPONENTAL_EASEOUT = 19,
            EXPONENTAL_EASEINOUT = 20,
            CIRCULAR_EASEIN = 21,
            CIRCULAR_EASEOUT = 22,
            CIRCULAR_EASEINOUT = 23,
            BACK_EASEIN = 24,
            BACK_EASEOUT = 25,
            BACK_EASEINOUT = 26,
            BOUNCE_EASEIN = 27,
            BOUNCE_EASEOUT = 28,
            BOUNCE_EASEINOUT = 29,
            ELASITC_EASEIN = 30,
            ELASITC_EASEOUT = 31,
            ELASITC_EASEINOUT = 32,
            NUM_EASINGTYPES = 33,
        };

        AppearType appearType;
        bool eventDriven;
        csl::ut::VariableString pathName;
        csl::math::Vector3 offsetTwoPoint;
        float time;
        EasingType easingTypePath;
        bool isLand;
        bool isAppearEff;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EggRoboAppearParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EggRoboAppearParam* pInstance);
        static void Clean(EggRoboAppearParam* pInstance);
    };
}

namespace heur::rfl {
    struct EggRoboSearchParam {
        enum class MoveType : int8_t {
            Fixed = 0,
            Offset = 1,
        };

        enum class EasingType : uint8_t {
            LINEAR_EASEIN = 0,
            LINEAR_EASEOUT = 1,
            LINEAR_EASEINOUT = 2,
            QUADRATIC_EASEIN = 3,
            QUADRATIC_EASEOUT = 4,
            QUADRATIC_EASEINOUT = 5,
            CUBIC_EASEIN = 6,
            CUBIC_EASEOUT = 7,
            CUBIC_EASEINOUT = 8,
            QUARTIC_EASEIN = 9,
            QUARTIC_EASEOUT = 10,
            QUARTIC_EASEINOUT = 11,
            QUINTIC_EASEIN = 12,
            QUINTIC_EASEOUT = 13,
            QUINTIC_EASEINOUT = 14,
            SINE_EASEIN = 15,
            SINE_EASEOUT = 16,
            SINE_EASEINOUT = 17,
            EXPONENTAL_EASEIN = 18,
            EXPONENTAL_EASEOUT = 19,
            EXPONENTAL_EASEINOUT = 20,
            CIRCULAR_EASEIN = 21,
            CIRCULAR_EASEOUT = 22,
            CIRCULAR_EASEINOUT = 23,
            BACK_EASEIN = 24,
            BACK_EASEOUT = 25,
            BACK_EASEINOUT = 26,
            BOUNCE_EASEIN = 27,
            BOUNCE_EASEOUT = 28,
            BOUNCE_EASEINOUT = 29,
            ELASITC_EASEIN = 30,
            ELASITC_EASEOUT = 31,
            ELASITC_EASEINOUT = 32,
            NUM_EASINGTYPES = 33,
        };

        MoveType moveType;
        csl::math::Vector3 moveOffset;
        float speed;
        float searchDistance;
        float searchAngle;
        bool isTakeOffLandAfterFound;
        csl::math::Vector3 landOffset;
        float landTime;
        EasingType landEasingType;
        csl::math::Vector3 eyesightOffsetDirection;
        csl::math::Vector3 eyesightRotateAxis;
        float eyesightRotateAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EggRoboSearchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EggRoboSearchParam* pInstance);
        static void Clean(EggRoboSearchParam* pInstance);
    };
}

namespace heur::rfl {
    struct EggRoboAttackLaserParam {
        float colliderDistance;
        float colliderThickness;
        float colliderAngle;
        float speed;
        float lifeTime;
        float chargeTime;
        uint32_t countContinuous;
        float intervalContinuous;
        float coolTime;
        float shotArcAngleFv;
        uint32_t shotArcBulletCountFv;
        bool isGraviry;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EggRoboAttackLaserParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EggRoboAttackLaserParam* pInstance);
        static void Clean(EggRoboAttackLaserParam* pInstance);
    };
}

namespace heur::rfl {
    struct EggRoboAttackMissileParam {
        float colliderDistance;
        float colliderAngle;
        float speed;
        float lifeTime;
        float explodeTime;
        float trackRate;
        float traceStartTime;
        float chargeTime;
        float coolTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EggRoboAttackMissileParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EggRoboAttackMissileParam* pInstance);
        static void Clean(EggRoboAttackMissileParam* pInstance);
    };
}

namespace heur::rfl {
    struct EggRoboAttackParam {
        enum class WeaponType : int8_t {
            Laser = 0,
            Missile = 1,
            Num = 2,
        };

        WeaponType weaponType;
        bool isLookTarget;
        float trackAngleSpeed;
        float targetLostTime;
        heur::rfl::EggRoboAttackLaserParam laserParam;
        heur::rfl::EggRoboAttackMissileParam missileParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EggRoboAttackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EggRoboAttackParam* pInstance);
        static void Clean(EggRoboAttackParam* pInstance);
    };
}

namespace heur::rfl {
    struct EggRoboReviveParam {
        enum class ReviveType : int8_t {
            None = 0,
            DeadPoint = 1,
            ArgumentPoint = 2,
            SameAppear = 3,
        };

        ReviveType reviveType;
        float time;
        hh::game::ObjectId locatorId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EggRoboReviveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EggRoboReviveParam* pInstance);
        static void Clean(EggRoboReviveParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyEggRoboSpawner {
        enum class ViewType : int8_t {
            SV = 0,
            FV = 1,
            Num = 2,
        };

        ViewType viewType;
        heur::rfl::EggRoboAppearParam appearParam;
        heur::rfl::EggRoboSearchParam searchParam;
        heur::rfl::EggRoboAttackParam attackParam;
        heur::rfl::EggRoboReviveParam reviveParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyEggRoboSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyEggRoboSpawner* pInstance);
        static void Clean(EnemyEggRoboSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyGaniganiTwoPoints {
        csl::math::Vector3 pos;
        float startPosRatio;
        float moveSpeed;
        float stopTime;
        float approachDist;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyGaniganiTwoPoints* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyGaniganiTwoPoints* pInstance);
        static void Clean(EnemyGaniganiTwoPoints* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyGaniganiFixed {
        float searchInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyGaniganiFixed* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyGaniganiFixed* pInstance);
        static void Clean(EnemyGaniganiFixed* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyGaniganiShot {
        float searchRadius;
        float searchAngle;
        float searchHeight;
        float searchOffset;
        float chargeTime;
        float interval;
        float distance;
        float height;
        float speed;
        float expRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyGaniganiShot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyGaniganiShot* pInstance);
        static void Clean(EnemyGaniganiShot* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyGaniganiSpawner {
        enum class MoveType : uint8_t {
            TypeFixed = 0,
            TypeTwoPoints = 1,
        };

        bool isFV;
        bool isFindMotion;
        MoveType moveType;
        heur::rfl::EnemyGaniganiTwoPoints twoPt;
        heur::rfl::EnemyGaniganiFixed fixed;
        heur::rfl::EnemyGaniganiShot shot;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyGaniganiSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyGaniganiSpawner* pInstance);
        static void Clean(EnemyGaniganiSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct SVParam {
        float descentDistance;
        float descentSpeed;
        float ascentSpeed;
        float flickerSpeedOnAscent;
        float flickerSpeedAfterAscent;
        float selfDestructTime;
        float reqLStickInputTimeToBreakFree;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SVParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SVParam* pInstance);
        static void Clean(SVParam* pInstance);
    };
}

namespace heur::rfl {
    struct FVParam {
        float hipsRotDegPerSec;
        float bulletVelocityY;
        float bulletVelocityMultiplier;
        float chargeTime;
        float bulletFlightTime;
        float attackInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FVParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FVParam* pInstance);
        static void Clean(FVParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyGrabberSpawner {
        enum class Placement : uint8_t {
            SV = 0,
            FV_ON_GROUND = 1,
            FV_IN_AIR = 2,
            FV_ON_RAIL = 3,
            NUM_PLACEMENTS = 4,
        };

        enum class Movement : uint8_t {
            FIXED = 0,
            TWO_POINT = 1,
            NUM_MOVEMENTS = 2,
        };

        Placement placement;
        Movement movement;
        csl::math::Vector3 dst;
        bool eventDriven;
        bool doesRespawn;
        float threadStartingYOffset;
        float respawnTime;
        float movementSpeed;
        float rotDegPerSec;
        float searchDistance;
        float searchAngle;
        heur::rfl::SVParam svParam;
        heur::rfl::FVParam fvParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyGrabberSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyGrabberSpawner* pInstance);
        static void Clean(EnemyGrabberSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct HeliTwoPoint {
        csl::math::Vector3 localDest;
        float speed;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliTwoPoint* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliTwoPoint* pInstance);
        static void Clean(HeliTwoPoint* pInstance);
    };
}

namespace heur::rfl {
    struct HeliOnPath {
        enum class MOVE_PARAM : uint8_t {
            FOLLOW_PLAYER = 0,
            ONE_WAY = 1,
            TWO_WAY = 2,
        };

        csl::ut::VariableString pathName;
        MOVE_PARAM moveDir;
        float speed;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliOnPath* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliOnPath* pInstance);
        static void Clean(HeliOnPath* pInstance);
    };
}

namespace heur::rfl {
    struct HeliEyeSight {
        float distance;
        float angle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliEyeSight* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliEyeSight* pInstance);
        static void Clean(HeliEyeSight* pInstance);
    };
}

namespace heur::rfl {
    struct HeliAppearance {
        csl::math::Vector3 appearPosLocal;
        float speed;
        bool useSwitch;
        bool revive;
        float retireTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliAppearance* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliAppearance* pInstance);
        static void Clean(HeliAppearance* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyHelicopterSpawner {
        enum class MOVE_TYPE : uint8_t {
            FIXED = 0,
            TWO_POINT = 1,
            ON_PATH = 2,
        };

        MOVE_TYPE moveType;
        heur::rfl::HeliTwoPoint twoPointParam;
        heur::rfl::HeliOnPath onPathParam;
        heur::rfl::HeliEyeSight eyesightParam;
        heur::rfl::HeliAppearance appearParam;
        bool isAttackChain;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyHelicopterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyHelicopterSpawner* pInstance);
        static void Clean(EnemyHelicopterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJellymanSpawner {
        enum class Mode : int8_t {
            Human = 0,
            Wolf = 1,
            Bird = 2,
        };

        int32_t no;
        int32_t level;
        float distance;
        float tolerance;
        Mode mode;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool disableChangeMode;
        bool enableEffect;
        bool isEgg;
        bool respawnableByMeteorShower;
        float searchDistanceOffset;
        bool isSonicSet;
        float actionRate[5];
        float actionCoolTime[5];
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool eventDriven;
        bool onlyHeightField;
        bool noWaveAttack;
        bool isTrial;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJellymanSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJellymanSpawner* pInstance);
        static void Clean(EnemyJellymanSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperSpawner {
        int32_t no;
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        csl::ut::MoveArray<hh::game::ObjectId> subs;
        csl::ut::MoveArray<hh::game::ObjectId> onTarget;
        float subsLifeTime;
        bool isSonicSet;
        float eyesightDistance;
        bool respawnableByMeteorShower;
        bool onlyHeightField;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperSpawner* pInstance);
        static void Clean(EnemyJumperSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperSubSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool main;
        bool air;
        csl::math::Vector3 shotDirection;
        float firstSpeed;
        float outOfControl;
        float keepVelocityDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperSubSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperSubSpawner* pInstance);
        static void Clean(EnemyJumperSubSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyLanderTwoPoints {
        csl::math::Vector3 pos;
        float startPosRatio;
        float moveSpeed;
        float stopTime;
        float escapeDist;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyLanderTwoPoints* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyLanderTwoPoints* pInstance);
        static void Clean(EnemyLanderTwoPoints* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyLanderShot {
        enum class ShotType : uint8_t {
            Ground = 0,
            Wall = 1,
            Ceiling = 2,
        };

        enum class SearchType : uint8_t {
            SV = 0,
            FV = 1,
        };

        enum class ShotNum : uint8_t {
            One = 1,
            Three = 3,
            Five = 5,
        };

        ShotType shotType;
        SearchType searchType;
        float searchRadius;
        float searchAngleAdd;
        float interval;
        ShotNum shotNum;
        float range;
        float distance;
        float height;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyLanderShot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyLanderShot* pInstance);
        static void Clean(EnemyLanderShot* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyLanderSpawner {
        enum class MoveType : uint8_t {
            Fixed = 0,
            TwoPoints = 1,
        };

        MoveType moveType;
        heur::rfl::EnemyLanderTwoPoints twoPt;
        heur::rfl::EnemyLanderShot shot;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyLanderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyLanderSpawner* pInstance);
        static void Clean(EnemyLanderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyMotoraSpawner {
        enum class Placement : uint8_t {
            WhereItsSet = 0,
            InAir = 1,
            NumPlacements = 2,
        };

        enum class Movement : uint8_t {
            Immobile = 0,
            TwoPoint = 1,
            NumMovements = 2,
        };

        Placement placement;
        Movement movement;
        csl::math::Vector3 destination;
        float movementSpeed;
        float rushSpeed;
        float knockbackSpeed;
        float tireRotAnglePerSecWhenMoving;
        float tireRotAnglePerSecWhenChargingup;
        float tireRotAnglePerSecWhenRushing;
        float searchDistance;
        float searchAngle;
        float respawnTime;
        float chargeupTime;
        float timeTilLoseSight;
        float heightToRecognizeAsCliff;
        float distanceToRecognizeObstable;
        float degreeToRotatePerSec;
        bool eventDriven;
        bool doesRespawn;
        bool doesAttack;
        bool useFindMotion;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyMotoraSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyMotoraSpawner* pInstance);
        static void Clean(EnemyMotoraSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyRobberMovePaths {
        csl::ut::VariableString path1;
        csl::ut::VariableString path2;
        csl::ut::VariableString path3;
        csl::ut::VariableString path4;
        csl::ut::VariableString path5;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyRobberMovePaths* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyRobberMovePaths* pInstance);
        static void Clean(EnemyRobberMovePaths* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyRobberSpawner {
        int32_t no;
        int32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        hh::game::ObjectId emeraldDropObjID;
        heur::rfl::EnemyRobberMovePaths movePaths;
        float searchDistanceOffset;
        bool respawnableByMeteorShower;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyRobberSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyRobberSpawner* pInstance);
        static void Clean(EnemyRobberSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemySniperSpawner {
        int32_t no;
        int32_t level;
        float distance;
        float tolerance;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        float searchDistanceOffset;
        float battleDistanceOffset;
        bool isParrySlowDisabled;
        bool isSonicSet;
        bool respawnableByMeteorShower;
        int32_t sonicSetHpOffset;
        int32_t sonicSetGpOffset;
        float sonicSetShotSpeedOffset;
        float sonicSetHideCoreDist;
        float sonicSetShowCoreDist;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemySniperSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemySniperSpawner* pInstance);
        static void Clean(EnemySniperSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct TankSpawnerAppearance {
        bool respawn;
        float respawnTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TankSpawnerAppearance* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TankSpawnerAppearance* pInstance);
        static void Clean(TankSpawnerAppearance* pInstance);
    };
}

namespace heur::rfl {
    struct TankSpawnerMainGun {
        float interval;
        bool noBlast;
        csl::math::Vector3 pos;
        float radius;
        float delay;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TankSpawnerMainGun* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TankSpawnerMainGun* pInstance);
        static void Clean(TankSpawnerMainGun* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyTankSpawner {
        bool attackBySwitch;
        heur::rfl::TankSpawnerAppearance appearance;
        heur::rfl::TankSpawnerMainGun mainGun;
        uint8_t hp;
        heur::rfl::ActionNotification actions[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyTankSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyTankSpawner* pInstance);
        static void Clean(EnemyTankSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyTutorialSpawner {
        enum class HealthType : int8_t {
            One = 0,
            Infinity = 1,
        };

        enum class ForceFocusType : int8_t {
            NoneFocus = 0,
            CameraFocus = 1,
            TargetFocus = 2,
        };

        enum class ShotDirectionType : int8_t {
            Aim = 0,
            AimHorz = 1,
            Front = 2,
            Random = 3,
        };

        HealthType health;
        bool targetable;
        bool defeatable;
        bool attackable;
        bool parryEnabled;
        bool recoverySmashEnabled;
        bool lifeGaugeVisibled;
        ForceFocusType forceFocus;
        float attackWaitTime;
        float attackSpanTime;
        float attackSleepTime;
        ShotDirectionType shotDirection;
        float shotSpeed;
        float shotSize;
        float respawnWaitTime;
        float respawnMoveDisatnce;
        float respawnMoveTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyTutorialSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyTutorialSpawner* pInstance);
        static void Clean(EnemyTutorialSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyTwisterSpawner {
        enum class MoveType : int8_t {
            Fix = 0,
            Path = 1,
            TwoPoint = 2,
        };

        enum class RotateType : int8_t {
            ChangeByTime = 0,
            OnlyNormal = 1,
            OnlyHighSpeed = 2,
        };

        int32_t no;
        int32_t level;
        MoveType moveType;
        csl::ut::VariableString pathName;
        csl::math::Vector3 twoPointOffset;
        float offsetPhase;
        float moveSpeed;
        RotateType rotateType;
        float changeTime;
        bool respawnableByMeteorShower;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool rigidbody;
        bool isQuest;
        bool isSonicSet;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyTwisterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyTwisterSpawner* pInstance);
        static void Clean(EnemyTwisterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ParachuteLineConfig {
        uint32_t objType[8];
        csl::math::Vector3 offSet;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ParachuteLineConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ParachuteLineConfig* pInstance);
        static void Clean(ParachuteLineConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ParachuteShotConfig {
        int32_t steps;
        int32_t lineNum;
        float distance;
        float range;
        bool isOrder;
        heur::rfl::ParachuteLineConfig lineLists[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ParachuteShotConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ParachuteShotConfig* pInstance);
        static void Clean(ParachuteShotConfig* pInstance);
    };
}

namespace heur::rfl {
    struct SonicSetConfig {
        bool isSonicSet;
        float jumpHeight;
        float closeDistance;
        float shotDistance;
        float blowoffSpeed;
        csl::math::Vector3 blowoffOffSet;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SonicSetConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SonicSetConfig* pInstance);
        static void Clean(SonicSetConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyUmbrellaSpawner {
        int32_t no;
        int32_t level;
        float distance;
        float tolerance;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        heur::rfl::ParachuteShotConfig parachute;
        bool respawnableByMeteorShower;
        heur::rfl::SonicSetConfig sonicset;
        bool onlyHeightField;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyUmbrellaSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyUmbrellaSpawner* pInstance);
        static void Clean(EnemyUmbrellaSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyWolfSpawner {
        int32_t no;
        uint32_t level;
        float distance;
        float tolerance;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        float searchDistanceOffset;
        hh::game::ObjectId managerId;
        bool respawnableByMeteorShower;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool isTrial;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyWolfSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyWolfSpawner* pInstance);
        static void Clean(EnemyWolfSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWolfManagerSpawner {
        float effectHeightOffset;
        bool isTrial;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWolfManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWolfManagerSpawner* pInstance);
        static void Clean(ObjWolfManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct SpawnParam {
        enum class ModeType : int8_t {
            MODE_NONE = 0,
            MODE_MAN = 1,
            MODE_WOLF = 2,
            MODE_BIRD = 3,
            MODE_RANDOM = 4,
        };

        ModeType mode;
        int32_t num;
        int32_t level;
        int32_t randLevel;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SpawnParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SpawnParam* pInstance);
        static void Clean(SpawnParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTerritorySpawner {
        enum class Shape : int8_t {
            SHAPE_CYLINDER = 0,
            SHAPE_BOX = 1,
        };

        enum class BasePoint : int8_t {
            BASE_CENTER = 0,
            BASE_Y_PLANE = 1,
            BASE_X_PLANE = 2,
            BASE_Z_PLANE = 3,
        };

        Shape shape;
        BasePoint basePoint;
        csl::ut::VariableString pathName;
        csl::math::Vector3 patrolSize;
        csl::math::Vector3 fightSize;
        csl::math::Vector3 patrolOffset;
        csl::math::Vector3 fightOffset;
        bool isFallReturnArea;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTerritorySpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTerritorySpawner* pInstance);
        static void Clean(ObjTerritorySpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EnemySpawnerSpawner {
        enum class SpawnPattern : int8_t {
            Random = 0,
            Line = 1,
            Circle = 2,
            Path = 3,
        };

        enum class AreaShape : int8_t {
            Cylinder = 0,
            Box = 1,
        };

        enum class RotateType : int8_t {
            ROTATE_RANDOM = 0,
            ROTATE_FRONT = 1,
        };

        enum class BasePoint : int8_t {
            BASE_CENTER = 0,
            BASE_Y_PLANE = 1,
            BASE_X_PLANE = 2,
            BASE_Z_PLANE = 3,
        };

        heur::rfl::SpawnParam spawnParam[4];
        bool eventDriven;
        bool saveEventDriven;
        bool enableEffect;
        bool isEgg;
        float searchDistanceOffset;
        SpawnPattern pattern;
        AreaShape shape;
        csl::math::Vector3 size;
        RotateType rotateType;
        BasePoint basePoint;
        bool onGround;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool disableChangeMode;
        bool useTerritory;
        bool isDeadRangeOut;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemySpawnerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemySpawnerSpawner* pInstance);
        static void Clean(EnemySpawnerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldSetupParameter {
        int8_t prio;
        bool defaultON;
        bool fixed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldSetupParameter* pInstance);
        static void Clean(GravityFieldSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldConcaveBoxSetupParameter : heur::rfl::GravityFieldSetupParameter {
        float x;
        float y;
        float z;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldConcaveBoxSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldConcaveBoxSetupParameter* pInstance);
        static void Clean(GravityFieldConcaveBoxSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldConcaveBoxSpawner : heur::rfl::GravityFieldConcaveBoxSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldConcaveBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldConcaveBoxSpawner* pInstance);
        static void Clean(ObjGFieldConcaveBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldConstantSetupParameter : heur::rfl::GravityFieldSetupParameter {
        float x;
        float y;
        float z;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldConstantSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldConstantSetupParameter* pInstance);
        static void Clean(GravityFieldConstantSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldConstantSpawner : heur::rfl::GravityFieldConstantSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldConstantSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldConstantSpawner* pInstance);
        static void Clean(ObjGFieldConstantSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldCylinderSplineSetupParameter : heur::rfl::GravityFieldSetupParameter {
        float radius;
        csl::ut::VariableString pathName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldCylinderSplineSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldCylinderSplineSetupParameter* pInstance);
        static void Clean(GravityFieldCylinderSplineSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldFaceSplineSetupParameter : heur::rfl::GravityFieldCylinderSplineSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldFaceSplineSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldFaceSplineSetupParameter* pInstance);
        static void Clean(GravityFieldFaceSplineSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldFaceSplineSpawner : heur::rfl::GravityFieldFaceSplineSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldFaceSplineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldFaceSplineSpawner* pInstance);
        static void Clean(ObjGFieldFaceSplineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldHemisphereSetupParameter : heur::rfl::GravityFieldSetupParameter {
        enum class Type : int8_t {
            TYPE_OUTER = 0,
            TYPE_INNER = 1,
        };

        float radius;
        float innerRadius;
        Type type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldHemisphereSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldHemisphereSetupParameter* pInstance);
        static void Clean(GravityFieldHemisphereSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldHemisphereSpawner : heur::rfl::GravityFieldHemisphereSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldHemisphereSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldHemisphereSpawner* pInstance);
        static void Clean(ObjGFieldHemisphereSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldInsideCylinderSplineSetupParameter : heur::rfl::GravityFieldCylinderSplineSetupParameter {
        float innerRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldInsideCylinderSplineSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldInsideCylinderSplineSetupParameter* pInstance);
        static void Clean(GravityFieldInsideCylinderSplineSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldInsideCylinderSplineSpawner : heur::rfl::GravityFieldInsideCylinderSplineSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldInsideCylinderSplineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldInsideCylinderSplineSpawner* pInstance);
        static void Clean(ObjGFieldInsideCylinderSplineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldInsidePrismSplineSetupParameter : heur::rfl::GravityFieldCylinderSplineSetupParameter {
        float innerRadius;
        int8_t divide;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldInsidePrismSplineSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldInsidePrismSplineSetupParameter* pInstance);
        static void Clean(GravityFieldInsidePrismSplineSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldInsidePrismSplineSpawner : heur::rfl::GravityFieldInsidePrismSplineSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldInsidePrismSplineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldInsidePrismSplineSpawner* pInstance);
        static void Clean(ObjGFieldInsidePrismSplineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldOutsideCylinderSplineSetupParameter : heur::rfl::GravityFieldCylinderSplineSetupParameter {
        float innerRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldOutsideCylinderSplineSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldOutsideCylinderSplineSetupParameter* pInstance);
        static void Clean(GravityFieldOutsideCylinderSplineSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldOutsideCylinderSplineSpawner : heur::rfl::GravityFieldOutsideCylinderSplineSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldOutsideCylinderSplineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldOutsideCylinderSplineSpawner* pInstance);
        static void Clean(ObjGFieldOutsideCylinderSplineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldOutsidePrismSplineSetupParameter : heur::rfl::GravityFieldCylinderSplineSetupParameter {
        float innerRadius;
        int8_t divide;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldOutsidePrismSplineSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldOutsidePrismSplineSetupParameter* pInstance);
        static void Clean(GravityFieldOutsidePrismSplineSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldOutsidePrismSplineSpawner : heur::rfl::GravityFieldOutsidePrismSplineSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldOutsidePrismSplineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldOutsidePrismSplineSpawner* pInstance);
        static void Clean(ObjGFieldOutsidePrismSplineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldSphereSetupParameter : heur::rfl::GravityFieldSetupParameter {
        float radius;
        float innerRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldSphereSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldSphereSetupParameter* pInstance);
        static void Clean(GravityFieldSphereSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldSphereSpawner : heur::rfl::GravityFieldSphereSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldSphereSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldSphereSpawner* pInstance);
        static void Clean(ObjGFieldSphereSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GravityFieldSvSplineSetupParameter : heur::rfl::GravityFieldSetupParameter {
        csl::ut::VariableString pathName;
        float x;
        float y;
        float z;
        float tolerance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GravityFieldSvSplineSetupParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GravityFieldSvSplineSetupParameter* pInstance);
        static void Clean(GravityFieldSvSplineSetupParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldSvSplineSpawner : heur::rfl::GravityFieldSvSplineSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldSvSplineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldSvSplineSpawner* pInstance);
        static void Clean(ObjGFieldSvSplineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHoleCommonSpawner {
        enum class InitialState : uint8_t {
            Close = 0,
            OpenSmall = 1,
            Open = 2,
        };

        int32_t no;
        InitialState initialState;
        InitialState afterState;
        bool wall;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHoleCommonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHoleCommonSpawner* pInstance);
        static void Clean(ObjHoleCommonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHoleAuraTrainSpawner : heur::rfl::ObjHoleCommonSpawner {
        csl::ut::VariableString pathName;
        bool reverse;
        hh::game::ObjectId cameraUuid;
        float cameraEaseInTime;
        float cameraEaseOutTime;
        float speed;
        hh::game::ObjectId exitHole;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHoleAuraTrainSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHoleAuraTrainSpawner* pInstance);
        static void Clean(ObjHoleAuraTrainSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHoleHideSpawner : heur::rfl::ObjHoleCommonSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHoleHideSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHoleHideSpawner* pInstance);
        static void Clean(ObjHoleHideSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHolePopupItemSpawner : heur::rfl::ObjHoleCommonSpawner {
        enum class ItemKind : uint32_t {
            Ring = 0,
            SuperRing = 1,
            SkillPiece = 2,
        };

        ItemKind item;
        uint32_t num;
        uint32_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHolePopupItemSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHolePopupItemSpawner* pInstance);
        static void Clean(ObjHolePopupItemSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHoleWarpSpawner : heur::rfl::ObjHoleCommonSpawner {
        enum class Interpolate : int8_t {
            Linear = 0,
            LinearAbsolute = 1,
            LinearAbsoluteStable = 2,
            TargetBase = 3,
            TargetBaseStable = 4,
            FixTarget = 5,
        };

        hh::game::ObjectId exitHole;
        hh::game::ObjectId camera;
        float easeInTime;
        Interpolate interpolateIn;
        float easeOutTime;
        Interpolate interpolateOut;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHoleWarpSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHoleWarpSpawner* pInstance);
        static void Clean(ObjHoleWarpSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnucklesPillarSpawner {
        enum class SizeType : int8_t {
            SMALL = 0,
            MIDDLE = 1,
            LARGE = 2,
            SIZETYPE_NUM = 3,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        enum class EventType : int8_t {
            EVENT_NONE = 0,
            EVENT_HIDE = 1,
            EVENT_NO_MOVE = 2,
        };

        int32_t no;
        SizeType size;
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        EventType eventDriven;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        bool isPressDead;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnucklesPillarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnucklesPillarSpawner* pInstance);
        static void Clean(ObjKnucklesPillarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnucklesWallSpawner {
        enum class SizeType : int8_t {
            SMALL = 0,
            MIDDLE = 1,
            LARGE = 2,
            SIZETYPE_NUM = 3,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_POINT = 1,
            MOVE_PATH = 2,
        };

        enum class PatrolType : int8_t {
            PATROL_RETURN = 0,
            PATROL_LOOP = 1,
            PATROL_ONEWAY = 2,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        enum class EventType : int8_t {
            EVENT_NONE = 0,
            EVENT_HIDE = 1,
            EVENT_NO_MOVE = 2,
        };

        int32_t no;
        SizeType size;
        MoveType moveType;
        PatrolType patrolType;
        TimeType timeType;
        EventType eventDriven;
        bool isSyncRot;
        bool isSmoothMove;
        bool isReverse;
        bool isPressDead;
        csl::math::Vector3 moveVector;
        csl::ut::VariableString pathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float waitTime;
        float phase;
        float speed;
        bool useConvex;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnucklesWallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnucklesWallSpawner* pInstance);
        static void Clean(ObjKnucklesWallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDashCircleBulletSpawner {
        enum class DirectionType : int8_t {
            Front = 0,
            Back = 1,
        };

        float moveSpeed;
        DirectionType dirType;
        float ocTime;
        float dashSpeed;
        float lifeTime;
        float offsetAngle;
        float scale;
        bool groundCheck;
        bool groundNormal;
        bool specifiiedLanding;
        float specifiiedLandingOffsetHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDashCircleBulletSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDashCircleBulletSpawner* pInstance);
        static void Clean(ObjDashCircleBulletSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        csl::ut::MoveArray<hh::game::ObjectId> deadPoints;
        bool isWaitSpawn;
        bool isTutorial;
        bool useTerritory;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        csl::ut::MoveArray<hh::game::ObjectId> portalBitsLegL;
        csl::ut::MoveArray<hh::game::ObjectId> portalBitsLegR;
        float searchDistanceOffset;
        int32_t no;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraSpawner* pInstance);
        static void Clean(MiniBossAshuraSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool isWaitSpawn;
        bool isTutorial;
        bool useNonBattleRange;
        bool respawnableByMeteorShower;
        float nonBattleRange;
        bool useTerritory;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        int32_t no;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool enableAttackOutsideArea;
        bool enable3rdParameter;
        bool enableHightSpeedMoveing;
        float speedUpScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeSpawner* pInstance);
        static void Clean(MiniBossBladeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct TimerTrigger {
        int32_t bootNum;
        float delayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TimerTrigger* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TimerTrigger* pInstance);
        static void Clean(TimerTrigger* pInstance);
    };
}

namespace heur::rfl {
    struct AttachSpringParam {
        float outOfControl;
        float firstSpeed;
        float keepVelocityDistance;
        csl::math::Vector3 direction;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AttachSpringParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AttachSpringParam* pInstance);
        static void Clean(AttachSpringParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGAttachmentSpawner {
        enum class AttachmentType : int8_t {
            Normal = 0,
            HA = 1,
            Spring = 2,
        };

        heur::rfl::TimerTrigger trigger;
        AttachmentType type;
        csl::math::Vector3 moveOffset;
        float moveTime;
        float targetCursorMaxDistance;
        heur::rfl::AttachSpringParam springParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGAttachmentSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGAttachmentSpawner* pInstance);
        static void Clean(ObjCGGAttachmentSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGBaseSpawner {
        csl::ut::MoveArray<hh::game::ObjectId> children;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGBaseSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGBaseSpawner* pInstance);
        static void Clean(ObjCGGBaseSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGBulletNormalGeneratorSpawner {
        heur::rfl::TimerTrigger trigger;
        float distance;
        int32_t bulletCount;
        float regenerateTime;
        int32_t regenerateCount;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGBulletNormalGeneratorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGBulletNormalGeneratorSpawner* pInstance);
        static void Clean(ObjCGGBulletNormalGeneratorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGLaserSpawner {
        enum class MoveType : int8_t {
            Fixed = 0,
            Rotate = 1,
        };

        heur::rfl::TimerTrigger trigger;
        int32_t count;
        float offset;
        float length;
        MoveType moveType;
        float rotateTime;
        bool isClockWise;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGLaserSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGLaserSpawner* pInstance);
        static void Clean(ObjCGGLaserSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGNodeTiltAxisSpawner {
        heur::rfl::ObjCGGBaseSpawner base;
        float angle;
        float speed;
        bool isClockWise;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGNodeTiltAxisSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGNodeTiltAxisSpawner* pInstance);
        static void Clean(ObjCGGNodeTiltAxisSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGRailSpawner {
        heur::rfl::PathCircleParameter setParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGRailSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGRailSpawner* pInstance);
        static void Clean(ObjCGGRailSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGResetBindSpawner {
        heur::rfl::TimerTrigger trigger;
        csl::ut::MoveArray<hh::game::ObjectId> nextObjects;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGResetBindSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGResetBindSpawner* pInstance);
        static void Clean(ObjCGGResetBindSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGRootTimerParam {
        float unitTime;
        float decPoint;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGRootTimerParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGRootTimerParam* pInstance);
        static void Clean(ObjCGGRootTimerParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGRootSpawner {
        heur::rfl::ObjCGGBaseSpawner base;
        heur::rfl::ObjCGGRootTimerParam timer;
        uint8_t railNum;
        float debugAreaRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGRootSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGRootSpawner* pInstance);
        static void Clean(ObjCGGRootSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool isWaitSpawn;
        bool useTerritory;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        int32_t no;
        int32_t cggLayerId;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool isCutRail;
        bool enable3rdParameter;
        bool enableHightSpeedMoveing;
        float speedUpScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerSpawner* pInstance);
        static void Clean(MiniBossChargerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaSpawner {
        enum class Mode : int8_t {
            Battle = 0,
            QuestKodamaEscort = 1,
            QuestKodamaEscort2 = 2,
            QuestDarumaBattle = 3,
        };

        uint32_t level;
        Mode mode;
        uint32_t bodyCount;
        int8_t ringPositions[4];
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool isWaitSpawn;
        bool isTutorial;
        bool isAppear;
        bool useTerritory;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        int32_t no;
        float stompWaitTimeFirst;
        float stompWaitTime;
        float scoutDistanceOffset;
        float scoutDistanceOutsideOffset;
        bool isThorn;
        bool enabledEyeSightMask;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool enable3rdParameter;
        bool enableHightSpeedMoveing;
        float speedUpScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaSpawner* pInstance);
        static void Clean(MiniBossDarumaSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerPathLoopInfo {
        bool enable;
        float start;
        float end;
        hh::game::ObjectId cameraActivator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerPathLoopInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerPathLoopInfo* pInstance);
        static void Clean(FlyerPathLoopInfo* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossFlyerSpawner {
        uint32_t level;
        bool isWaitSpawn;
        bool isTutorial;
        bool respawnableByMeteorShower;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        csl::ut::VariableString pathName;
        heur::rfl::FlyerPathLoopInfo loopInfo[5];
        int32_t no;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossFlyerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossFlyerSpawner* pInstance);
        static void Clean(MiniBossFlyerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSkierMissileSpawner {
        float speed;
        csl::math::Vector3 launchDirCorrectionAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSkierMissileSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSkierMissileSpawner* pInstance);
        static void Clean(ObjSkierMissileSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSkierProhibitedAreaSpawner {
        float radius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSkierProhibitedAreaSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSkierProhibitedAreaSpawner* pInstance);
        static void Clean(ObjSkierProhibitedAreaSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSkierPylonSpawner {
        float appearTime;
        float hideOffsetY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSkierPylonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSkierPylonSpawner* pInstance);
        static void Clean(ObjSkierPylonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct SkierPathAttributeInfo {
        enum class Attribute : int8_t {
            SNAKE_MOVE_ENABLE = 0,
            JUMP_ENABLE = 1,
            TAIL_ATTACK_ENABLE = 2,
            POSTURELR_ENABLE = 3,
            COL_CONFLICT = 4,
            NONE = 5,
        };

        bool debugDraw;
        Attribute attribute;
        float start;
        float end;
        csl::ut::MoveArray<hh::game::ObjectId> pylons;
        csl::ut::MoveArray<hh::game::ObjectId> missiles;
        float avoidObjCalMargePylonOffset;
        float avoidObjCalMargeMissileOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SkierPathAttributeInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SkierPathAttributeInfo* pInstance);
        static void Clean(SkierPathAttributeInfo* pInstance);
    };
}

namespace heur::rfl {
    struct SkierSkiAcitionRate {
        float SnakeMoveRate;
        float JumpHighRate;
        float JumpLowRate;
        float PylonRate;
        float MissileRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SkierSkiAcitionRate* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SkierSkiAcitionRate* pInstance);
        static void Clean(SkierSkiAcitionRate* pInstance);
    };
}

namespace heur::rfl {
    struct SkierSkiActionParam {
        enum class RateType : int8_t {
            COMMON = 0,
            PHASE1 = 1,
            PHASE2 = 2,
            PHASE3 = 3,
            NONE = 4,
        };

        bool debugDraw;
        RateType type;
        float pathDist;
        heur::rfl::SkierSkiAcitionRate rate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SkierSkiActionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SkierSkiActionParam* pInstance);
        static void Clean(SkierSkiActionParam* pInstance);
    };
}

namespace heur::rfl {
    struct SkierCameraInfo {
        enum class ActivateCondition : int8_t {
            ALL = 0,
            SNAKE_MOVE = 1,
            JUMP_HIGH = 2,
            JUMP_LOW = 3,
            PYLON = 4,
            MISSILE = 5,
        };

        bool debugDraw;
        ActivateCondition condition;
        float start;
        float end;
        hh::game::ObjectId cameraActivator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SkierCameraInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SkierCameraInfo* pInstance);
        static void Clean(SkierCameraInfo* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierSpawner {
        int32_t no;
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool useTerritory;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        bool isWaitSpawn;
        bool isTutorial;
        bool respawnableByMeteorShower;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        csl::ut::VariableString pathName;
        float pathPNTInterpolateSpeed;
        heur::rfl::SkierPathAttributeInfo pathInfo[20];
        heur::rfl::SkierSkiActionParam pathAction[20];
        heur::rfl::SkierCameraInfo cameraInfo[40];
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        csl::ut::MoveArray<hh::game::ObjectId> prohibitedArea;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierSpawner* pInstance);
        static void Clean(MiniBossSkierSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDivingAuraTrainRoot {
        csl::ut::VariableString pathName;
        hh::game::ObjectId cameraUuid;
        float cameraEaseInTime;
        float cameraEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDivingAuraTrainRoot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDivingAuraTrainRoot* pInstance);
        static void Clean(ObjDivingAuraTrainRoot* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDivingAuraTrainSpawner {
        enum class SetType : int8_t {
            Distance = 0,
            Quantity = 1,
        };

        SetType setType;
        float value;
        int32_t startNum;
        csl::ut::MoveArray<hh::game::ObjectId> cameraColliderUuids;
        heur::rfl::ObjDivingAuraTrainRoot root;
        float speed;
        csl::math::Vector3 collisionScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDivingAuraTrainSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDivingAuraTrainSpawner* pInstance);
        static void Clean(ObjDivingAuraTrainSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderDivingVolumeSpawner {
        enum class StateType : int8_t {
            DEFAULTSTATE_ON = 0,
            DEFAULTSTATE_OFF = 1,
        };

        enum class ActionType : int8_t {
            ACTION_EACHTIME = 0,
            ACTION_ONCE = 1,
        };

        bool limit;
        float easeTimeEnter;
        float easeTimeLeave;
        float outOfControlTime;
        float waitTime;
        bool velocityReset;
        StateType state;
        ActionType action;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderDivingVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderDivingVolumeSpawner* pInstance);
        static void Clean(ObjSpiderDivingVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderNeedleSpawner {
        csl::ut::VariableString pathName;
        csl::math::Vector3 collisionSize;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderNeedleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderNeedleSpawner* pInstance);
        static void Clean(ObjSpiderNeedleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderRippleLaserSpawner {
        float minScale;
        float maxScale;
        float scalePeriod;
        csl::ut::VariableString pathName;
        float movePeriod;
        bool isWrapBack;
        float moveDelay;
        float depthFix;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderRippleLaserSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderRippleLaserSpawner* pInstance);
        static void Clean(ObjSpiderRippleLaserSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderRotateLaserTurretParam {
        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        TimeType timeType;
        float time;
        float radius;
        float phase;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderRotateLaserTurretParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderRotateLaserTurretParam* pInstance);
        static void Clean(ObjSpiderRotateLaserTurretParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderRotateLaserTurretSpawner {
        heur::rfl::ObjSpiderRotateLaserTurretParam param;
        int8_t edgeNum;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderRotateLaserTurretSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderRotateLaserTurretSpawner* pInstance);
        static void Clean(ObjSpiderRotateLaserTurretSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderThornBallMoveParam {
        enum class Direction : int8_t {
            DIR_HORIZONTAL = 0,
            DIR_VERTICAL = 1,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        float time;
        float distance;
        float phase;
        Direction direction;
        TimeType timeType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderThornBallMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderThornBallMoveParam* pInstance);
        static void Clean(ObjSpiderThornBallMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderThornBallRollingParam {
        enum class Direction : int8_t {
            DIR_HORIZONTAL = 0,
            DIR_VERTICAL = 1,
        };

        float time;
        float radius;
        float phase;
        Direction direction;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderThornBallRollingParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderThornBallRollingParam* pInstance);
        static void Clean(ObjSpiderThornBallRollingParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderThornBallSpawner {
        enum class Type : int8_t {
            TYPE_NORMAL = 0,
            TYPE_MOVE = 1,
            TYPE_ROLLING = 2,
        };

        Type type;
        heur::rfl::ObjSpiderThornBallMoveParam moveParam;
        heur::rfl::ObjSpiderThornBallRollingParam rollingParam;
        heur::rfl::VolumeTriggerSpawner volume;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderThornBallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderThornBallSpawner* pInstance);
        static void Clean(ObjSpiderThornBallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderTwisterMoveParam {
        enum class Direction : int8_t {
            DIR_HORIZONTAL = 0,
            DIR_VERTICAL = 1,
        };

        enum class TimeType : int8_t {
            TIME_LOCAL = 0,
            TIME_GLOBAL = 1,
        };

        float time;
        float distance;
        float phase;
        Direction direction;
        TimeType timeType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderTwisterMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderTwisterMoveParam* pInstance);
        static void Clean(ObjSpiderTwisterMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderTwisterRollingParam {
        enum class Direction : int8_t {
            DIR_HORIZONTAL = 0,
            DIR_VERTICAL = 1,
        };

        float time;
        float radius;
        float phase;
        Direction direction;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderTwisterRollingParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderTwisterRollingParam* pInstance);
        static void Clean(ObjSpiderTwisterRollingParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSpiderTwisterSpawner {
        enum class Type : int8_t {
            TYPE_NORMAL = 0,
            TYPE_MOVE = 1,
            TYPE_ROLLING = 2,
        };

        Type type;
        heur::rfl::ObjSpiderTwisterMoveParam moveParam;
        heur::rfl::ObjSpiderTwisterRollingParam rollingParam;
        float rigidColliderRadius;
        float damageColliderRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSpiderTwisterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSpiderTwisterSpawner* pInstance);
        static void Clean(ObjSpiderTwisterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool isWaitSpawn;
        bool isTutorial;
        bool useTerritory;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        hh::game::ObjectId locatorDiving;
        uint8_t shieldHpNormal;
        float divingBeginHeightNormal;
        csl::ut::VariableString divingSetNameNormal;
        csl::ut::VariableString divingActiveLayerNormal;
        uint8_t shieldHpAngry;
        float divingBeginHeightAngry;
        csl::ut::VariableString divingSetNameAngry;
        csl::ut::VariableString divingActiveLayerAngry;
        int32_t no;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool isCutUpper;
        bool enable3rdParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderSpawner* pInstance);
        static void Clean(MiniBossSpiderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderArcLaserSpawner {
        int8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderArcLaserSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderArcLaserSpawner* pInstance);
        static void Clean(ObjStriderArcLaserSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderBulletSpawner {
        hh::game::ObjectId connectToPole;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderBulletSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderBulletSpawner* pInstance);
        static void Clean(ObjStriderBulletSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderGrindRailSpawner : heur::rfl::PathCircleParameter {
        int8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderGrindRailSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderGrindRailSpawner* pInstance);
        static void Clean(ObjStriderGrindRailSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderLaserSpawner {
        int8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderLaserSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderLaserSpawner* pInstance);
        static void Clean(ObjStriderLaserSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossStriderSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool isWaitSpawn;
        bool isTutorial;
        bool useTerritory;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        int32_t no;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossStriderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossStriderSpawner* pInstance);
        static void Clean(MiniBossStriderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPoleSpawner {
        enum class NormalDirection : int8_t {
            Front = 0,
            Back = 1,
        };

        hh::game::ObjectId connectToPole;
        NormalDirection normalDirection;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPoleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPoleSpawner* pInstance);
        static void Clean(ObjSumoPoleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPuckSpawner {
        enum class BehaviorType : int8_t {
            Bumper = 0,
            Bomb = 1,
        };

        BehaviorType behaviorType;
        float speed;
        float lifeTime;
        float timeStartDecelerate;
        float deceleration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPuckSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPuckSpawner* pInstance);
        static void Clean(ObjSumoPuckSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoSpawner {
        uint32_t level;
        bool isWaitSpawn;
        bool isTutorial;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> poles;
        bool onlyHeightField;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoSpawner* pInstance);
        static void Clean(MiniBossSumoSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        csl::ut::MoveArray<hh::game::ObjectId> bases;
        csl::ut::MoveArray<hh::game::ObjectId> attackTargets;
        csl::ut::MoveArray<hh::game::ObjectId> attackTargets2;
        csl::ut::MoveArray<hh::game::ObjectId> attackTargets3;
        bool isWaitSpawn;
        bool isTutorial;
        bool useTerritory;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        int32_t no;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool enable3rdParameter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerSpawner* pInstance);
        static void Clean(MiniBossTrackerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerAttackTargetSpawner {
        enum class Type : int8_t {
            Mine = 0,
            RingHole = 1,
            MineNoMotion = 2,
        };

        Type type;
        float waitTime;
        float repeatTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerAttackTargetSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerAttackTargetSpawner* pInstance);
        static void Clean(MiniBossTrackerAttackTargetSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerBaseSpawner {
        csl::ut::MoveArray<hh::game::ObjectId> gimmicks;
        float returnRadius;
        float visibleDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerBaseSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerBaseSpawner* pInstance);
        static void Clean(MiniBossTrackerBaseSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool isWaitSpawn;
        bool isTutorial;
        bool useTerritory;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        int32_t no;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;
        bool isCutUpper;
        bool enable3rdParameter;
        bool enableHightSpeedMoveing;
        float speedUpScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantSpawner* pInstance);
        static void Clean(MiniBossTyrantSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarShipBirdSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarShipBirdSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarShipBirdSpawner* pInstance);
        static void Clean(ObjWarShipBirdSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarShipBulletSpawner {
        int32_t railNo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarShipBulletSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarShipBulletSpawner* pInstance);
        static void Clean(ObjWarShipBulletSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarshipDashRingSpawner {
        enum class Visual : int8_t {
            WarshipDashRing = 0,
            RainbowRing = 1,
            None = 2,
            Num = 3,
        };

        Visual visual;
        float OutOfControl;
        float KeepVelocity;
        float Speed;
        bool PosConst;
        bool VeloConst;
        bool Spin;
        bool AirTrick;
        heur::rfl::ActionNotification actions[3];
        heur::rfl::PathMovement pathMovement;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarshipDashRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarshipDashRingSpawner* pInstance);
        static void Clean(ObjWarshipDashRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct LandingLaunchParam {
        float outStrength;
        float inStrength;
        float outElev;
        float inElev;
        float speedMin;
        float speedMax;
        float speedMinLength;
        float speedMaxLength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(LandingLaunchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(LandingLaunchParam* pInstance);
        static void Clean(LandingLaunchParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarshipLandVolumeSpawner {
        enum class StateType : int8_t {
            DEFAULTSTATE_ON = 0,
            DEFAULTSTATE_OFF = 1,
        };

        enum class ActionType : int8_t {
            ACTION_EACHTIME = 0,
            ACTION_ONCE = 1,
        };

        StateType state;
        ActionType action;
        heur::rfl::VolumeTriggerSpawner volume;
        heur::rfl::LandingLaunchParam launchParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarshipLandVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarshipLandVolumeSpawner* pInstance);
        static void Clean(ObjWarshipLandVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct WarshipSpeedParam {
        enum class SpeedUseType : int8_t {
            NONE = 0,
            SET = 1,
            RESET = 2,
        };

        SpeedUseType useType;
        float highSpeed;
        float lowSpeed;
        float changeLowSpeedDistance;
        float disableDistanceMaxSpeed;
        float relativeSpeedDisableDistance;
        float speedOnJump;
        float speedDownOnJumpDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WarshipSpeedParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WarshipSpeedParam* pInstance);
        static void Clean(WarshipSpeedParam* pInstance);
    };
}

namespace heur::rfl {
    struct WarshipMotionParam {
        enum class MotionType : int8_t {
            MOTION_NONE = 0,
            DASHRING = 1,
            BULLET = 2,
            BIRD = 3,
        };

        enum class MotionPattern : int8_t {
            START = 0,
            END = 1,
        };

        MotionType motionType;
        MotionPattern motionPattern;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WarshipMotionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WarshipMotionParam* pInstance);
        static void Clean(WarshipMotionParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarshipVolumeSpawner {
        enum class StateType : int8_t {
            DEFAULTSTATE_ON = 0,
            DEFAULTSTATE_OFF = 1,
        };

        enum class ActionType : int8_t {
            ACTION_EACHTIME = 0,
            ACTION_ONCE = 1,
        };

        StateType state;
        ActionType action;
        heur::rfl::WarshipSpeedParam speedParam;
        heur::rfl::WarshipMotionParam motionParam;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarshipVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarshipVolumeSpawner* pInstance);
        static void Clean(ObjWarshipVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct WarshipLocatorInfo {
        csl::ut::VariableString attackPathName;
        csl::ut::MoveArray<hh::game::ObjectId> locaterList;
        float changeStateDistance;
        float stopAttackDistance;
        csl::ut::VariableString grindPathNames[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WarshipLocatorInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WarshipLocatorInfo* pInstance);
        static void Clean(WarshipLocatorInfo* pInstance);
    };
}

namespace heur::rfl {
    struct WarshipCameraParam {
        float start;
        float end;
        hh::game::ObjectId cameraActivator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WarshipCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WarshipCameraParam* pInstance);
        static void Clean(WarshipCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct WarshipPathSectionInfo {
        bool enable;
        float start;
        float end;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WarshipPathSectionInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WarshipPathSectionInfo* pInstance);
        static void Clean(WarshipPathSectionInfo* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipSpawner {
        uint32_t level;
        csl::ut::MoveArray<hh::game::ObjectId> territories;
        bool isWaitSpawn;
        bool isTutorial;
        bool useTerritory;
        bool respawnableByMeteorShower;
        heur::rfl::ObjTerritorySpawner territoryInfo;
        csl::ut::MoveArray<hh::game::ObjectId> portalBits;
        csl::ut::VariableString wanderPathName;
        heur::rfl::WarshipLocatorInfo locatorInfo[3];
        int32_t eacapePathNo;
        csl::ut::MoveArray<hh::game::ObjectId> winWarpList;
        csl::ut::MoveArray<hh::game::ObjectId> eventLocatorList;
        heur::rfl::WarshipCameraParam cameraParam[20];
        heur::rfl::WarshipPathSectionInfo rotateInfo[20];
        heur::rfl::WarshipPathSectionInfo wanderPathInfo;
        heur::rfl::WarshipPathSectionInfo noBombPathInfo[10];
        heur::rfl::EnemyPracticeNotifierConfig practiceConfig;
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipSpawner* pInstance);
        static void Clean(MiniBossWarshipSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpawnerSpawner {
        int32_t minibossId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpawnerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpawnerSpawner* pInstance);
        static void Clean(MiniBossSpawnerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBarbecueMachineSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBarbecueMachineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBarbecueMachineSpawner* pInstance);
        static void Clean(ObjBarbecueMachineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBarbecueSonicSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBarbecueSonicSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBarbecueSonicSpawner* pInstance);
        static void Clean(ObjBarbecueSonicSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFishCoinSpawner {
        int32_t no;
        bool eventDriven;
        bool spawnByGrowFlower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFishCoinSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFishCoinSpawner* pInstance);
        static void Clean(ObjFishCoinSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFisherSonicSpawner {
        csl::math::Vector3 castPointCenter;
        float castPointRadius;
        csl::math::Vector3 finishPoint;
        csl::math::Vector3 largeFishPoint;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFisherSonicSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFisherSonicSpawner* pInstance);
        static void Clean(ObjFisherSonicSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFishingBigSpawner {
        int8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFishingBigSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFishingBigSpawner* pInstance);
        static void Clean(ObjFishingBigSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFishingSequenceSpawner {
        int32_t spotId;
        hh::game::ObjectId sonicObj;
        hh::game::ObjectId bigObj;
        hh::game::ObjectId talkCamera;
        hh::game::ObjectId fishingCamera;
        hh::game::ObjectId castCamera;
        hh::game::ObjectId fishingSonicPos;
        csl::math::Vector3 fishSwimCenter;
        float fishSwimRadius;
        float buoyCameraTransitTime;
        csl::math::Vector3 buoyCameraOffset;
        csl::math::Vector3 battleCameraOffset;
        csl::math::Vector3 catchCameraOffset;
        float fishingCameraTransitTime;
        csl::math::Vector3 cyberNoiseEffectPos;
        csl::math::Vector3 cyberNoiseEffectRot;
        hh::game::ObjectId barbecueSonicObj;
        hh::game::ObjectId barbecueMachineObj;
        hh::game::ObjectId barbecueCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFishingSequenceSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFishingSequenceSpawner* pInstance);
        static void Clean(ObjFishingSequenceSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAmySpawner {
        enum class PurposeOfUse : int8_t {
            Normal = 0,
            Quest = 1,
            Quest_Retry = 2,
            SubEvent = 3,
            NumUses = 4,
        };

        enum class Value : int8_t {
            KodamaCollection01 = 0,
            Mowing = 1,
            KodamaEscort = 2,
            KodamaCollection02 = 3,
            DarumaBattle = 4,
            CollectItem = 5,
            DrawBridge = 6,
            NumQuestTypes = 7,
        };

        enum class CharacterType : int8_t {
            All = 0,
            Sonic = 1,
            Amy = 2,
            Knuckles = 3,
            Tails = 4,
            NumCharaTypes = 5,
        };

        enum class AdditionalColliderShape : int8_t {
            Cylinder = 0,
            Box = 1,
            Sphere = 2,
            Capsule = 3,
            NumShapes = 4,
        };

        int32_t no;
        PurposeOfUse purposeOfUse;
        Value questType;
        bool eventDriven;
        csl::ut::VariableString luaName;
        csl::ut::VariableString eventName;
        bool isEndKill;
        bool useDefaultPath;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        bool isUseSequenceItem;
        int32_t requiredSequenceItem;
        csl::ut::VariableString lackLuaName;
        csl::ut::VariableString inputEventName;
        CharacterType useCharacterType;
        bool useAdditionalCollider;
        AdditionalColliderShape additionalColliderShape;
        csl::math::Vector3 offset;
        csl::math::Vector3 extents;
        float radius;
        float height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAmySpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAmySpawner* pInstance);
        static void Clean(ObjAmySpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEggManSpawner {
        enum class PurposeOfUse : int8_t {
            Normal = 0,
            SubEvent = 1,
            NumUses = 2,
        };

        enum class CharacterType : int8_t {
            All = 0,
            Sonic = 1,
            Amy = 2,
            Knuckles = 3,
            Tails = 4,
            NumCharaTypes = 5,
        };

        int32_t no;
        PurposeOfUse purposeOfUse;
        bool eventDriven;
        csl::ut::VariableString luaName;
        csl::ut::VariableString eventName;
        bool isEndKill;
        bool useDefaultPath;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        CharacterType useCharacterType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEggManSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEggManSpawner* pInstance);
        static void Clean(ObjEggManSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnucklesSpawner {
        enum class PurposeOfUse : int8_t {
            Normal = 0,
            Quest = 1,
            Quest_Retry = 2,
            SubEvent = 3,
            NumUses = 4,
        };

        enum class Value : int8_t {
            KodamaCollection01 = 0,
            Mowing = 1,
            KodamaEscort = 2,
            KodamaCollection02 = 3,
            DarumaBattle = 4,
            CollectItem = 5,
            DrawBridge = 6,
            NumQuestTypes = 7,
        };

        enum class CharacterType : int8_t {
            All = 0,
            Sonic = 1,
            Amy = 2,
            Knuckles = 3,
            Tails = 4,
            NumCharaTypes = 5,
        };

        enum class AdditionalColliderShape : int8_t {
            Cylinder = 0,
            Box = 1,
            Sphere = 2,
            Capsule = 3,
            NumShapes = 4,
        };

        int32_t no;
        PurposeOfUse purposeOfUse;
        Value questType;
        bool eventDriven;
        csl::ut::VariableString luaName;
        csl::ut::VariableString eventName;
        bool isEndKill;
        bool useDefaultPath;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        bool isUseSequenceItem;
        int32_t requiredSequenceItem;
        csl::ut::VariableString lackLuaName;
        csl::ut::VariableString inputEventName;
        CharacterType useCharacterType;
        bool useAdditionalCollider;
        AdditionalColliderShape additionalColliderShape;
        csl::math::Vector3 offset;
        csl::math::Vector3 extents;
        float radius;
        float height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnucklesSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnucklesSpawner* pInstance);
        static void Clean(ObjKnucklesSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAmyKodamaElderSpawner {
        int32_t no;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;
        bool isAmyKodamaCollect;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAmyKodamaElderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAmyKodamaElderSpawner* pInstance);
        static void Clean(ObjAmyKodamaElderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAmyKodamaHermitSpawner {
        int32_t no;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;
        bool isAmyKodamaCollect;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAmyKodamaHermitSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAmyKodamaHermitSpawner* pInstance);
        static void Clean(ObjAmyKodamaHermitSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaSpawner {
        int32_t no;
        bool eventDriven;
        bool restrictMotion;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaSpawner* pInstance);
        static void Clean(ObjKodamaSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaElderSpawner {
        int32_t no;
        hh::game::ObjectId fastTravelLocator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaElderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaElderSpawner* pInstance);
        static void Clean(ObjKodamaElderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaEscortSpawner {
        enum class QuestType : uint8_t {
            KodamaEscortDesert = 0,
            NumQuestTypes = 1,
        };

        int32_t no;
        QuestType questType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaEscortSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaEscortSpawner* pInstance);
        static void Clean(ObjKodamaEscortSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaHermitSpawner {
        int32_t no;
        hh::game::ObjectId fastTravelLocator;
        csl::ut::VariableString eventNamePower;
        csl::ut::VariableString eventNameGuard;
        csl::ut::VariableString eventNamePowerAndGuard;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaHermitSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaHermitSpawner* pInstance);
        static void Clean(ObjKodamaHermitSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaLauncherSpawner {
        uint32_t numKodamas;
        float splashMinRadius;
        float splashMaxRadius;
        float launchAngle;
        float launchMaxSpeed;
        float launchMinSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaLauncherSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaLauncherSpawner* pInstance);
        static void Clean(ObjKodamaLauncherSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaMapSpawner {
        enum class CharacterType : int8_t {
            Amy = 0,
            Knuckles = 1,
            Tails = 2,
            Num = 3,
        };

        int32_t no;
        CharacterType type;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaMapSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaMapSpawner* pInstance);
        static void Clean(ObjKodamaMapSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaMasterSpawner {
        enum class TrialType : int8_t {
            Dragon = 0,
            Snake = 1,
            Tiger = 2,
            Crane = 3,
            Num = 4,
        };

        enum class StateType : int8_t {
            Access = 0,
            Trial = 1,
            StateNum = 2,
        };

        int32_t no;
        TrialType trialType;
        StateType stateType;
        hh::game::ObjectId trialEndObj;
        csl::ut::VariableString eventName;
        bool useDefaultPath;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaMasterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaMasterSpawner* pInstance);
        static void Clean(ObjKodamaMasterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaMasterKingSpawner {
        enum class KingStateType : int8_t {
            Access = 0,
            Trial = 1,
            StateNum = 2,
        };

        int32_t no;
        csl::ut::VariableString eventName;
        bool useDefaultPath;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;
        KingStateType stateType;
        float SuperSonicfollowingDistance;
        float SuperSonicfollowingHomingDistance;
        float SuperSonicfollowingHeightPosition;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaMasterKingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaMasterKingSpawner* pInstance);
        static void Clean(ObjKodamaMasterKingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaNewFormSpawner {
        enum class Value : int8_t {
            RareA = 0,
            RareB = 1,
            RareC = 2,
            RareD = 3,
            RareE = 4,
            Bronze = 5,
            Silver = 6,
            Goald = 7,
            Num = 8,
        };

        int32_t no;
        bool eventDriven;
        bool restrictMotion;
        Value type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaNewFormSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaNewFormSpawner* pInstance);
        static void Clean(ObjKodamaNewFormSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaPeddlerSpawner {
        enum class CharacterType : int8_t {
            Amy = 0,
            Knuckles = 1,
            Tails = 2,
            Num = 3,
        };

        int32_t no;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;
        CharacterType characterType;
        int32_t skillPieceNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaPeddlerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaPeddlerSpawner* pInstance);
        static void Clean(ObjKodamaPeddlerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaQuestSpawner {
        enum class QuestType : uint8_t {
            KodamaCollectionGrass = 0,
            KodamaCollectionDesert = 1,
            NumQuestTypes = 2,
        };

        int32_t no;
        QuestType questType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaQuestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaQuestSpawner* pInstance);
        static void Clean(ObjKodamaQuestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaTowerSpawner {
        int32_t no;
        float cyloopSignDistance;
        float cyloopSignTolerance;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaTowerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaTowerSpawner* pInstance);
        static void Clean(ObjKodamaTowerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTailsKodamaHackingSpawner {
        int32_t no;
        bool disableFunction;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTailsKodamaHackingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTailsKodamaHackingSpawner* pInstance);
        static void Clean(ObjTailsKodamaHackingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaChildSpawner {
        int32_t no;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaChildSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaChildSpawner* pInstance);
        static void Clean(ObjKodamaChildSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaDiscipleSpawner {
        int32_t no;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaDiscipleSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaDiscipleSpawner* pInstance);
        static void Clean(ObjKodamaDiscipleSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaLoverSpawner {
        int32_t no;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaLoverSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaLoverSpawner* pInstance);
        static void Clean(ObjKodamaLoverSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaMotherSpawner {
        enum class PurposeOfUse : uint8_t {
            Normal = 0,
            Quest = 1,
            NumTypes = 2,
        };

        int32_t no;
        bool eventDriven;
        PurposeOfUse purposeOfUse;
        float modelScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaMotherSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaMotherSpawner* pInstance);
        static void Clean(ObjKodamaMotherSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaPunchSpawner {
        int32_t no;
        bool guideCircleEnabled;
        csl::math::Vector3 guideCircleOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaPunchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaPunchSpawner* pInstance);
        static void Clean(ObjKodamaPunchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaSoldierSpawner {
        int32_t no;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaSoldierSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaSoldierSpawner* pInstance);
        static void Clean(ObjKodamaSoldierSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaWarriorSpawner {
        int32_t no;
        bool eventDriven;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaWarriorSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaWarriorSpawner* pInstance);
        static void Clean(ObjKodamaWarriorSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNpcSonicSpawner {
        enum class PurposeOfUse : int8_t {
            Normal = 0,
            SubEvent = 1,
            NumUses = 2,
        };

        enum class CharacterType : int8_t {
            All = 0,
            Sonic = 1,
            Amy = 2,
            Knuckles = 3,
            Tails = 4,
            NumCharaTypes = 5,
        };

        int32_t no;
        PurposeOfUse purposeOfUse;
        bool eventDriven;
        csl::ut::VariableString luaName;
        csl::ut::VariableString eventName;
        bool isEndKill;
        bool useDefaultPath;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        CharacterType useCharacterType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNpcSonicSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNpcSonicSpawner* pInstance);
        static void Clean(ObjNpcSonicSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSageSpawner {
        enum class PurposeOfUse : int8_t {
            Normal = 0,
            Quest = 1,
            SubEvent = 2,
            NumUses = 3,
        };

        enum class Value : int8_t {
            KodamaCollection01 = 0,
            Mowing = 1,
            KodamaEscort = 2,
            KodamaCollection02 = 3,
            DarumaBattle = 4,
            CollectItem = 5,
            DrawBridge = 6,
            NumQuestTypes = 7,
        };

        enum class CharacterType : int8_t {
            All = 0,
            Sonic = 1,
            Amy = 2,
            Knuckles = 3,
            Tails = 4,
            NumCharaTypes = 5,
        };

        enum class AdditionalColliderShape : int8_t {
            Cylinder = 0,
            Box = 1,
            Sphere = 2,
            Capsule = 3,
            NumShapes = 4,
        };

        int32_t no;
        PurposeOfUse purposeOfUse;
        Value questType;
        bool eventDriven;
        csl::ut::VariableString luaName;
        csl::ut::VariableString eventName;
        bool isEndKill;
        bool useDefaultPath;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        bool isUseSequenceItem;
        int32_t requiredSequenceItem;
        csl::ut::VariableString inputEventName;
        CharacterType useCharacterType;
        bool useAdditionalCollider;
        AdditionalColliderShape additionalColliderShape;
        csl::math::Vector3 offset;
        csl::math::Vector3 extents;
        float radius;
        float height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSageSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSageSpawner* pInstance);
        static void Clean(ObjSageSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTailsSpawner {
        enum class PurposeOfUse : int8_t {
            Normal = 0,
            Quest = 1,
            Quest_Retry = 2,
            SubEvent = 3,
            NumUses = 4,
        };

        enum class Value : int8_t {
            KodamaCollection01 = 0,
            Mowing = 1,
            KodamaEscort = 2,
            KodamaCollection02 = 3,
            DarumaBattle = 4,
            CollectItem = 5,
            DrawBridge = 6,
            NumQuestTypes = 7,
        };

        enum class CharacterType : int8_t {
            All = 0,
            Sonic = 1,
            Amy = 2,
            Knuckles = 3,
            Tails = 4,
            NumCharaTypes = 5,
        };

        int32_t no;
        PurposeOfUse purposeOfUse;
        Value questType;
        bool eventDriven;
        csl::ut::VariableString luaName;
        csl::ut::VariableString eventName;
        bool isEndKill;
        bool useDefaultPath;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        bool isUseSequenceItem;
        int32_t requiredSequenceItem;
        csl::ut::VariableString lackLuaName;
        csl::ut::VariableString inputEventName;
        CharacterType useCharacterType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTailsSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTailsSpawner* pInstance);
        static void Clean(ObjTailsSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct PathMoveCameraParam {
        float azimuth;
        float elevation;
        float distance;
        float zRoll;
        float fovy;
        csl::math::Vector3 frameOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PathMoveCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PathMoveCameraParam* pInstance);
        static void Clean(PathMoveCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPathMoveFieldSpawner {
        heur::rfl::PathMoveCameraParam cameraParam;
        csl::ut::VariableString pathName;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPathMoveFieldSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPathMoveFieldSpawner* pInstance);
        static void Clean(ObjPathMoveFieldSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct DropQuestItemParam {
        int32_t dropNum;
        float velocity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DropQuestItemParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DropQuestItemParam* pInstance);
        static void Clean(DropQuestItemParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuestBoxSpawner {
        enum class BoxSizeType : int8_t {
            SMALL = 0,
            MIDDLE = 1,
            LARGE = 2,
            SIZETYPE_NUM = 3,
        };

        BoxSizeType size;
        int32_t heightBoxNum;
        int32_t SideBoxNum;
        int32_t depthBoxNum;
        heur::rfl::DropQuestItemParam dropItemParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuestBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuestBoxSpawner* pInstance);
        static void Clean(ObjQuestBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuestBreakBoxSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuestBreakBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuestBreakBoxSpawner* pInstance);
        static void Clean(ObjQuestBreakBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct GoalBoxParam {
        float depth;
        float height;
        float width;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GoalBoxParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GoalBoxParam* pInstance);
        static void Clean(GoalBoxParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuestDrawBridgeGoalSpawner {
        heur::rfl::GoalBoxParam BoxPram;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuestDrawBridgeGoalSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuestDrawBridgeGoalSpawner* pInstance);
        static void Clean(ObjQuestDrawBridgeGoalSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaEscortDarumaSpawner {
        uint32_t level;
        uint32_t bodyCount;
        float stompWaitTime;
        bool isThorn;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaEscortDarumaSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaEscortDarumaSpawner* pInstance);
        static void Clean(ObjKodamaEscortDarumaSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBeeFlowerSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBeeFlowerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBeeFlowerSpawner* pInstance);
        static void Clean(ObjBeeFlowerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBeeSwarmSpawner {
        int8_t beeNum;
        float beeInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBeeSwarmSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBeeSwarmSpawner* pInstance);
        static void Clean(ObjBeeSwarmSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGrassRestoreVolumeSpawner {
        csl::math::Vector3 extents;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGrassRestoreVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGrassRestoreVolumeSpawner* pInstance);
        static void Clean(ObjGrassRestoreVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMowingGrassSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMowingGrassSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMowingGrassSpawner* pInstance);
        static void Clean(ObjMowingGrassSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjResultViewCameraStoreSpawner {
        hh::game::ObjectId camera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjResultViewCameraStoreSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjResultViewCameraStoreSpawner* pInstance);
        static void Clean(ObjResultViewCameraStoreSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuestEndPositionSpawner {
        enum class Value : int8_t {
            KodamaCollection01 = 0,
            Mowing = 1,
            KodamaEscort = 2,
            KodamaCollection02 = 3,
            DarumaBattle = 4,
            CollectItem = 5,
            DrawBridge = 6,
            NumQuestTypes = 7,
        };

        enum class Condition : int8_t {
            COND_FAILED = 0,
            COND_CLEARED = 1,
        };

        Value questType;
        Condition condition;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuestEndPositionSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuestEndPositionSpawner* pInstance);
        static void Clean(ObjQuestEndPositionSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuestStartPositionSpawner {
        enum class Value : int8_t {
            KodamaCollection01 = 0,
            Mowing = 1,
            KodamaEscort = 2,
            KodamaCollection02 = 3,
            DarumaBattle = 4,
            CollectItem = 5,
            DrawBridge = 6,
            NumQuestTypes = 7,
        };

        Value questType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuestStartPositionSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuestStartPositionSpawner* pInstance);
        static void Clean(ObjQuestStartPositionSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEnemyBulletPatternPreviewSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEnemyBulletPatternPreviewSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEnemyBulletPatternPreviewSpawner* pInstance);
        static void Clean(ObjEnemyBulletPatternPreviewSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHomingLaserTargetManagerSpawner {
        csl::ut::MoveArray<hh::game::ObjectId> enemyIds;
        hh::game::ObjectId bossId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHomingLaserTargetManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHomingLaserTargetManagerSpawner* pInstance);
        static void Clean(ObjHomingLaserTargetManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShootingEnemyCoreSpawner {
        int32_t no;
        csl::ut::VariableString luaName;
        int32_t hp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShootingEnemyCoreSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShootingEnemyCoreSpawner* pInstance);
        static void Clean(ObjShootingEnemyCoreSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ChangeWaveCondition {
        bool coreEnemyHpRemain;
        float coreEnemyRemanHpPersentage;
        bool timeLimitFlag;
        float limitTime;
        bool normalEnemyAllClear;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChangeWaveCondition* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChangeWaveCondition* pInstance);
        static void Clean(ChangeWaveCondition* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShootingEnemyManagerSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> enemyIds;
        csl::ut::VariableString luaName;
        heur::rfl::ChangeWaveCondition changeWaveCondition;
        bool startScriptAfterSerif;
        csl::ut::VariableString soundName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShootingEnemyManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShootingEnemyManagerSpawner* pInstance);
        static void Clean(ObjShootingEnemyManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShootingEnemyNormalSpawner {
        enum class HpType : uint8_t {
            HpS = 0,
            HpM = 1,
            HpL = 2,
        };

        int32_t no;
        HpType hpType;
        csl::ut::VariableString luaName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShootingEnemyNormalSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShootingEnemyNormalSpawner* pInstance);
        static void Clean(ObjShootingEnemyNormalSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShootingEnemyWaveManagerSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> enemyManagerIds;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShootingEnemyWaveManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShootingEnemyWaveManagerSpawner* pInstance);
        static void Clean(ObjShootingEnemyWaveManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAmbSoundVolumeSpawner {
        enum class ShapeType : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CYLINDER = 2,
            SHAPE_CAPSULE = 3,
        };

        enum class BasePoint : int8_t {
            BASE_CENTER = 0,
            BASE_Z_PLANE = 1,
        };

        int32_t id;
        ShapeType shape;
        BasePoint basePoint;
        float width;
        float height;
        float depth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAmbSoundVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAmbSoundVolumeSpawner* pInstance);
        static void Clean(ObjAmbSoundVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjChangeBGMAisacVolumeSpawner {
        csl::ut::VariableString aisacName;
        float targetAisacValue;
        float fadeInTime;
        float fadeOutTime;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjChangeBGMAisacVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjChangeBGMAisacVolumeSpawner* pInstance);
        static void Clean(ObjChangeBGMAisacVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjChangeBGMTriggerSpawner {
        csl::ut::VariableString cueName;
        float fadeOutTime;
        float playDelayTime;
        float fadeInTime;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjChangeBGMTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjChangeBGMTriggerSpawner* pInstance);
        static void Clean(ObjChangeBGMTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjChangeBGMVolumeSpawner {
        enum class ShapeType : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CYLINDER = 2,
            SHAPE_CAPSULE = 3,
        };

        enum class BasePoint : int8_t {
            BASE_CENTER = 0,
            BASE_Z_PLANE = 1,
        };

        int32_t id;
        ShapeType shape;
        BasePoint basePoint;
        float width;
        float height;
        float depth;
        bool isStop;
        bool oneTime;
        bool autoRemoveRequest;
        int32_t defaultBgmId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjChangeBGMVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjChangeBGMVolumeSpawner* pInstance);
        static void Clean(ObjChangeBGMVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjChangeSEAisacVolumeSpawner {
        csl::ut::VariableString aisacName;
        float targetAisacValue;
        float fadeInTime;
        float fadeOutTime;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjChangeSEAisacVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjChangeSEAisacVolumeSpawner* pInstance);
        static void Clean(ObjChangeSEAisacVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjExtentSoundSourceSpawner {
        enum class PlayMode : int8_t {
            PLAYMODE_LOOP = 0,
            PLAYMODE_ONE_SHOT = 1,
            PLAYMODE_PERIODIC = 2,
        };

        enum class Shape : int8_t {
            SHAPE_SPHERE = 0,
        };

        csl::ut::VariableString cueName;
        PlayMode playMode;
        float timeOffset;
        float playInterval;
        float volume;
        Shape shape;
        csl::math::Vector3 hearingRange;
        csl::math::Vector3 undampedRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjExtentSoundSourceSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjExtentSoundSourceSpawner* pInstance);
        static void Clean(ObjExtentSoundSourceSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOneShotBGMTriggerSpawner {
        enum class ShapeType : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CYLINDER = 2,
        };

        enum class BasePoint : int8_t {
            BASE_CENTER = 0,
            BASE_Z_PLANE = 1,
        };

        csl::ut::VariableString cueName;
        float fadeTime;
        ShapeType shape;
        BasePoint basePoint;
        float width;
        float height;
        float depth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOneShotBGMTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOneShotBGMTriggerSpawner* pInstance);
        static void Clean(ObjOneShotBGMTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOneShotSoundTriggerSpawner {
        enum class SoundPositionType : int8_t {
            SOUND_POS_CENTER = 0,
            SOUND_POS_MANUAL = 1,
        };

        enum class ShapeType : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CYLINDER = 2,
        };

        enum class BasePoint : int8_t {
            BASE_CENTER = 0,
            BASE_Z_PLANE = 1,
        };

        csl::ut::VariableString cueName;
        float volume;
        bool isPlay3D;
        SoundPositionType soundPositionType;
        csl::math::Vector3 soundPosition;
        ShapeType shape;
        BasePoint basePoint;
        float width;
        float height;
        float depth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOneShotSoundTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOneShotSoundTriggerSpawner* pInstance);
        static void Clean(ObjOneShotSoundTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSoundSourceSpawner {
        enum class PlayMode : int8_t {
            PLAYMODE_LOOP = 0,
            PLAYMODE_ONE_SHOT = 1,
            PLAYMODE_PERIODIC = 2,
        };

        csl::ut::VariableString cueName;
        PlayMode playMode;
        float timeOffset;
        float playInterval;
        float volume;
        float hearingRange;
        float undampedRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSoundSourceSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSoundSourceSpawner* pInstance);
        static void Clean(ObjSoundSourceSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPathSoundSourceSpawner : heur::rfl::ObjSoundSourceSpawner {
        csl::ut::VariableString pathName;
        int32_t searchDivideNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPathSoundSourceSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPathSoundSourceSpawner* pInstance);
        static void Clean(ObjPathSoundSourceSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPointSoundSourceSpawner : heur::rfl::ObjSoundSourceSpawner {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPointSoundSourceSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPointSoundSourceSpawner* pInstance);
        static void Clean(ObjPointSoundSourceSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSoundSourcePlaneSpawner {
        csl::ut::VariableString cueName;
        float volume;
        bool is3D;
        csl::math::Vector3 pos3D;
        heur::rfl::PassPlaneTriggerSpawner planeTrigger;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSoundSourcePlaneSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSoundSourcePlaneSpawner* pInstance);
        static void Clean(ObjSoundSourcePlaneSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSoundSourceVolumeSpawner : heur::rfl::ObjSoundSourceSpawner {
        heur::rfl::VolumeTriggerSpawner volumeTrigger;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSoundSourceVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSoundSourceVolumeSpawner* pInstance);
        static void Clean(ObjSoundSourceVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAlbatrossChaseSpawner {
        csl::math::Vector3 relative;
        float thresholdTime;
        float timeMin;
        float timeMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAlbatrossChaseSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAlbatrossChaseSpawner* pInstance);
        static void Clean(ObjAlbatrossChaseSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAlbatrossGroupSpawner {
        enum class RotAxisType : int8_t {
            ROT_AXIS_X = 0,
            ROT_AXIS_Y = 1,
            ROT_AXIS_Z = 2,
        };

        int32_t groupNum;
        csl::math::Vector3 spawmAreaSize;
        csl::math::Vector3 territorySize;
        csl::math::Vector3 offsetPos;
        csl::math::Vector3 baseMoveSpeed;
        float baseRotAngleSpeed;
        float baseRotAnglePhase;
        RotAxisType baseRotAxis;
        bool isGroupRotLock;
        float baseMoveLimitDistance;
        int32_t randomParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAlbatrossGroupSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAlbatrossGroupSpawner* pInstance);
        static void Clean(ObjAlbatrossGroupSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBreakableObjectSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBreakableObjectSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBreakableObjectSpawner* pInstance);
        static void Clean(ObjBreakableObjectSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAncientBridgeSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAncientBridgeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAncientBridgeSpawner* pInstance);
        static void Clean(ObjAncientBridgeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossNestColliderSpawner {
        enum class Shape : int8_t {
            Box = 0,
            Sphere = 1,
            Capsule = 2,
            NumShapes = 3,
        };

        int32_t no;
        Shape shape;
        csl::math::Vector3 offset;
        csl::math::Vector3 extents;
        float radius;
        float height;
        bool collidesWithCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossNestColliderSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossNestColliderSpawner* pInstance);
        static void Clean(ObjBossNestColliderSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantBridgeSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantBridgeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantBridgeSpawner* pInstance);
        static void Clean(ObjGiantBridgeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantIncidentSpawner {
        hh::game::ObjectId startPos;
        hh::game::ObjectId endPos;
        hh::game::ObjectId endLookAt;
        hh::game::ObjectId giant;
        csl::ut::MoveArray<hh::game::ObjectId> rocks;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantIncidentSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantIncidentSpawner* pInstance);
        static void Clean(ObjGiantIncidentSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantIncidentGiantSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantIncidentGiantSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantIncidentGiantSpawner* pInstance);
        static void Clean(ObjGiantIncidentGiantSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantIncidentRockSpawner {
        enum class ModelType : int8_t {
            TYPE_A = 0,
            TYPE_B = 1,
            TYPE_C = 2,
            TYPE_NUM = 3,
        };

        ModelType modelType;
        bool isBreakable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantIncidentRockSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantIncidentRockSpawner* pInstance);
        static void Clean(ObjGiantIncidentRockSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantStatueSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantStatueSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantStatueSpawner* pInstance);
        static void Clean(ObjGiantStatueSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjExtraGiantTowerSpawner {
        int32_t no;
        int8_t unlockOrder;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjExtraGiantTowerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjExtraGiantTowerSpawner* pInstance);
        static void Clean(ObjExtraGiantTowerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantTowerSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantTowerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantTowerSpawner* pInstance);
        static void Clean(ObjGiantTowerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraLimitedPanSpawner : heur::rfl::ObjCameraSpawner {
        enum class PositionMode : int8_t {
            POS_MODE_FIX = 0,
            POS_MODE_MAINTAIN_DISTANCE = 1,
        };

        float fovy;
        csl::math::Vector3 atBase;
        float atRadius;
        float playerRadius;
        float atOffsetY;
        PositionMode positionMode;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraLimitedPanSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraLimitedPanSpawner* pInstance);
        static void Clean(ObjCameraLimitedPanSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStatueSmallSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> targetList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStatueSmallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStatueSmallSpawner* pInstance);
        static void Clean(ObjStatueSmallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWaterfallBreakSpawner {
        int32_t no;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;
        float collisionWidth;
        float collisionHeight;
        float collisionDepth;
        csl::math::Vector3 collisionOffset;
        heur::rfl::VolumeTriggerSpawner effectVolume;
        heur::rfl::VolumeTriggerSpawner effectVolumeBreak[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWaterfallBreakSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWaterfallBreakSpawner* pInstance);
        static void Clean(ObjWaterfallBreakSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWaterfallStatueSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWaterfallStatueSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWaterfallStatueSpawner* pInstance);
        static void Clean(ObjWaterfallStatueSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAirFireBarSpawner {
        int16_t barCount;
        float rotSpeed;
        float bouncePower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAirFireBarSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAirFireBarSpawner* pInstance);
        static void Clean(ObjAirFireBarSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonActionVolumeSpawner {
        enum class ActionType : int8_t {
            MISSILE = 0,
        };

        heur::rfl::VolumeTriggerSpawner volume;
        ActionType actionType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonActionVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonActionVolumeSpawner* pInstance);
        static void Clean(ObjDragonActionVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonAreaSubVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;
        hh::game::ObjectId target;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonAreaSubVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonAreaSubVolumeSpawner* pInstance);
        static void Clean(ObjDragonAreaSubVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonAreaVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;
        float closeRadius;
        hh::game::ObjectId dragon;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonAreaVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonAreaVolumeSpawner* pInstance);
        static void Clean(ObjDragonAreaVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonCameraChangeVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;
        int32_t priority;
        float easeTimeEnter;
        float easeTimeLeave;
        float upOffset;
        float distance;
        float azimuthOffset;
        float elevationOffset;
        float roll;
        bool isChangeFocus;
        float focusRatio;
        float focusLimitAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonCameraChangeVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonCameraChangeVolumeSpawner* pInstance);
        static void Clean(ObjDragonCameraChangeVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentSpawner_EventFirstParam {
        hh::game::ObjectId position;
        hh::game::ObjectId lookAt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentSpawner_EventFirstParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentSpawner_EventFirstParam* pInstance);
        static void Clean(ObjDragonIncidentSpawner_EventFirstParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentSpawner_EventEndParam {
        hh::game::ObjectId position;
        hh::game::ObjectId lookAt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentSpawner_EventEndParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentSpawner_EventEndParam* pInstance);
        static void Clean(ObjDragonIncidentSpawner_EventEndParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentSpawner_EventRetryParam {
        hh::game::ObjectId position;
        hh::game::ObjectId lookAt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentSpawner_EventRetryParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentSpawner_EventRetryParam* pInstance);
        static void Clean(ObjDragonIncidentSpawner_EventRetryParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentSpawner_AutorunCameraParam {
        enum class PlayerOffsetType : int8_t {
            PLAYER_OFFSET_NORMAL = 0,
            PLAYER_OFFSET_ABSOLUTE = 1,
        };

        float fovy;
        float zRot;
        float distance;
        float pathOffset;
        bool reversePathFront;
        bool usePathVerticalComponent;
        bool usePathNormal;
        float angleSensitivity;
        float angleSensitivityBoost;
        float azimuthOffsetDeg;
        float elevationOffsetDeg;
        float gravityOffset;
        csl::math::Vector3 playerOffset;
        PlayerOffsetType playerOffsetType;
        float interpolateTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentSpawner_AutorunCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentSpawner_AutorunCameraParam* pInstance);
        static void Clean(ObjDragonIncidentSpawner_AutorunCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentSpawner_AutorunParam {
        csl::ut::VariableString pathName;
        float speed;
        float boostSpeed;
        float boostSpeedMax;
        float width;
        heur::rfl::ObjDragonIncidentSpawner_AutorunCameraParam cameraIntro;
        heur::rfl::ObjDragonIncidentSpawner_AutorunCameraParam cameraMain;
        csl::ut::MoveArray<hh::game::ObjectId> cameraCollision;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentSpawner_AutorunParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentSpawner_AutorunParam* pInstance);
        static void Clean(ObjDragonIncidentSpawner_AutorunParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentSpawner_MissilePresetParam {
        float heightOffset;
        float firstPathOffset;
        float approachPathOffset;
        float approachSpeed;
        float attackSpeed;
        float aimTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentSpawner_MissilePresetParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentSpawner_MissilePresetParam* pInstance);
        static void Clean(ObjDragonIncidentSpawner_MissilePresetParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentSpawner_MissileCommonParam {
        heur::rfl::ObjDragonIncidentSpawner_MissilePresetParam presets[10];
        float explodeRadius;
        float explodeTime;
        uint32_t damageRings;
        float dummyIntervalMin;
        float dummyIntervalMax;
        uint32_t dummyPresetMax;
        bool dummyDamage;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentSpawner_MissileCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentSpawner_MissileCommonParam* pInstance);
        static void Clean(ObjDragonIncidentSpawner_MissileCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentSpawner {
        hh::game::ObjectId dragon;
        heur::rfl::ObjDragonIncidentSpawner_EventFirstParam eventFirst;
        heur::rfl::ObjDragonIncidentSpawner_EventEndParam eventEnd;
        heur::rfl::ObjDragonIncidentSpawner_EventRetryParam eventRetry;
        heur::rfl::ObjDragonIncidentSpawner_AutorunParam autorun;
        heur::rfl::ObjDragonIncidentSpawner_MissileCommonParam missile;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentSpawner* pInstance);
        static void Clean(ObjDragonIncidentSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentCameraTriggerSpawner {
        hh::game::ObjectId dragonIncident;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentCameraTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentCameraTriggerSpawner* pInstance);
        static void Clean(ObjDragonIncidentCameraTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentDragonSpawner {
        hh::game::ObjectId incident;
        float height;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentDragonSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentDragonSpawner* pInstance);
        static void Clean(ObjDragonIncidentDragonSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentMissileSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentMissileSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentMissileSpawner* pInstance);
        static void Clean(ObjDragonIncidentMissileSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentMissileGroupSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentMissileGroupSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentMissileGroupSpawner* pInstance);
        static void Clean(ObjDragonIncidentMissileGroupSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonIncidentMissileTriggerSpawner {
        hh::game::ObjectId dragonIncident;
        csl::math::Vector3 firstOffset;
        csl::math::Vector3 secondOffset;
        csl::math::Vector3 finishOffset;
        uint32_t preset;
        bool aimPlayer;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonIncidentMissileTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonIncidentMissileTriggerSpawner* pInstance);
        static void Clean(ObjDragonIncidentMissileTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDragonStatusVolumeSpawner {
        heur::rfl::VolumeTriggerSpawner volume;
        bool disableMissile;
        bool keepChase;
        bool changeMotion;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDragonStatusVolumeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDragonStatusVolumeSpawner* pInstance);
        static void Clean(ObjDragonStatusVolumeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantBallSpawner {
        bool eventObject;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantBallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantBallSpawner* pInstance);
        static void Clean(ObjGiantBallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantCraneSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantCraneSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantCraneSpawner* pInstance);
        static void Clean(ObjGiantCraneSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantOrbSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantOrbSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantOrbSpawner* pInstance);
        static void Clean(ObjGiantOrbSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantOrbMountSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantOrbMountSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantOrbMountSpawner* pInstance);
        static void Clean(ObjGiantOrbMountSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct CraneGrid {
        uint8_t row;
        uint8_t col;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CraneGrid* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CraneGrid* pInstance);
        static void Clean(CraneGrid* pInstance);
    };
}

namespace heur::rfl {
    struct OrbMountParam {
        heur::rfl::CraneGrid pos;
        float rotate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OrbMountParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OrbMountParam* pInstance);
        static void Clean(OrbMountParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantCraneManagerSpawner {
        int32_t no;
        uint8_t row;
        uint8_t col;
        float gridSize;
        uint8_t correctableGrid;
        float craneSpeed;
        float armSpeed;
        float timeCatch;
        heur::rfl::CraneGrid cranePos;
        heur::rfl::CraneGrid orbPos[4];
        heur::rfl::OrbMountParam orbMount[4];
        heur::rfl::GimmickCameraOptionalParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantCraneManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantCraneManagerSpawner* pInstance);
        static void Clean(ObjGiantCraneManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantShieldSpawner {
        enum class VisualType : int8_t {
            Normal = 0,
            Broken = 1,
        };

        VisualType type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantShieldSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantShieldSpawner* pInstance);
        static void Clean(ObjGiantShieldSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLandSlideSpawner {
        int32_t dummy;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLandSlideSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLandSlideSpawner* pInstance);
        static void Clean(ObjLandSlideSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSandSmokeSpawner {
        enum class EffectColor : uint8_t {
            Yellow = 0,
            Red = 1,
            White = 2,
            NumColor = 3,
        };

        enum class AreaType : uint8_t {
            Circle = 0,
            Square = 1,
        };

        EffectColor color;
        AreaType areaType;
        csl::math::Vector3 size;
        float amount;
        float minDist;
        float duration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSandSmokeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSandSmokeSpawner* pInstance);
        static void Clean(ObjSandSmokeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossCloudSpawner {
        int32_t no;
        float distance;
        heur::rfl::VolumeTriggerSpawner volume;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossCloudSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossCloudSpawner* pInstance);
        static void Clean(ObjBossCloudSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBrokenRobotSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBrokenRobotSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBrokenRobotSpawner* pInstance);
        static void Clean(ObjBrokenRobotSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBumperSpawner {
        enum class BumperMark : int8_t {
            MarkStar = 0,
            MarkSircle = 1,
            MarkPlain = 2,
            MarkMax = 3,
        };

        BumperMark bumperMark;
        int32_t score;
        float impluse;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBumperSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBumperSpawner* pInstance);
        static void Clean(ObjBumperSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCrackGroundSpawner {
        enum class ModelType : int8_t {
            ModelType_1 = 0,
            ModelType_2 = 1,
        };

        ModelType type;
        csl::ut::MoveArray<hh::game::ObjectId> hiddenList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCrackGroundSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCrackGroundSpawner* pInstance);
        static void Clean(ObjCrackGroundSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDeviceControllerSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDeviceControllerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDeviceControllerSpawner* pInstance);
        static void Clean(ObjDeviceControllerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDiveSwitchSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDiveSwitchSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDiveSwitchSpawner* pInstance);
        static void Clean(ObjDiveSwitchSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDrawBridgeSpawner {
        int32_t no;
        float rotate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDrawBridgeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDrawBridgeSpawner* pInstance);
        static void Clean(ObjDrawBridgeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEnergyBallSpawner {
        int8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEnergyBallSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEnergyBallSpawner* pInstance);
        static void Clean(ObjEnergyBallSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEnergyBallLauncherSpawner {
        float speed;
        float gravity;
        float firstReflectionAngle;
        int32_t scoreThatGivesEnergy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEnergyBallLauncherSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEnergyBallLauncherSpawner* pInstance);
        static void Clean(ObjEnergyBallLauncherSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEnvAnalyzerSpawner {
        int32_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEnvAnalyzerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEnvAnalyzerSpawner* pInstance);
        static void Clean(ObjEnvAnalyzerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEruptionControlDeviceManagerredRingNodeUse {
        bool useNode[15];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEruptionControlDeviceManagerredRingNodeUse* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEruptionControlDeviceManagerredRingNodeUse* pInstance);
        static void Clean(ObjEruptionControlDeviceManagerredRingNodeUse* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEruptionControlDeviceManagerSpawner {
        uint32_t easyLvFailedCount[3];
        float speed;
        float gravity;
        float reflectDampingRatio;
        float reflectDampingSpeed;
        float maxSlope;
        float supportDistance;
        float slideDampingRatio;
        float slideDampingSpeedMin;
        int32_t maxBallCount;
        float firstReflectionAngle;
        int32_t scoreThatGivesEnergy;
        int32_t scoreOpenShutter;
        int32_t scoreThatRolloverBonus;
        int32_t ringCount2;
        int32_t ringCount4;
        int32_t ringCount8;
        int32_t ringCount16;
        int32_t ringCount32;
        int32_t ringCount64;
        int32_t ringCount128;
        int32_t ringCount256;
        float startDuration;
        float restartDuration;
        float clearedDuration;
        float failedDuration;
        float redRingDuration[3];
        int32_t scoreRedRing;
        int32_t countRedRing;
        uint32_t impluseCountFluctuation;
        float fluctuationAngle;
        csl::ut::MoveArray<hh::game::ObjectId> childs;
        csl::ut::MoveArray<hh::game::ObjectId> childsAfterClearing;
        csl::ut::MoveArray<hh::game::ObjectId> redRingNodeList;
        heur::rfl::ObjEruptionControlDeviceManagerredRingNodeUse redRingUsePattern[9];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEruptionControlDeviceManagerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEruptionControlDeviceManagerSpawner* pInstance);
        static void Clean(ObjEruptionControlDeviceManagerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFlipperSpawner {
        enum class RotateDirection : int8_t {
            Left = 0,
            Right = 1,
        };

        RotateDirection rotateDirection;
        float maxMovableAngle;
        float flipUpTime;
        float apexLaunchAngle;
        float axisLaunchAngle;
        float apexSpeed;
        float axisSpeed;
        float axisReflectionSpeedMin;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFlipperSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFlipperSpawner* pInstance);
        static void Clean(ObjFlipperSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentSpawner_FvParam {
        hh::game::ObjectId startPosition;
        csl::ut::VariableString fvShieldPathName;
        hh::game::ObjectId camera;
        float shieldSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentSpawner_FvParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentSpawner_FvParam* pInstance);
        static void Clean(ObjKnightIncidentSpawner_FvParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentSpawner_EventFirstParam {
        hh::game::ObjectId position;
        hh::game::ObjectId lookAt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentSpawner_EventFirstParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentSpawner_EventFirstParam* pInstance);
        static void Clean(ObjKnightIncidentSpawner_EventFirstParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentSpawner_EventEndParam {
        hh::game::ObjectId position;
        hh::game::ObjectId lookAt;
        float endDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentSpawner_EventEndParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentSpawner_EventEndParam* pInstance);
        static void Clean(ObjKnightIncidentSpawner_EventEndParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentSpawner_EventRetryParam {
        hh::game::ObjectId position;
        hh::game::ObjectId lookAt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentSpawner_EventRetryParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentSpawner_EventRetryParam* pInstance);
        static void Clean(ObjKnightIncidentSpawner_EventRetryParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentSpawner_FlyerParam {
        hh::game::ObjectId flyer;
        csl::ut::VariableString pathName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentSpawner_FlyerParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentSpawner_FlyerParam* pInstance);
        static void Clean(ObjKnightIncidentSpawner_FlyerParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentSpawner_ShieldPresetParam {
        csl::math::Vector3 launchOffset;
        csl::math::Vector3 approachOffset;
        float approachSpeed;
        csl::math::Vector3 attackOffset;
        float attackSpeed;
        float attackReadyTime;
        float attackTime;
        csl::math::Vector3 finishOffset;
        float finishSpeed;
        float rotationY;
        float forceOfBoost;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentSpawner_ShieldPresetParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentSpawner_ShieldPresetParam* pInstance);
        static void Clean(ObjKnightIncidentSpawner_ShieldPresetParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentSpawner_ShieldCommonParam {
        heur::rfl::ObjKnightIncidentSpawner_ShieldPresetParam presets[6];
        float collisionRadius;
        uint32_t damageRings;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentSpawner_ShieldCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentSpawner_ShieldCommonParam* pInstance);
        static void Clean(ObjKnightIncidentSpawner_ShieldCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentSpawner {
        heur::rfl::ObjKnightIncidentSpawner_FvParam fv;
        heur::rfl::ObjKnightIncidentSpawner_EventFirstParam eventFirst;
        heur::rfl::ObjKnightIncidentSpawner_EventEndParam eventEnd;
        heur::rfl::ObjKnightIncidentSpawner_EventRetryParam eventRetry;
        heur::rfl::ObjKnightIncidentSpawner_FlyerParam flyer;
        heur::rfl::ObjKnightIncidentSpawner_ShieldCommonParam shield;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentSpawner* pInstance);
        static void Clean(ObjKnightIncidentSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_PathLoopInfo {
        bool enable;
        float start;
        float end;
        hh::game::ObjectId cameraActivator;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_PathLoopInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_PathLoopInfo* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_PathLoopInfo* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam_HoleParam {
        float start;
        float end;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam_HoleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam_HoleParam* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam_HoleParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam_TrailParam {
        float interval;
        int32_t recordNum;
        float width;
        float wallHeight;
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam_HoleParam holes[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam_TrailParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam_TrailParam* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam_TrailParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData_OneBullet {
        float vert;
        float initSpeed;
        float maxSpeed;
        float acc;
        float lifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData_OneBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData_OneBullet* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData_OneBullet* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData {
        bool enabled;
        float shotAnimSpeed;
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData_OneBullet oneBullet[6];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam {
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam_TableData posTable[16];
        float readyDuration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_CameraParam {
        float fovy;
        float distance;
        float azimuth;
        float elevation;
        float limitRightRatio;
        float limitLeftRatio;
        float upScrollRatio;
        float limitUpScrollDistance;
        float downScrollRatio;
        float limitDownScrollDistance;
        bool isLimitPathDistance;
        float limitPathDistanceMin;
        float limitPathDistanceMax;
        bool isSmoothPath;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_CameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_CameraParam* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_CameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_QuickStepParam {
        bool enable;
        float speed;
        float boostSpeed;
        float boostSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_QuickStepParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_QuickStepParam* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_QuickStepParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam {
        float startSpeed;
        float decrease;
        float minSpeed;
        float targetDisableTime;
        float resetByFallTime;
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_ShotParam shot;
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_CameraParam camera;
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam_QuickStepParam quickStep;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner_ConfigParam {
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam_TrailParam trail;
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam_EscapeParam escape;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner_ConfigParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner_ConfigParam* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner_ConfigParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentFlyerSpawner {
        csl::ut::VariableString pathName;
        heur::rfl::ObjKnightIncidentFlyerSpawner_PathLoopInfo loopInfo[5];
        int32_t no;
        heur::rfl::ObjKnightIncidentFlyerSpawner_ConfigParam config;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentFlyerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentFlyerSpawner* pInstance);
        static void Clean(ObjKnightIncidentFlyerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentShieldSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentShieldSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentShieldSpawner* pInstance);
        static void Clean(ObjKnightIncidentShieldSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentShieldFvSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentShieldFvSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentShieldFvSpawner* pInstance);
        static void Clean(ObjKnightIncidentShieldFvSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKnightIncidentShieldTriggerSpawner {
        hh::game::ObjectId knightIncident;
        uint32_t preset;
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKnightIncidentShieldTriggerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKnightIncidentShieldTriggerSpawner* pInstance);
        static void Clean(ObjKnightIncidentShieldTriggerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPinballDecorationSpawner {
        enum class Type : int8_t {
            TypeA = 0,
            TypeB = 1,
            TypeC = 2,
        };

        Type type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPinballDecorationSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPinballDecorationSpawner* pInstance);
        static void Clean(ObjPinballDecorationSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPinballReverseSpawner {
        enum class Type : int8_t {
            TypeAL = 0,
            TypeAR = 1,
            TypeB = 2,
        };

        Type type;
        float impluse;
        float offsetYColli;
        float relightingTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPinballReverseSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPinballReverseSpawner* pInstance);
        static void Clean(ObjPinballReverseSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPinballRedRingSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPinballRedRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPinballRedRingSpawner* pInstance);
        static void Clean(ObjPinballRedRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPinballRingSpawner {
        enum class SetType : int8_t {
            EquallySpaced = 0,
            NodeID = 1,
        };

        int32_t score;
        float respawnTime;
        csl::ut::VariableString pathName;
        SetType setType;
        int8_t num;
        csl::ut::MoveArray<hh::game::ObjectId> setNodeList;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPinballRingSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPinballRingSpawner* pInstance);
        static void Clean(ObjPinballRingSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPinballShutterSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPinballShutterSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPinballShutterSpawner* pInstance);
        static void Clean(ObjPinballShutterSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRolloverSpawner {
        enum class InOutLane : int8_t {
            InLnae = 0,
            OutLane = 1,
        };

        int32_t id;
        InOutLane inOutLane;
        int32_t score;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRolloverSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRolloverSpawner* pInstance);
        static void Clean(ObjRolloverSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSlingshotSpawner {
        int32_t score;
        float impluse;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSlingshotSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSlingshotSpawner* pInstance);
        static void Clean(ObjSlingshotSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjVolcanicEruptionSpawner {
        int32_t type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjVolcanicEruptionSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjVolcanicEruptionSpawner* pInstance);
        static void Clean(ObjVolcanicEruptionSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAmbSoundResearcherSpawner {
        float width;
        float height;
        float depth;
        float gridInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAmbSoundResearcherSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAmbSoundResearcherSpawner* pInstance);
        static void Clean(ObjAmbSoundResearcherSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAmbSoundTestMaterialSpawner {
        enum class Material : int8_t {
            MATERIAL_GRASS = 0,
            MATERIAL_WATER = 1,
            NUM_MATERIALS = 2,
        };

        Material material;
        float width;
        float height;
        float depth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAmbSoundTestMaterialSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAmbSoundTestMaterialSpawner* pInstance);
        static void Clean(ObjAmbSoundTestMaterialSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct AnimatorTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AnimatorTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AnimatorTestSpawner* pInstance);
        static void Clean(AnimatorTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct AnimatorTest2Spawner {
        float speed;
        float lr;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AnimatorTest2Spawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AnimatorTest2Spawner* pInstance);
        static void Clean(AnimatorTest2Spawner* pInstance);
    };
}

namespace heur::rfl {
    struct AttractionMoveParam {
        enum class MoveType : int8_t {
            MoveNone = 0,
            MoveStraight = 1,
            MoveRotate = 2,
        };

        MoveType type;
        float distance;
        float cycle;
        csl::math::Vector3 axis;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AttractionMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AttractionMoveParam* pInstance);
        static void Clean(AttractionMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAttractionTestSpawner {
        float weight;
        float size;
        float radius;
        float tolerance;
        float force;
        float maxSpeed;
        float enabledTime;
        float disabledTime;
        heur::rfl::AttractionMoveParam move;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAttractionTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAttractionTestSpawner* pInstance);
        static void Clean(ObjAttractionTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAuraTrainTestRoot {
        csl::ut::VariableString pathName;
        hh::game::ObjectId cameraUuid;
        float cameraEaseInTime;
        float cameraEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAuraTrainTestRoot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAuraTrainTestRoot* pInstance);
        static void Clean(ObjAuraTrainTestRoot* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAuraTrainTestSpawner {
        heur::rfl::ObjAuraTrainTestRoot roots[3];
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAuraTrainTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAuraTrainTestSpawner* pInstance);
        static void Clean(ObjAuraTrainTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossAttackTestSpawner {
        enum class AttackType : int8_t {
            ATTACK_TYPE_MISSILE = 0,
            ATTACK_TYPE_THUNDER = 1,
            ATTACK_TYPE_THORN_BALL = 2,
            ATTACK_TYPE_GROUND_WAVE = 3,
        };

        float activateDistance;
        float diactivateDistance;
        AttackType attackType;
        float cycle;
        float phase;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossAttackTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossAttackTestSpawner* pInstance);
        static void Clean(ObjBossAttackTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossDecoySpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossDecoySpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossDecoySpawner* pInstance);
        static void Clean(ObjBossDecoySpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossRushTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossRushTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossRushTestSpawner* pInstance);
        static void Clean(ObjBossRushTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossShakeCameraTestSpawner {
        enum class ShakeType : int8_t {
            MINI = 0,
            SMALL = 1,
            MIDDLE = 2,
            LARGE = 3,
            EX_LARGE = 4,
        };

        ShakeType type;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossShakeCameraTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossShakeCameraTestSpawner* pInstance);
        static void Clean(ObjBossShakeCameraTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBulletHoleTestSpawner {
        float scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBulletHoleTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBulletHoleTestSpawner* pInstance);
        static void Clean(ObjBulletHoleTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMultiFocusCameraTestSpawner {
        hh::game::ObjectId farLookAt;
        hh::game::ObjectId nearLookAt;
        csl::math::Vector3 farOffset;
        csl::math::Vector3 nearOffset;
        float distance;
        float offsetDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMultiFocusCameraTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMultiFocusCameraTestSpawner* pInstance);
        static void Clean(ObjMultiFocusCameraTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraBehaviorDemoSpawner {
        enum class CameraType : int8_t {
            CAMERA_NORMAL = 0,
            CAMERA_SIMPLE = 1,
            CAMERA_POINT = 2,
        };

        CameraType cameraType;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraBehaviorDemoSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraBehaviorDemoSpawner* pInstance);
        static void Clean(ObjCameraBehaviorDemoSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCameraResetTestSpawner {
        enum class Type : int8_t {
            Standard = 0,
            LookAt = 1,
            Direction = 2,
        };

        Type type;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCameraResetTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCameraResetTestSpawner* pInstance);
        static void Clean(ObjCameraResetTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCharacterActionGuideTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCharacterActionGuideTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCharacterActionGuideTestSpawner* pInstance);
        static void Clean(ObjCharacterActionGuideTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct CharacterRbTestSpawner {
        enum class MoveSystem : int8_t {
            Stairs = 0,
            Slide = 1,
            Linear = 2,
            Simple = 3,
        };

        enum class QueryMode : int8_t {
            Sweep = 0,
            Raycast = 1,
            RaycastDisk = 2,
            None = 3,
        };

        float speed;
        float gravity;
        float supportDistance;
        bool appControl;
        MoveSystem moveSystem;
        QueryMode queryMode;
        bool useCache;
        bool onlyHeightField;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CharacterRbTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CharacterRbTestSpawner* pInstance);
        static void Clean(CharacterRbTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjColliderQueryTestSpawner {
        enum class ShapeType : int8_t {
            SPHERE = 0,
            MOVE_SPHERE = 1,
            CAPSULE = 2,
        };

        ShapeType shape;
        float width;
        float height;
        bool hitbits[32];
        bool triggers[3];
        bool outputLog;
        bool outputScreen;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjColliderQueryTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjColliderQueryTestSpawner* pInstance);
        static void Clean(ObjColliderQueryTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjColliderTestSpawner {
        enum class ShapeType : int8_t {
            SPHERE = 0,
            CAPSULE = 1,
            CYLINDER = 2,
            BOX = 3,
        };

        enum class LayerType : int8_t {
            NONE = 0,
            SOLID = 1,
            LIQUID = 2,
            THROUGH = 3,
            CAMERA = 4,
            SOLID_ONEWAY = 5,
            SOLID_THROUGH = 6,
            SOLID_TINY = 7,
            SOLID_DETAIL = 8,
            LEAF = 9,
            LAND = 10,
            RAYBLOCK = 11,
            EVENT = 12,
            RESERVED13 = 13,
            RESERVED14 = 14,
            PLAYER = 15,
            ENEMY = 16,
            ENEMY_BODY = 17,
            GIMMICK = 18,
            DYNAMICS = 19,
            RING = 20,
            CHARACTER_CONTROL = 21,
            PLAYER_ONLY = 22,
            DYNAMICS_THROUGH = 23,
            ENEMY_ONLY = 24,
            SENSOR_PLAYER = 25,
            SENSOR_RING = 26,
            SENSOR_GIMMICK = 27,
            SENSOR_LAND = 28,
            SENSOR_ALL = 29,
            RESERVED30 = 30,
            RESERVED31 = 31,
        };

        ShapeType shape;
        float width;
        float height;
        float depth;
        LayerType layer;
        bool hitbits[32];
        bool triggers[3];
        bool outputLog;
        bool outputScreen;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjColliderTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjColliderTestSpawner* pInstance);
        static void Clean(ObjColliderTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCompassTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCompassTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCompassTestSpawner* pInstance);
        static void Clean(ObjCompassTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjContactTestSpawner {
        csl::math::Vector3 localOffset;
        bool compassEnabled;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjContactTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjContactTestSpawner* pInstance);
        static void Clean(ObjContactTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCyBlasterTestSpawner {
        csl::math::Vector3 releaseVel;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCyBlasterTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCyBlasterTestSpawner* pInstance);
        static void Clean(ObjCyBlasterTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct WhiteFlow {
        float m_circleRadius;
        float m_uvScrollSpeed;
        float m_twistShift;
        float m_flowSpeed;
        float m_rollOffset;
        float m_waveOffset;
        csl::math::Vector2 m_scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WhiteFlow* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WhiteFlow* pInstance);
        static void Clean(WhiteFlow* pInstance);
    };
}

namespace heur::rfl {
    struct BlackFlow {
        float m_circleRadius;
        float m_uvScrollSpeed;
        float m_flowSpeed;
        float m_twistShift;
        float m_rollOffset;
        float m_waveOffset;
        float m_alphaThreshold;
        float m_uvCell1Scale;
        csl::math::Vector2 m_uvCell1Speed;
        float m_uvCell2Scale;
        csl::math::Vector2 m_uvCell2Speed;
        csl::math::Vector2 m_uvLineScale;
        csl::math::Vector2 m_scale;
        csl::ut::Colorf m_color;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BlackFlow* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BlackFlow* pInstance);
        static void Clean(BlackFlow* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCyloopSlashTestSpawner {
        float m_circleVertices;
        csl::ut::Colorf m_colorA;
        csl::ut::Colorf m_colorB;
        float m_flowLuminance;
        heur::rfl::WhiteFlow m_whiteFlow[3];
        heur::rfl::BlackFlow m_blackFlow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCyloopSlashTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCyloopSlashTestSpawner* pInstance);
        static void Clean(ObjCyloopSlashTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCyloopTestSpawner {
        bool collisionEnabled;
        float collisionRadius;
        float collisionHeight;
        float cyloopRadius;
        float targetOffsetUp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCyloopTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCyloopTestSpawner* pInstance);
        static void Clean(ObjCyloopTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDamageTestDefence {
        enum class Reaction : int8_t {
            Hit = 0,
            Dead = 1,
            Avoid = 2,
            Guard = 3,
            Guard_Avoid = 4,
            Guard_Flip = 5,
            Parry = 6,
        };

        enum class Status : int8_t {
            Usual = 0,
            Stunned = 1,
            Staggered = 2,
            Change = 3,
        };

        Reaction reaction;
        Status status;
        float maxStunPoint;
        float stunnedTime;
        float maxStaggerPoint;
        float staggeredTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDamageTestDefence* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDamageTestDefence* pInstance);
        static void Clean(ObjDamageTestDefence* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDamageTestAttack {
        enum class Attribute : int8_t {
            Normal = 0,
            BlowOff = 1,
            Quake = 2,
            Killing = 3,
            OnlyParry = 4,
        };

        enum class ParryType : int8_t {
            Disabled = 0,
            Enabled = 1,
            Enabled_Slow = 2,
            Enabled_Just = 3,
            Enabled_SlowAndJust = 4,
        };

        enum class Kind : int16_t {
            InvalidKind = -1,
            Dead_BattleJellymanLv1 = 0,
            Dead_BattleJellymanLv2 = 1,
            Dead_BattleJellymanLv3 = 2,
            Dead_BattleJellymanLv4 = 3,
            Dead_BattleWolf = 4,
            Dead_BattleBird = 5,
            Dead_BattleSniper = 6,
            Dead_BattleTwister = 7,
            Dead_BattleBommer = 8,
            Dead_BattleBubble = 9,
            Dead_BattleDefender = 10,
            Dead_BattleUmbrella = 11,
            Dead_BattleAquaBall = 12,
            Dead_BattleJumper = 13,
            Dead_BattleBladeLv1 = 14,
            Dead_BattleBladeLv2 = 15,
            Dead_BattleBladeLv3 = 16,
            Dead_BattleBladeLv4 = 17,
            Dead_BattleDarumaLv1 = 18,
            Dead_BattleDarumaLv2 = 19,
            Dead_BattleDarumaLv3 = 20,
            Dead_BattleDarumaLv4 = 21,
            Dead_BattleSpider = 22,
            Dead_BattleCharger = 23,
            Dead_BattleFlyer = 24,
            Dead_BattleTracker = 25,
            Dead_BattleAsura = 26,
            Dead_BattleSkier = 27,
            Dead_BattleTyrant = 28,
            Dead_BattleSumo = 29,
            Dead_BattleStrider = 30,
            Dead_BattleWarship = 31,
            Dead_BattleGiantFC = 32,
            Dead_BattleGiantClimb = 33,
            Dead_BattleGiant = 34,
            Dead_BattleDragonFC = 35,
            Dead_BattleDragonClimb = 36,
            Dead_BattleDragon = 37,
            Dead_BattleKnightFC = 38,
            Dead_BattleKnightClimb = 39,
            Dead_BattleKnight = 40,
            Dead_BattleRifle = 41,
            Dead_BattleTheEnd = 42,
            Dead_Gimmick = 43,
            Dead_Fall = 44,
            Dead_Water = 45,
            Dead_Lava = 46,
            Failed_QuestKodamaCollect1 = 47,
            Failed_QuestMowingGrass = 48,
            Failed_QuestKodamaEscort = 49,
            Failed_QuestKodamaCollect2 = 50,
            Failed_QuestDarumaBattle = 51,
            Failed_QuestCollectItem = 52,
            Failed_QuestDrawBridge = 53,
            Failed_PinBall = 54,
            Failed_Hacking = 55,
            Transit_ToIsland = 56,
            Transit_ToCyber = 57,
            Transit_ToFishing = 58,
            Transit_ToHacking = 59,
            Transit_ToTheEnd = 60,
            Transit_ToSkill1 = 61,
            Transit_ToSkill2 = 62,
            Transit_ToSkill3 = 63,
            Transit_ToSkill4 = 64,
            Transit_ToSkill5 = 65,
            Transit_ToSkill6 = 66,
            Transit_ToSkill7 = 67,
            Transit_ToSkill8 = 68,
            Transit_ToSkill9 = 69,
            Transit_ToSkill10 = 70,
            Transit_ToSkill11 = 71,
            Transit_ToSkill12 = 72,
            Transit_ToSkill13 = 73,
            Transit_ToSkill14 = 74,
            Transit_ToSkill15 = 75,
            Transit_ToSkill16 = 76,
            Transit_ToSkill17 = 77,
            Transit_ToSkill18 = 78,
            Transit_ToSkill19 = 79,
            Transit_ToSkill20 = 80,
            BattleRifleBeast_Fase3_Cable = 81,
            BattleRifleBeast_Fase3_Parry = 82,
            BattleRifleBeast_Fase3_Down = 83,
            BattleRifleBeast_Fase4 = 84,
            TransitAmy_ToSkill1 = 85,
            TransitAmy_ToSkill2 = 86,
            TransitAmy_ToSkill3 = 87,
            TransitAmy_ToSkill4 = 88,
            TransitAmy_ToSkill5 = 89,
            TransitAmy_ToSkill6 = 90,
            TransitAmy_ToSkill7 = 91,
            TransitAmy_ToSkill8 = 92,
            TransitAmy_ToSkill9 = 93,
            TransitAmy_ToSkill10 = 94,
            TransitAmy_ToSkill11 = 95,
            TransitAmy_ToSkill12 = 96,
            TransitAmy_ToSkill13 = 97,
            TransitAmy_ToSkill14 = 98,
            TransitAmy_ToSkill15 = 99,
            TransitAmy_ToSkill16 = 100,
            TransitAmy_ToSkill17 = 101,
            TransitAmy_ToSkill18 = 102,
            TransitAmy_ToSkill19 = 103,
            TransitAmy_ToSkill20 = 104,
            DeadAmy_BattleBlade = 105,
            DeadAmy_BattleDaruma = 106,
            DeadAmy_BattleCharger = 107,
            DeadAmy_BattleSpider = 108,
            DeadAmy_BattleTracker = 109,
            DeadAmy_BattleTyrant = 110,
            DeadAmy_Gimmick = 111,
            DeadAmy_Fall = 112,
            DeadAmy_Water = 113,
            TransitKnuckles_ToSkill1 = 114,
            TransitKnuckles_ToSkill2 = 115,
            TransitKnuckles_ToSkill3 = 116,
            TransitKnuckles_ToSkill4 = 117,
            TransitKnuckles_ToSkill5 = 118,
            TransitKnuckles_ToSkill6 = 119,
            TransitKnuckles_ToSkill7 = 120,
            TransitKnuckles_ToSkill8 = 121,
            TransitKnuckles_ToSkill9 = 122,
            TransitKnuckles_ToSkill10 = 123,
            TransitKnuckles_ToSkill11 = 124,
            TransitKnuckles_ToSkill12 = 125,
            TransitKnuckles_ToSkill13 = 126,
            TransitKnuckles_ToSkill14 = 127,
            TransitKnuckles_ToSkill15 = 128,
            TransitKnuckles_ToSkill16 = 129,
            TransitKnuckles_ToSkill17 = 130,
            TransitKnuckles_ToSkill18 = 131,
            TransitKnuckles_ToSkill19 = 132,
            TransitKnuckles_ToSkill20 = 133,
            DeadKnuckles_BattleBlade = 134,
            DeadKnuckles_BattleDaruma = 135,
            DeadKnuckles_BattleCharger = 136,
            DeadKnuckles_BattleSpider = 137,
            DeadKnuckles_BattleTracker = 138,
            DeadKnuckles_BattleTyrant = 139,
            DeadKnuckles_Gimmick = 140,
            DeadKnuckles_Fall = 141,
            DeadKnuckles_Water = 142,
            TransitTails_ToSkill1 = 143,
            TransitTails_ToSkill2 = 144,
            TransitTails_ToSkill3 = 145,
            TransitTails_ToSkill4 = 146,
            TransitTails_ToSkill5 = 147,
            TransitTails_ToSkill6 = 148,
            TransitTails_ToSkill7 = 149,
            TransitTails_ToSkill8 = 150,
            TransitTails_ToSkill9 = 151,
            TransitTails_ToSkill10 = 152,
            TransitTails_ToSkill11 = 153,
            TransitTails_ToSkill12 = 154,
            TransitTails_ToSkill13 = 155,
            TransitTails_ToSkill14 = 156,
            TransitTails_ToSkill15 = 157,
            TransitTails_ToSkill16 = 158,
            TransitTails_ToSkill17 = 159,
            TransitTails_ToSkill18 = 160,
            TransitTails_ToSkill19 = 161,
            TransitTails_ToSkill20 = 162,
            DeadTails_BattleBlade = 163,
            DeadTails_BattleDaruma = 164,
            DeadTails_BattleCharger = 165,
            DeadTails_BattleSpider = 166,
            DeadTails_BattleTracker = 167,
            DeadTails_BattleTyrant = 168,
            DeadTails_Gimmick = 169,
            DeadTails_Fall = 170,
            DeadTails_Water = 171,
            DeadSonic_BattleBlade = 172,
            DeadSonic_BattleDaruma = 173,
            DeadSonic_BattleCharger = 174,
            DeadSonic_BattleSpider = 175,
            DeadSonic_BattleTracker = 176,
            DeadSonic_BattleTyrant = 177,
            DeadSonic_Gimmick = 178,
            DeadSonic_Fall = 179,
            DeadSonic_Water = 180,
            NumKinds = 181,
        };

        bool enabled;
        float waitTime;
        int32_t damagePoint;
        Attribute attribute;
        bool counterSmash;
        csl::math::Vector3 velocity;
        ParryType parryType;
        bool parrySpecialCamera;
        Kind practice;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDamageTestAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDamageTestAttack* pInstance);
        static void Clean(ObjDamageTestAttack* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDamageTestSpawner {
        heur::rfl::ObjDamageTestDefence defence;
        heur::rfl::ObjDamageTestAttack attack;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDamageTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDamageTestSpawner* pInstance);
        static void Clean(ObjDamageTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct DebrisTestCommonParam {
        float gravityPow;
        float lifeTime;
        float weight;
        float friction;
        float restitution;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DebrisTestCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DebrisTestCommonParam* pInstance);
        static void Clean(DebrisTestCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct DebrisTestImpulseVelInfo {
        csl::math::Vector3 contactPoint;
        csl::math::Vector3 direction;
        float force;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DebrisTestImpulseVelInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DebrisTestImpulseVelInfo* pInstance);
        static void Clean(DebrisTestImpulseVelInfo* pInstance);
    };
}

namespace heur::rfl {
    struct DebrisTestExplosionVelInfo {
        csl::math::Vector3 explosionPoint;
        float explosionForce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DebrisTestExplosionVelInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DebrisTestExplosionVelInfo* pInstance);
        static void Clean(DebrisTestExplosionVelInfo* pInstance);
    };
}

namespace heur::rfl {
    struct DebrisTestRotationInfo {
        float defaultMaxAngle;
        float maxAngularVelocity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DebrisTestRotationInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DebrisTestRotationInfo* pInstance);
        static void Clean(DebrisTestRotationInfo* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDebrisTestSpawner {
        heur::rfl::DebrisTestCommonParam commonParam;
        heur::rfl::DebrisTestImpulseVelInfo impulseVelInfo;
        heur::rfl::DebrisTestExplosionVelInfo expolsionVelInfo;
        heur::rfl::DebrisTestRotationInfo rotationInfo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDebrisTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDebrisTestSpawner* pInstance);
        static void Clean(ObjDebrisTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDeformableFieldSpawner {
        float width;
        uint32_t numV;
        uint32_t numH;
        float spreadSpeed;
        float damper;
        float hitReactionDistance;
        float hitAffectDistance;
        bool moveVertex;
        bool moveTransform;
        bool attrMovable;
        bool attrParkour;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDeformableFieldSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDeformableFieldSpawner* pInstance);
        static void Clean(ObjDeformableFieldSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDependChildTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDependChildTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDependChildTestSpawner* pInstance);
        static void Clean(ObjDependChildTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDependParentTestSpawner {
        csl::ut::MoveArray<hh::game::ObjectId> childs;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDependParentTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDependParentTestSpawner* pInstance);
        static void Clean(ObjDependParentTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjDestinationTestSpawner {
        csl::math::Vector3 localOffset;
        float tolerance;
        bool useObjectID;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjDestinationTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjDestinationTestSpawner* pInstance);
        static void Clean(ObjDestinationTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEasingTestSpawner {
        enum class EasingType : int8_t {
            EASE_IN = 0,
            EASE_OUT = 1,
            EASE_INOUT = 2,
        };

        enum class CalculateType : int8_t {
            LINEAR = 0,
            QUADRATIC = 1,
            CUBIC = 2,
            QUARTIC = 3,
            QUINTIC = 4,
            SIN = 5,
            EXPONENTIAL = 6,
            CIRCULAR = 7,
            BACK = 8,
            BOUNCE = 9,
            ELASTIC = 10,
        };

        enum class ParamType : int8_t {
            PARAM_ONE = 0,
            PARAM_INV_ONE = 1,
            PARAM_HALF = 2,
            PARAM_INV_HALF = 3,
            PARAM_DOUBLE = 4,
            PARAM_INV_DOUBLE = 5,
        };

        enum class OperationType : int8_t {
            OP_NONE = 0,
            OP_ADD = 1,
            OP_SUB = 2,
            OP_MULTI = 3,
            OP_NEST = 4,
        };

        EasingType m_ease1;
        CalculateType m_calc1;
        ParamType m_param1;
        EasingType m_ease2;
        CalculateType m_calc2;
        ParamType m_param2;
        OperationType m_op;
        float m_previewTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEasingTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEasingTestSpawner* pInstance);
        static void Clean(ObjEasingTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MoveParam {
        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_CONSTANT = 1,
            MOVE_ROTATE = 2,
        };

        MoveType type;
        float distance;
        float cycle;
        csl::math::Vector3 axis;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MoveParam* pInstance);
        static void Clean(MoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEffectTestSpawner {
        csl::ut::VariableString name;
        float cycle;
        csl::math::Vector3 offset;
        heur::rfl::MoveParam move;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEffectTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEffectTestSpawner* pInstance);
        static void Clean(ObjEffectTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct EventPlayTestParam {
        enum class StartType : uint8_t {
            Stand = 0,
            Fixed = 1,
            Frozen = 2,
        };

        csl::ut::VariableString eventName;
        bool setRootMatrix;
        bool noUnload;
        StartType playerStartType;
        float cameraInterpolateTime;
        bool setCameraLookAt;
        csl::math::Vector3 cameraLookAt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EventPlayTestParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EventPlayTestParam* pInstance);
        static void Clean(EventPlayTestParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEventPlayTestSpawner {
        bool eventDriven;
        bool preload;
        heur::rfl::EventPlayTestParam param;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEventPlayTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEventPlayTestSpawner* pInstance);
        static void Clean(ObjEventPlayTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjExternalControlTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjExternalControlTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjExternalControlTestSpawner* pInstance);
        static void Clean(ObjExternalControlTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFlipMouthTestSpawner {
        bool autoFlip;
        bool forceFlip;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFlipMouthTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFlipMouthTestSpawner* pInstance);
        static void Clean(ObjFlipMouthTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFlowDustTestSpawner {
        bool wind;
        float emitInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFlowDustTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFlowDustTestSpawner* pInstance);
        static void Clean(ObjFlowDustTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFxParamChangerSpawner {
        enum class InterpolateType : int8_t {
            LINEAR = 0,
            SIN_CURVE = 1,
        };

        uint32_t sourceParamNo;
        uint32_t targetParamNo;
        float time;
        InterpolateType interpolateType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFxParamChangerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFxParamChangerSpawner* pInstance);
        static void Clean(ObjFxParamChangerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGeometrizeBillboardTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGeometrizeBillboardTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGeometrizeBillboardTestSpawner* pInstance);
        static void Clean(ObjGeometrizeBillboardTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGeometrizeTestSpawner {
        enum class Shape : int32_t {
            Polyline = 0,
            Tube = 1,
        };

        enum class RenderPreset : int32_t {
            Opaque = 0,
            Transparent = 1,
            Add = 2,
        };

        enum class Coord : int8_t {
            World = 0,
            Local = 1,
        };

        enum class NodeCoord : int8_t {
            NodeWorldAuto = 0,
            NodeLocal = 1,
        };

        Shape m_shape;
        RenderPreset m_preset;
        Coord m_coord;
        NodeCoord m_nodeCoord;
        int32_t m_numSegments;
        float m_segmentDistance;
        float m_maxDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGeometrizeTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGeometrizeTestSpawner* pInstance);
        static void Clean(ObjGeometrizeTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGeometryInstanceTestSpawner {
        uint32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGeometryInstanceTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGeometryInstanceTestSpawner* pInstance);
        static void Clean(ObjGeometryInstanceTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGiantGTestSpawner {
        float scale;
        float moveSpeed;
        float moveDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGiantGTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGiantGTestSpawner* pInstance);
        static void Clean(ObjGiantGTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGimmickScriptTestSpawner {
        int32_t no;
        csl::ut::VariableString luaName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGimmickScriptTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGimmickScriptTestSpawner* pInstance);
        static void Clean(ObjGimmickScriptTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGrindTestSpawner {
        float length;
        float cycle;
        bool closed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGrindTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGrindTestSpawner* pInstance);
        static void Clean(ObjGrindTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHeightCheckerSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHeightCheckerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHeightCheckerSpawner* pInstance);
        static void Clean(ObjHeightCheckerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHeightFieldTestSpawner {
        csl::ut::VariableString resFile;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHeightFieldTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHeightFieldTestSpawner* pInstance);
        static void Clean(ObjHeightFieldTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHomingTargetTestSpawner {
        float phantomSize;
        bool hasPhantom;
        float rigidbodySize;
        bool hasRigidbody;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHomingTargetTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHomingTargetTestSpawner* pInstance);
        static void Clean(ObjHomingTargetTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct HsmTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HsmTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HsmTestSpawner* pInstance);
        static void Clean(HsmTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFootIKTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFootIKTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFootIKTestSpawner* pInstance);
        static void Clean(ObjFootIKTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLevitateTestSpawner {
        enum class Shape : int8_t {
            Sphere = 0,
            Box = 1,
        };

        float height;
        Shape shape;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLevitateTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLevitateTestSpawner* pInstance);
        static void Clean(ObjLevitateTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLookAtTargetTestSpawner {
        csl::ut::VariableString objectName;
        float runningTime;
        float idleTime;
        float easeInTime;
        float easeOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLookAtTargetTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLookAtTargetTestSpawner* pInstance);
        static void Clean(ObjLookAtTargetTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLuaTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLuaTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLuaTestSpawner* pInstance);
        static void Clean(ObjLuaTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMaterialTestSpawner {
        float radius;
        float intervalDist;
        float intervalAngle;
        float rayLength;
        bool tracePlayer;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMaterialTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMaterialTestSpawner* pInstance);
        static void Clean(ObjMaterialTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMessageTestSpawner {
        hh::game::ObjectId receiver;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMessageTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMessageTestSpawner* pInstance);
        static void Clean(ObjMessageTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMissileLauncherSpawner {
        enum class MissileMoveType : int8_t {
            Straight = 0,
            Homing = 1,
        };

        MissileMoveType moveType;
        uint8_t maxShotCount;
        float shotInterval;
        float waitTime;
        float storeDist;
        float maxMoveSpeed;
        float minMoveSpeed;
        float explosionRadius;
        float explosionDuration;
        float rotateSpeedMax;
        float rotateSpeedMin;
        float eyesightAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMissileLauncherSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMissileLauncherSpawner* pInstance);
        static void Clean(ObjMissileLauncherSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMockSpawner {
        enum class Kind : int8_t {
            PuzzleSmall = 0,
            PuzzleMiddle = 1,
            PuzzleLarge = 2,
            EnemyCrowd = 3,
            BossSmall = 4,
            Boss = 5,
            Portal = 6,
            Num = 7,
        };

        Kind m_kind;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMockSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMockSpawner* pInstance);
        static void Clean(ObjMockSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMotionBlendCameraTestSpawner {
        csl::ut::VariableString resource0;
        csl::ut::VariableString resource1;
        csl::ut::VariableString resource2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMotionBlendCameraTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMotionBlendCameraTestSpawner* pInstance);
        static void Clean(ObjMotionBlendCameraTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMotionCameraTestSpawner {
        csl::ut::VariableString resource;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMotionCameraTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMotionCameraTestSpawner* pInstance);
        static void Clean(ObjMotionCameraTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMovieTestSpawner {
        csl::ut::VariableString name;
        int8_t audioTrackNo;
        int8_t subAudioTrackNo;
        int8_t extraAudioTrackNo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMovieTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMovieTestSpawner* pInstance);
        static void Clean(ObjMovieTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNarrationTestSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNarrationTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNarrationTestSpawner* pInstance);
        static void Clean(ObjNarrationTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct NaviPathData {
        csl::ut::VariableString pathName;
        float pathRangeMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NaviPathData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NaviPathData* pInstance);
        static void Clean(NaviPathData* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNavigationPathTestSpawner {
        enum class PointType : int8_t {
            POINT_TYPE_NONE = 0,
            POINT_TYPE_START_PLAYER_POS = 1,
            POINT_TYPE_END_PLAYER_POS = 2,
        };

        heur::rfl::NaviPathData naviPathDatas[16];
        hh::game::ObjectId startPointObj;
        hh::game::ObjectId endPointObj;
        PointType pointType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNavigationPathTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNavigationPathTestSpawner* pInstance);
        static void Clean(ObjNavigationPathTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNavMeshFindPathTestSpawner {
        csl::math::Vector3 destination;
        csl::math::Vector3 searchPosition;
        bool immediate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNavMeshFindPathTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNavMeshFindPathTestSpawner* pInstance);
        static void Clean(ObjNavMeshFindPathTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNpcTestSpawner {
        int32_t no;
        bool eventDriven;
        csl::ut::VariableString luaName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNpcTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNpcTestSpawner* pInstance);
        static void Clean(ObjNpcTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOnewayFloorTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOnewayFloorTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOnewayFloorTestSpawner* pInstance);
        static void Clean(ObjOnewayFloorTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct OverlapTestSpawner {
        enum class LayerType : int8_t {
            NONE_GROUP = 0,
            LAND = 1,
            RAYBLOCK = 2,
            THROUGH = 3,
            OBJECT = 4,
        };

        LayerType layer;
        bool childLoopLeft;
        bool childLoopRight;
        bool childSolid;
        bool childLiquid;
        bool childThrough;
        float searchSize;
        bool cache;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OverlapTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OverlapTestSpawner* pInstance);
        static void Clean(OverlapTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjOverlayTestSpawner {
        enum class Kind : int8_t {
            Toast = 0,
            ToastOrder = 1,
            ToastOrderPositive = 2,
            ToastOrderNegative = 3,
            ToastOrderFeed = 4,
            ToastOrderPositiveFeed = 5,
            ToastOrderNegativeFeed = 6,
            Window = 7,
            HeaderWindow = 8,
            TutorialWindow = 9,
            DialogWindow = 10,
            Caption = 11,
            CaptionByManual = 12,
            CaptionByExternal = 13,
            CaptionSelectBox = 14,
            Objective = 15,
            ObjectiveClear = 16,
            ObjectiveByExternal = 17,
            ObjectiveQuest = 18,
            OperationGuide = 19,
        };

        Kind kind;
        csl::ut::VariableString label;
        csl::ut::VariableString cue;
        csl::ut::VariableString tag;
        csl::ut::VariableString replaceLabel;
        csl::ut::VariableString replaceTexture;
        float time;
        bool block;
        bool unselected;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjOverlayTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjOverlayTestSpawner* pInstance);
        static void Clean(ObjOverlayTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPassPlaneTestSpawner {
        heur::rfl::PassPlaneTriggerSpawner passPlane;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPassPlaneTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPassPlaneTestSpawner* pInstance);
        static void Clean(ObjPassPlaneTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPathBuildTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPathBuildTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPathBuildTestSpawner* pInstance);
        static void Clean(ObjPathBuildTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjPbaTestSpawner {
        csl::ut::VariableString modelName;
        csl::ut::VariableString skeletonName;
        csl::ut::VariableString animatorName;
        csl::ut::VariableString animStateName;
        csl::ut::VariableString pathName;
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjPbaTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjPbaTestSpawner* pInstance);
        static void Clean(ObjPbaTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRaycastTestSpawner {
        enum class RaycastType : int8_t {
            World = 0,
            Cache = 1,
            HeightField = 2,
        };

        bool hitbits[32];
        bool preSimulate;
        RaycastType type;
        float searchSize;
        uint8_t divideNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRaycastTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRaycastTestSpawner* pInstance);
        static void Clean(ObjRaycastTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjReactiveTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjReactiveTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjReactiveTestSpawner* pInstance);
        static void Clean(ObjReactiveTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBlockObjectTestSpawner {
        enum class ShapeType : int8_t {
            SPHERE = 0,
            CAPSULE = 1,
            CYLINDER = 2,
            BOX = 3,
            MESH = 4,
        };

        enum class LayerType : int8_t {
            NONE = 0,
            SOLID = 1,
            LIQUID = 2,
            THROUGH = 3,
            CAMERA = 4,
            SOLID_ONEWAY = 5,
            SOLID_THROUGH = 6,
            SOLID_TINY = 7,
            SOLID_DETAIL = 8,
            LEAF = 9,
            LAND = 10,
            RAYBLOCK = 11,
            EVENT = 12,
            RESERVED13 = 13,
            RESERVED14 = 14,
            PLAYER = 15,
            ENEMY = 16,
            ENEMY_BODY = 17,
            GIMMICK = 18,
            DYNAMICS = 19,
            RING = 20,
            CHARACTER_CONTROL = 21,
            PLAYER_ONLY = 22,
            DYNAMICS_THROUGH = 23,
            ENEMY_ONLY = 24,
            SENSOR_PLAYER = 25,
            SENSOR_RING = 26,
            SENSOR_GIMMICK = 27,
            SENSOR_LAND = 28,
            SENSOR_ALL = 29,
            RESERVED30 = 30,
            RESERVED31 = 31,
        };

        enum class MaterialType : int8_t {
            MAT_NONE = 0,
            MAT_STONE = 1,
            MAT_EARTH = 2,
            MAT_WOOD = 3,
            MAT_GRASS = 4,
            MAT_IRON = 5,
            MAT_SAND = 6,
            MAT_LAVA = 7,
            MAT_GLASS = 8,
            MAT_SNOW = 9,
            MAT_NO_ENTRY = 10,
            MAT_ICE = 11,
            MAT_WATER = 12,
            MAT_SEA = 13,
            MAT_DAMAGE = 14,
            MAT_DEAD = 15,
            MAT_FLOWER0 = 16,
            MAT_FLOWER1 = 17,
            MAT_FLOWER2 = 18,
            MAT_AIR = 19,
            MAT_DEADLEAVES = 20,
            MAT_WIREMESH = 21,
            MAT_DEAD_ANYDIR = 22,
            MAT_DAMAGE_THROUGH = 23,
            MAT_DRY_GRASS = 24,
            MAT_RELIC = 25,
            MAT_GIANT = 26,
            MAT_GRAVEL = 27,
            MAT_MUD_WATER = 28,
            MAT_SAND2 = 29,
            MAT_SAND3 = 30,
        };

        ShapeType shape;
        csl::ut::VariableString meshResourceName;
        float width;
        float height;
        float depth;
        csl::math::Vector3 localTranslation;
        csl::math::Quaternion localRotation;
        csl::math::Vector3 localScale;
        LayerType layer;
        MaterialType material;
        bool attributes[24];
        bool movable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBlockObjectTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBlockObjectTestSpawner* pInstance);
        static void Clean(ObjBlockObjectTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRigidBodyTestSpawner {
        enum class ShapeType : int8_t {
            SPHERE = 0,
            CAPSULE = 1,
            CYLINDER = 2,
            BOX = 3,
            MESH = 4,
        };

        enum class LayerType : int8_t {
            NONE = 0,
            SOLID = 1,
            LIQUID = 2,
            THROUGH = 3,
            CAMERA = 4,
            SOLID_ONEWAY = 5,
            SOLID_THROUGH = 6,
            SOLID_TINY = 7,
            SOLID_DETAIL = 8,
            LEAF = 9,
            LAND = 10,
            RAYBLOCK = 11,
            EVENT = 12,
            RESERVED13 = 13,
            RESERVED14 = 14,
            PLAYER = 15,
            ENEMY = 16,
            ENEMY_BODY = 17,
            GIMMICK = 18,
            DYNAMICS = 19,
            RING = 20,
            CHARACTER_CONTROL = 21,
            PLAYER_ONLY = 22,
            DYNAMICS_THROUGH = 23,
            ENEMY_ONLY = 24,
            SENSOR_PLAYER = 25,
            SENSOR_RING = 26,
            SENSOR_GIMMICK = 27,
            SENSOR_LAND = 28,
            SENSOR_ALL = 29,
            RESERVED30 = 30,
            RESERVED31 = 31,
        };

        enum class MaterialType : int8_t {
            MAT_NONE = 0,
            MAT_STONE = 1,
            MAT_EARTH = 2,
            MAT_WOOD = 3,
            MAT_GRASS = 4,
            MAT_IRON = 5,
            MAT_SAND = 6,
            MAT_LAVA = 7,
            MAT_GLASS = 8,
            MAT_SNOW = 9,
            MAT_NO_ENTRY = 10,
            MAT_ICE = 11,
            MAT_WATER = 12,
            MAT_SEA = 13,
            MAT_DAMAGE = 14,
            MAT_DEAD = 15,
            MAT_FLOWER0 = 16,
            MAT_FLOWER1 = 17,
            MAT_FLOWER2 = 18,
            MAT_AIR = 19,
            MAT_DEADLEAVES = 20,
            MAT_WIREMESH = 21,
            MAT_DEAD_ANYDIR = 22,
            MAT_DAMAGE_THROUGH = 23,
            MAT_DRY_GRASS = 24,
            MAT_RELIC = 25,
            MAT_GIANT = 26,
            MAT_GRAVEL = 27,
            MAT_MUD_WATER = 28,
            MAT_SAND2 = 29,
            MAT_SAND3 = 30,
        };

        ShapeType shape;
        csl::ut::VariableString meshResourceName;
        float width;
        float height;
        float depth;
        LayerType layer;
        bool hitbits[32];
        MaterialType material;
        bool attributes[24];
        float mass;
        float friction;
        float gravityFactor;
        float restitution;
        float allowedPenetrationDepth;
        float linearDamping;
        float angularDamping;
        float maxLinearVelocity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRigidBodyTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRigidBodyTestSpawner* pInstance);
        static void Clean(ObjRigidBodyTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSampleShapeSpawner {
        enum class Shape : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CYLINDER = 2,
            SHAPE_CYLINDER_MIDAIR = 3,
        };

        enum class LayerType : int8_t {
            NONE = 0,
            SOLID = 1,
            LIQUID = 2,
            THROUGH = 3,
            CAMERA = 4,
            SOLID_ONEWAY = 5,
            SOLID_THROUGH = 6,
            SOLID_TINY = 7,
            SOLID_DETAIL = 8,
            LEAF = 9,
            LAND = 10,
            RAYBLOCK = 11,
            EVENT = 12,
            RESERVED13 = 13,
            RESERVED14 = 14,
            PLAYER = 15,
            ENEMY = 16,
            ENEMY_BODY = 17,
            GIMMICK = 18,
            DYNAMICS = 19,
            RING = 20,
            CHARACTER_CONTROL = 21,
            PLAYER_ONLY = 22,
            DYNAMICS_THROUGH = 23,
            ENEMY_ONLY = 24,
            SENSOR_PLAYER = 25,
            SENSOR_RING = 26,
            SENSOR_GIMMICK = 27,
            SENSOR_LAND = 28,
            SENSOR_ALL = 29,
            RESERVED30 = 30,
            RESERVED31 = 31,
        };

        enum class MaterialType : int8_t {
            MAT_NONE = 0,
            MAT_STONE = 1,
            MAT_EARTH = 2,
            MAT_WOOD = 3,
            MAT_GRASS = 4,
            MAT_IRON = 5,
            MAT_SAND = 6,
            MAT_LAVA = 7,
            MAT_GLASS = 8,
            MAT_SNOW = 9,
            MAT_NO_ENTRY = 10,
            MAT_ICE = 11,
            MAT_WATER = 12,
            MAT_SEA = 13,
            MAT_DAMAGE = 14,
            MAT_DEAD = 15,
            MAT_FLOWER0 = 16,
            MAT_FLOWER1 = 17,
            MAT_FLOWER2 = 18,
            MAT_AIR = 19,
            MAT_DEADLEAVES = 20,
            MAT_WIREMESH = 21,
            MAT_DEAD_ANYDIR = 22,
            MAT_DAMAGE_THROUGH = 23,
            MAT_DRY_GRASS = 24,
            MAT_RELIC = 25,
            MAT_GIANT = 26,
            MAT_GRAVEL = 27,
            MAT_MUD_WATER = 28,
            MAT_SAND2 = 29,
            MAT_SAND3 = 30,
        };

        Shape ShapeType;
        float Width;
        float Height;
        float Depth;
        uint8_t Red;
        uint8_t Green;
        uint8_t Blue;
        uint8_t Alpha;
        bool IsEnableModel;
        bool IsEnableRigidbody;
        LayerType layer;
        MaterialType material;
        bool attributes[24];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSampleShapeSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSampleShapeSpawner* pInstance);
        static void Clean(ObjSampleShapeSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSavePermissionTestSpawner {
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSavePermissionTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSavePermissionTestSpawner* pInstance);
        static void Clean(ObjSavePermissionTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSearchPathSpawner {
        enum class Shape : int8_t {
            Sphere = 0,
            Aabb = 1,
            Raycast = 2,
            Plane = 3,
        };

        bool pathFilters[5];
        Shape shape;
        float size;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSearchPathSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSearchPathSpawner* pInstance);
        static void Clean(ObjSearchPathSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShadowCameraTestSpawner {
        float nearPlane;
        float farPlane;
        float lookAtDepth;
        float sceneRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShadowCameraTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShadowCameraTestSpawner* pInstance);
        static void Clean(ObjShadowCameraTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSlingshotTestSpawner {
        csl::ut::MoveArray<hh::game::ObjectId> routePoints;
        float speed;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSlingshotTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSlingshotTestSpawner* pInstance);
        static void Clean(ObjSlingshotTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSplineTestSpawner {
        csl::math::Vector3 target;
        float beginAngle;
        float beginForce;
        float endAngle;
        float endForce;
        bool autoForce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSplineTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSplineTestSpawner* pInstance);
        static void Clean(ObjSplineTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSwayTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSwayTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSwayTestSpawner* pInstance);
        static void Clean(ObjSwayTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSweepTest2Spawner {
        enum class SweepType : int8_t {
            World = 0,
            Cache = 1,
            HeightField = 2,
        };

        float distance;
        float radius;
        float height;
        bool hitbits[32];
        bool fixedUp;
        SweepType type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSweepTest2Spawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSweepTest2Spawner* pInstance);
        static void Clean(ObjSweepTest2Spawner* pInstance);
    };
}

namespace heur::rfl {
    struct SweepTestSpawner {
        enum class ShapeType : int8_t {
            SPHERE = 0,
            CAPSULE = 1,
        };

        float distance;
        float radius;
        float height;
        ShapeType shape;
        bool hitbits[32];
        bool direct;
        csl::math::Vector3 shapePos;
        csl::math::Vector3 topPos;
        csl::math::Vector3 displacement;
        int32_t recursion;
        bool cache;
        int32_t count;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SweepTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SweepTestSpawner* pInstance);
        static void Clean(SweepTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTalkModeTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTalkModeTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTalkModeTestSpawner* pInstance);
        static void Clean(ObjTalkModeTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTargetSearchTestSpawner {
        enum class ViewShapeType : int8_t {
            Sphere = 0,
            Frustum = 1,
            Cone = 2,
        };

        ViewShapeType shape;
        float angle;
        float aspect;
        float nearClip;
        float farClip;
        bool maskEnabled;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTargetSearchTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTargetSearchTestSpawner* pInstance);
        static void Clean(ObjTargetSearchTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTargetTestSpawner {
        enum class ShapeType : int8_t {
            SPHERE = 0,
            BOX = 1,
        };

        enum class MoveType : int8_t {
            NONE = 0,
            SWING = 1,
            VSWING = 2,
        };

        ShapeType shape;
        float width;
        float height;
        float depth;
        csl::ut::Color8 color;
        bool visible;
        bool enemy;
        bool focusable;
        bool damageByKIll;
        MoveType move;
        float cycle;
        float distance;
        float idlingTime;
        float pausedTime;
        float disabledTime;
        float noReplyTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTargetTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTargetTestSpawner* pInstance);
        static void Clean(ObjTargetTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCreditBoxSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCreditBoxSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCreditBoxSpawner* pInstance);
        static void Clean(ObjCreditBoxSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTestHangerSpawner {
        float radius;
        bool move;
        float cycle;
        float distance;
        float moveTime;
        float stopTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTestHangerSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTestHangerSpawner* pInstance);
        static void Clean(ObjTestHangerSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTextTestSpawner {
        csl::ut::VariableString label;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTextTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTextTestSpawner* pInstance);
        static void Clean(ObjTextTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct TinyFsmTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TinyFsmTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TinyFsmTestSpawner* pInstance);
        static void Clean(TinyFsmTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTreadmillTestSpawner {
        float minSpeed;
        float maxSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTreadmillTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTreadmillTestSpawner* pInstance);
        static void Clean(ObjTreadmillTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLifeGaugeTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLifeGaugeTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLifeGaugeTestSpawner* pInstance);
        static void Clean(ObjLifeGaugeTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjUserModelMaterialTestSpawner {
        csl::math::Vector3 albedo;
        float reflectance;
        float smoothness;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjUserModelMaterialTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjUserModelMaterialTestSpawner* pInstance);
        static void Clean(ObjUserModelMaterialTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjUserModelShaderTestSpawner {
        csl::ut::VariableString texture;
        csl::ut::VariableString vertexShaderName;
        csl::ut::VariableString pixelShaderName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjUserModelShaderTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjUserModelShaderTestSpawner* pInstance);
        static void Clean(ObjUserModelShaderTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjUserModelTestSpawner {
        enum class RenderPresetType : int8_t {
            RENDER_PRESET_OPAQUE = 0,
            RENDER_PRESET_PUNCHTHROUGH = 1,
            RENDER_PRESET_TRANSPARENT = 2,
            RENDER_PRESET_ADD = 3,
        };

        enum class MoveType : int8_t {
            MOVE_NONE = 0,
            MOVE_SWING = 1,
            MOVE_ROTATE = 2,
        };

        RenderPresetType preset;
        csl::ut::VariableString texture;
        uint8_t red;
        uint8_t green;
        uint8_t blue;
        uint8_t alpha;
        float scale;
        csl::ut::VariableString vertexShaderName;
        csl::ut::VariableString pixelShaderName;
        bool shadowCaster;
        bool shadowReceiver;
        bool dynamic;
        MoveType move;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjUserModelTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjUserModelTestSpawner* pInstance);
        static void Clean(ObjUserModelTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjVerificationTestSpawner {
        float lengthV;
        float lengthH;
        uint32_t gridV;
        uint32_t gridH;
        uint32_t splitV;
        uint32_t splitH;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjVerificationTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjVerificationTestSpawner* pInstance);
        static void Clean(ObjVerificationTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjVibrationTestSpawner {
        enum class RumbleType : int8_t {
            RUMBLE_AUTO = 0,
            RUMBLE_ONESHOT = 1,
            RUMBLE_LOOP = 2,
        };

        csl::ut::VariableString name;
        RumbleType type;
        float time;
        bool enabledTimeAttn;
        bool enabledDistAttn;
        float distance;
        float easeoutTime;
        heur::rfl::VolumeTriggerSpawner volume;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjVibrationTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjVibrationTestSpawner* pInstance);
        static void Clean(ObjVibrationTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjVisualModelCacheTestSpawner {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjVisualModelCacheTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjVisualModelCacheTestSpawner* pInstance);
        static void Clean(ObjVisualModelCacheTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjVisualModelTestSpawner {
        csl::ut::VariableString modelName;
        csl::ut::VariableString skeletonName;
        csl::ut::VariableString animationName;
        bool clipping;
        float clippingHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjVisualModelTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjVisualModelTestSpawner* pInstance);
        static void Clean(ObjVisualModelTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarpMonitorTestSpawner {
        int32_t no;
        bool eventDriven;
        hh::game::ObjectId warpObject;
        csl::math::Vector3 warpOffset;
        csl::math::Vector3 lockonOffset;
        csl::math::Vector3 reboundDir;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarpMonitorTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarpMonitorTestSpawner* pInstance);
        static void Clean(ObjWarpMonitorTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWindTestSpawner {
        enum class WindFlowType : uint8_t {
            FlowNone = 0,
            FlowDirectional = 1,
            FlowOmni = 2,
            FlowVortex = 3,
            FlowFan = 4,
        };

        enum class WindVolumnCenter : uint8_t {
            LookAt = 0,
            Object = 1,
        };

        float power;
        float radius;
        float moveComp;
        WindFlowType type;
        csl::math::Vector3 dir;
        float fanAngle;
        heur::rfl::PathMovement pathParam;
        float easingTime;
        WindVolumnCenter volumnCenter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWindTestSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWindTestSpawner* pInstance);
        static void Clean(ObjWindTestSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraBattleParameter {
        float distance;
        float distanceSuspensionK;
        float elevationOffset;
        float azimuthMinOffset;
        float azimuthMaxOffset;
        float azimuthMinOffsetDistance;
        float azimuthMaxOffsetDistance;
        float azimuthSensitivity;
        float targetOffsetSuspensionK;
        float targetMinUpOffset;
        float targetMaxUpOffset;
        float targetFrontOffset;
        float delayAllowDistance;
        float delayLimitDistance;
        float delaySuspensionK;
        float manualControlTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraBattleParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraBattleParameter* pInstance);
        static void Clean(StandardCameraBattleParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraCommonParameter {
        float distance;
        float distanceSuspensionK;
        float minElevation;
        float maxElevation;
        float azimuthSensitivity;
        float elevationUpSensitivity;
        float elevationDownSensitivity;
        float elevationOffset;
        float targetUpOffset;
        float targetMinUpOffsetLimit;
        float targetMaxUpOffsetLimit;
        float targetMinUpOffsetLimitDistance;
        float targetMaxUpOffsetLimitDistance;
        float targetOffsetSuspensionK;
        float delayAllowDistance;
        float delayLimitDistance;
        float delaySuspensionK;
        float autocontrolDisabledTime;
        float chaseSegmentSuspensionK;
        float chaseSegmentShortenSpeed;
        int32_t chaseSegmentMaxCount;
        float inertiaMinDecel;
        float inertiaOvershootAngle;
        float resetSuspensionK;
        float downDirectionDotThreshold;
        float baseUpLeanRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraCommonParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraCommonParameter* pInstance);
        static void Clean(StandardCameraCommonParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraDashParameter {
        float minDistance;
        float maxDistance;
        float minDistanceAccel;
        float maxDistanceAccel;
        float distanceSuspensionK;
        float elevationOffset;
        float azimuthSensitivity;
        float targetOffsetSuspensionK;
        float targetUpOffset;
        float delayAllowDistance;
        float delayLimitDistance;
        float delaySuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraDashParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraDashParameter* pInstance);
        static void Clean(StandardCameraDashParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraCyloopParameter {
        float minDistance;
        float maxDistance;
        float elevationOffset;
        float azimuthSensitivity;
        float elevationUpSensitivity;
        float elevationDownSensitivity;
        float targetUpOffset;
        float minDelayLimitDistance;
        float maxDelayLimitDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraCyloopParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraCyloopParameter* pInstance);
        static void Clean(StandardCameraCyloopParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraLockonParameter {
        float distance;
        float minElevation;
        float maxElevation;
        float elevationOffset;
        float minElevationCyloop;
        float maxElevationCyloop;
        float elevationOffsetCyloop;
        float targetUpOffset;
        float delayAllowDistance;
        float delayLimitDistance;
        float delaySuspensionK;
        float panningSuspensionK;
        float interiorPanningDistance;
        float interiorPanningSuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraLockonParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraLockonParameter* pInstance);
        static void Clean(StandardCameraLockonParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraWallParameter {
        float distance;
        float targetUpOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraWallParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraWallParameter* pInstance);
        static void Clean(StandardCameraWallParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraLoopParameter {
        float azimuthSensitivity;
        float elevationUpSensitivity;
        float elevationDownSensitivity;
        float targetUpOffset;
        float baseUpLeanRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraLoopParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraLoopParameter* pInstance);
        static void Clean(StandardCameraLoopParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraOptionParameter {
        float minManualRotationSpeed;
        float maxManualRotationSpeed;
        float minDistanceScale;
        float maxDistanceScale;
        float maxElevationAddOffset;
        float minTargetUpOffsetScale;
        float maxTargetUpOffsetScale;
        float minFovyRate;
        float minLimitFovy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraOptionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraOptionParameter* pInstance);
        static void Clean(StandardCameraOptionParameter* pInstance);
    };
}

namespace heur::rfl {
    struct StandardCameraConfig {
        heur::rfl::StandardCameraCommonParameter common;
        heur::rfl::StandardCameraDashParameter dash;
        heur::rfl::StandardCameraCyloopParameter cyloop;
        heur::rfl::StandardCameraCyloopParameter cyloopSnipe;
        heur::rfl::StandardCameraLockonParameter lockon;
        heur::rfl::StandardCameraLockonParameter lockonCharger;
        heur::rfl::StandardCameraLockonParameter lockonSpider;
        heur::rfl::StandardCameraLockonParameter lockonDaruma;
        heur::rfl::StandardCameraLockonParameter lockonNinja;
        heur::rfl::StandardCameraLockonParameter lockonSumo;
        heur::rfl::StandardCameraWallParameter wall;
        heur::rfl::StandardCameraLoopParameter loop;
        heur::rfl::StandardCameraBattleParameter battle;
        heur::rfl::StandardCameraOptionParameter option;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StandardCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StandardCameraConfig* pInstance);
        static void Clean(StandardCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct CameraShakeRecord {
        enum class ShakeType : uint8_t {
            Directional = 0,
            WorldY = 1,
            Random = 2,
            DirectionalStaticUp = 3,
        };

        csl::ut::VariableString name;
        ShakeType type;
        float zRot;
        float duration;
        float frequency;
        float amplitude;
        float timeAttenuationRate;
        bool enableDistanceAttenuation;
        float attenuationDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CameraShakeRecord* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CameraShakeRecord* pInstance);
        static void Clean(CameraShakeRecord* pInstance);
    };
}

namespace heur::rfl {
    struct CameraShakeTable {
        heur::rfl::CameraShakeRecord records[64];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CameraShakeTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CameraShakeTable* pInstance);
        static void Clean(CameraShakeTable* pInstance);
    };
}

namespace heur::rfl {
    struct AddDatabaseInfo {
        uint8_t recordNo;
        uint8_t numRecords;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AddDatabaseInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AddDatabaseInfo* pInstance);
        static void Clean(AddDatabaseInfo* pInstance);
    };
}

namespace heur::rfl {
    struct ContentParameter {
        heur::rfl::AddDatabaseInfo databases[2];
        csl::ut::VariableString stagedata;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ContentParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ContentParameter* pInstance);
        static void Clean(ContentParameter* pInstance);
    };
}

namespace heur::rfl {
    struct Record {
        uint8_t no;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Record* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Record* pInstance);
        static void Clean(Record* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAttackRecord : heur::rfl::Record {
        enum class Kind : int16_t {
            InvalidKind = -1,
            Dead_BattleJellymanLv1 = 0,
            Dead_BattleJellymanLv2 = 1,
            Dead_BattleJellymanLv3 = 2,
            Dead_BattleJellymanLv4 = 3,
            Dead_BattleWolf = 4,
            Dead_BattleBird = 5,
            Dead_BattleSniper = 6,
            Dead_BattleTwister = 7,
            Dead_BattleBommer = 8,
            Dead_BattleBubble = 9,
            Dead_BattleDefender = 10,
            Dead_BattleUmbrella = 11,
            Dead_BattleAquaBall = 12,
            Dead_BattleJumper = 13,
            Dead_BattleBladeLv1 = 14,
            Dead_BattleBladeLv2 = 15,
            Dead_BattleBladeLv3 = 16,
            Dead_BattleBladeLv4 = 17,
            Dead_BattleDarumaLv1 = 18,
            Dead_BattleDarumaLv2 = 19,
            Dead_BattleDarumaLv3 = 20,
            Dead_BattleDarumaLv4 = 21,
            Dead_BattleSpider = 22,
            Dead_BattleCharger = 23,
            Dead_BattleFlyer = 24,
            Dead_BattleTracker = 25,
            Dead_BattleAsura = 26,
            Dead_BattleSkier = 27,
            Dead_BattleTyrant = 28,
            Dead_BattleSumo = 29,
            Dead_BattleStrider = 30,
            Dead_BattleWarship = 31,
            Dead_BattleGiantFC = 32,
            Dead_BattleGiantClimb = 33,
            Dead_BattleGiant = 34,
            Dead_BattleDragonFC = 35,
            Dead_BattleDragonClimb = 36,
            Dead_BattleDragon = 37,
            Dead_BattleKnightFC = 38,
            Dead_BattleKnightClimb = 39,
            Dead_BattleKnight = 40,
            Dead_BattleRifle = 41,
            Dead_BattleTheEnd = 42,
            Dead_Gimmick = 43,
            Dead_Fall = 44,
            Dead_Water = 45,
            Dead_Lava = 46,
            Failed_QuestKodamaCollect1 = 47,
            Failed_QuestMowingGrass = 48,
            Failed_QuestKodamaEscort = 49,
            Failed_QuestKodamaCollect2 = 50,
            Failed_QuestDarumaBattle = 51,
            Failed_QuestCollectItem = 52,
            Failed_QuestDrawBridge = 53,
            Failed_PinBall = 54,
            Failed_Hacking = 55,
            Transit_ToIsland = 56,
            Transit_ToCyber = 57,
            Transit_ToFishing = 58,
            Transit_ToHacking = 59,
            Transit_ToTheEnd = 60,
            Transit_ToSkill1 = 61,
            Transit_ToSkill2 = 62,
            Transit_ToSkill3 = 63,
            Transit_ToSkill4 = 64,
            Transit_ToSkill5 = 65,
            Transit_ToSkill6 = 66,
            Transit_ToSkill7 = 67,
            Transit_ToSkill8 = 68,
            Transit_ToSkill9 = 69,
            Transit_ToSkill10 = 70,
            Transit_ToSkill11 = 71,
            Transit_ToSkill12 = 72,
            Transit_ToSkill13 = 73,
            Transit_ToSkill14 = 74,
            Transit_ToSkill15 = 75,
            Transit_ToSkill16 = 76,
            Transit_ToSkill17 = 77,
            Transit_ToSkill18 = 78,
            Transit_ToSkill19 = 79,
            Transit_ToSkill20 = 80,
            BattleRifleBeast_Fase3_Cable = 81,
            BattleRifleBeast_Fase3_Parry = 82,
            BattleRifleBeast_Fase3_Down = 83,
            BattleRifleBeast_Fase4 = 84,
            TransitAmy_ToSkill1 = 85,
            TransitAmy_ToSkill2 = 86,
            TransitAmy_ToSkill3 = 87,
            TransitAmy_ToSkill4 = 88,
            TransitAmy_ToSkill5 = 89,
            TransitAmy_ToSkill6 = 90,
            TransitAmy_ToSkill7 = 91,
            TransitAmy_ToSkill8 = 92,
            TransitAmy_ToSkill9 = 93,
            TransitAmy_ToSkill10 = 94,
            TransitAmy_ToSkill11 = 95,
            TransitAmy_ToSkill12 = 96,
            TransitAmy_ToSkill13 = 97,
            TransitAmy_ToSkill14 = 98,
            TransitAmy_ToSkill15 = 99,
            TransitAmy_ToSkill16 = 100,
            TransitAmy_ToSkill17 = 101,
            TransitAmy_ToSkill18 = 102,
            TransitAmy_ToSkill19 = 103,
            TransitAmy_ToSkill20 = 104,
            DeadAmy_BattleBlade = 105,
            DeadAmy_BattleDaruma = 106,
            DeadAmy_BattleCharger = 107,
            DeadAmy_BattleSpider = 108,
            DeadAmy_BattleTracker = 109,
            DeadAmy_BattleTyrant = 110,
            DeadAmy_Gimmick = 111,
            DeadAmy_Fall = 112,
            DeadAmy_Water = 113,
            TransitKnuckles_ToSkill1 = 114,
            TransitKnuckles_ToSkill2 = 115,
            TransitKnuckles_ToSkill3 = 116,
            TransitKnuckles_ToSkill4 = 117,
            TransitKnuckles_ToSkill5 = 118,
            TransitKnuckles_ToSkill6 = 119,
            TransitKnuckles_ToSkill7 = 120,
            TransitKnuckles_ToSkill8 = 121,
            TransitKnuckles_ToSkill9 = 122,
            TransitKnuckles_ToSkill10 = 123,
            TransitKnuckles_ToSkill11 = 124,
            TransitKnuckles_ToSkill12 = 125,
            TransitKnuckles_ToSkill13 = 126,
            TransitKnuckles_ToSkill14 = 127,
            TransitKnuckles_ToSkill15 = 128,
            TransitKnuckles_ToSkill16 = 129,
            TransitKnuckles_ToSkill17 = 130,
            TransitKnuckles_ToSkill18 = 131,
            TransitKnuckles_ToSkill19 = 132,
            TransitKnuckles_ToSkill20 = 133,
            DeadKnuckles_BattleBlade = 134,
            DeadKnuckles_BattleDaruma = 135,
            DeadKnuckles_BattleCharger = 136,
            DeadKnuckles_BattleSpider = 137,
            DeadKnuckles_BattleTracker = 138,
            DeadKnuckles_BattleTyrant = 139,
            DeadKnuckles_Gimmick = 140,
            DeadKnuckles_Fall = 141,
            DeadKnuckles_Water = 142,
            TransitTails_ToSkill1 = 143,
            TransitTails_ToSkill2 = 144,
            TransitTails_ToSkill3 = 145,
            TransitTails_ToSkill4 = 146,
            TransitTails_ToSkill5 = 147,
            TransitTails_ToSkill6 = 148,
            TransitTails_ToSkill7 = 149,
            TransitTails_ToSkill8 = 150,
            TransitTails_ToSkill9 = 151,
            TransitTails_ToSkill10 = 152,
            TransitTails_ToSkill11 = 153,
            TransitTails_ToSkill12 = 154,
            TransitTails_ToSkill13 = 155,
            TransitTails_ToSkill14 = 156,
            TransitTails_ToSkill15 = 157,
            TransitTails_ToSkill16 = 158,
            TransitTails_ToSkill17 = 159,
            TransitTails_ToSkill18 = 160,
            TransitTails_ToSkill19 = 161,
            TransitTails_ToSkill20 = 162,
            DeadTails_BattleBlade = 163,
            DeadTails_BattleDaruma = 164,
            DeadTails_BattleCharger = 165,
            DeadTails_BattleSpider = 166,
            DeadTails_BattleTracker = 167,
            DeadTails_BattleTyrant = 168,
            DeadTails_Gimmick = 169,
            DeadTails_Fall = 170,
            DeadTails_Water = 171,
            DeadSonic_BattleBlade = 172,
            DeadSonic_BattleDaruma = 173,
            DeadSonic_BattleCharger = 174,
            DeadSonic_BattleSpider = 175,
            DeadSonic_BattleTracker = 176,
            DeadSonic_BattleTyrant = 177,
            DeadSonic_Gimmick = 178,
            DeadSonic_Fall = 179,
            DeadSonic_Water = 180,
            NumKinds = 181,
        };

        csl::ut::VariableString name;
        int32_t damage;
        float velocityX;
        float velocityY;
        csl::ut::VariableString hitStopName;
        csl::ut::VariableString cameraShakeName;
        Kind practice;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAttackRecord* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAttackRecord* pInstance);
        static void Clean(EnemyAttackRecord* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAttackRecordBaseTable {
        heur::rfl::EnemyAttackRecord data[192];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAttackRecordBaseTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAttackRecordBaseTable* pInstance);
        static void Clean(EnemyAttackRecordBaseTable* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAttackRecordTable {
        heur::rfl::EnemyAttackRecord data[192];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAttackRecordTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAttackRecordTable* pInstance);
        static void Clean(EnemyAttackRecordTable* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyDefenceRecord : heur::rfl::Record {
        csl::ut::VariableString name;
        float baseRate;
        float slashRate;
        float quickRate;
        float stunRate;
        float staggerRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyDefenceRecord* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyDefenceRecord* pInstance);
        static void Clean(EnemyDefenceRecord* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyDefenceRecordBaseTable {
        heur::rfl::EnemyDefenceRecord data[64];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyDefenceRecordBaseTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyDefenceRecordBaseTable* pInstance);
        static void Clean(EnemyDefenceRecordBaseTable* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyDefenceRecordTable {
        heur::rfl::EnemyDefenceRecord data[128];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyDefenceRecordTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyDefenceRecordTable* pInstance);
        static void Clean(EnemyDefenceRecordTable* pInstance);
    };
}

namespace heur::rfl {
    struct DLCMhrBarbecueTokenParam {
        uint32_t rawToken;
        uint32_t rawBurnToken;
        uint32_t brownedToken;
        uint32_t charredToken;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DLCMhrBarbecueTokenParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DLCMhrBarbecueTokenParam* pInstance);
        static void Clean(DLCMhrBarbecueTokenParam* pInstance);
    };
}

namespace heur::rfl {
    struct DLCMhrBarbecueParameter {
        float rawTime;
        float rawBurnTime;
        float brownedTime;
        float charredTime;
        float startwaitTime;
        float successTime;
        float missTime;
        float resultUIDelaySuccess;
        float resultUIDelayFaild;
        heur::rfl::DLCMhrBarbecueTokenParam tokenParam[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DLCMhrBarbecueParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DLCMhrBarbecueParameter* pInstance);
        static void Clean(DLCMhrBarbecueParameter* pInstance);
    };
}

namespace heur::rfl {
    struct DLCParameter {
        uint8_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DLCParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DLCParameter* pInstance);
        static void Clean(DLCParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BossRushStageParameter {
        uint32_t hour;
        uint32_t minute;
        uint32_t healthPoint;
        uint32_t recoveryRing;
        uint8_t powerLevel;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRushStageParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRushStageParameter* pInstance);
        static void Clean(BossRushStageParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BossRushParameterElement {
        int32_t applicableFailedCount;
        heur::rfl::BossRushStageParameter stages[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRushParameterElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRushParameterElement* pInstance);
        static void Clean(BossRushParameterElement* pInstance);
    };
}

namespace heur::rfl {
    struct BossRushParameter {
        heur::rfl::BossRushParameterElement element[3];
        heur::rfl::BossRushParameterElement elementEasy[3];
        uint32_t defaultRing;
        uint32_t defaultRingEasy;
        float defaultCyloopGauge;
        float readyTime;
        float clearTime;
        float failedTime;
        float clearWaitTime;
        float failedWaitTime;
        float kodamaOrdinaryTextTime;
        float kodamaFightDelayTime;
        float kodamaFightTextTime;
        float kodamaSplendidTextTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRushParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRushParameter* pInstance);
        static void Clean(BossRushParameter* pInstance);
    };
}

namespace heur::rfl {
    struct DebrisParameter {
        int32_t m_maxNumPieces;
        float gravity;
        float lifeTime;
        float force;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DebrisParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DebrisParameter* pInstance);
        static void Clean(DebrisParameter* pInstance);
    };
}

namespace heur::rfl {
    struct MasterTrialStageParameter {
        csl::ut::Bitset<uint8_t> prerequisite;
        float limitTime;
        float defeatedWaitTime;
        float speedUpScale;
        float attackRate;
        float recoveryHpTime;
        uint32_t recoveryHpPoint;
        uint32_t limitMistake;
        int32_t damagePoint;
        uint8_t powerLevel;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MasterTrialStageParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MasterTrialStageParameter* pInstance);
        static void Clean(MasterTrialStageParameter* pInstance);
    };
}

namespace heur::rfl {
    struct MasterTrialParameterElement {
        int32_t applicableFailedCount;
        heur::rfl::MasterTrialStageParameter stages[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MasterTrialParameterElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MasterTrialParameterElement* pInstance);
        static void Clean(MasterTrialParameterElement* pInstance);
    };
}

namespace heur::rfl {
    struct MasterTrialParameters {
        float subjectViewTime;
        float readyTime;
        float clearTime;
        float failedTime;
        float clearWaitTime;
        float failedWaitTime;
        float kodamaOrdinaryTextTime;
        float kodamaFightDelayTime;
        float kodamaFightTextTime;
        float kodamaSplendidTextTime;
        heur::rfl::MasterTrialParameterElement element[3];
        heur::rfl::MasterTrialParameterElement elementEasy[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MasterTrialParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MasterTrialParameters* pInstance);
        static void Clean(MasterTrialParameters* pInstance);
    };
}

namespace heur::rfl {
    struct DevConfigParameters {
        enum class Value : int8_t {
            Invalid = -1,
            Sonic = 0,
            Amy = 1,
            Knuckles = 2,
            Tails = 3,
            Num = 4,
            Default = 0,
        };

        bool autoSaveEnabled;
        bool gismoEnabled;
        bool reportEnabled;
        bool skillTreeEnabled;
        bool tutorialEnabled;
        bool arcadeModeEnabled;
        bool battleModeEnabled;
        bool cyberChallengeEnabled;
        bool practice;
        bool practiceTimeLimitEnabled;
        bool creditsEnabled;
        Value character;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DevConfigParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DevConfigParameters* pInstance);
        static void Clean(DevConfigParameters* pInstance);
    };
}

namespace heur::rfl {
    struct HeightFieldConfigData {
        enum class LayerType : int8_t {
            LAYER_NONE = 0,
            LAYER_SOLID = 1,
            LAYER_LIQUID = 2,
            LAYER_THROUGH = 3,
            LAYER_CAMERA = 4,
            LAYER_SOLID_ONEWAY = 5,
            LAYER_SOLID_THROUGH = 6,
            LAYER_SOLID_TINY = 7,
            LAYER_SOLID_DETAIL = 8,
            LAYER_LEAF = 9,
            LAYER_LAND = 10,
            LAYER_RAYBLOCK = 11,
            LAYER_EVENT = 12,
            LAYER_RESERVED13 = 13,
            LAYER_RESERVED14 = 14,
            LAYER_PLAYER = 15,
            LAYER_ENEMY = 16,
            LAYER_ENEMY_BODY = 17,
            LAYER_GIMMICK = 18,
            LAYER_DYNAMICS = 19,
            LAYER_RING = 20,
            LAYER_CHARACTER_CONTROL = 21,
            LAYER_PLAYER_ONLY = 22,
            LAYER_DYNAMICS_THROUGH = 23,
            LAYER_ENEMY_ONLY = 24,
            LAYER_SENSOR_PLAYER = 25,
            LAYER_SENSOR_RING = 26,
            LAYER_SENSOR_GIMMICK = 27,
            LAYER_SENSOR_LAND = 28,
            LAYER_SENSOR_ALL = 29,
            LAYER_RESERVED30 = 30,
            LAYER_RESERVED31 = 31,
        };

        enum class MaterialType : int8_t {
            MAT_NONE = 0,
            MAT_STONE = 1,
            MAT_EARTH = 2,
            MAT_WOOD = 3,
            MAT_GRASS = 4,
            MAT_IRON = 5,
            MAT_SAND = 6,
            MAT_LAVA = 7,
            MAT_GLASS = 8,
            MAT_SNOW = 9,
            MAT_NO_ENTRY = 10,
            MAT_ICE = 11,
            MAT_WATER = 12,
            MAT_SEA = 13,
            MAT_DAMAGE = 14,
            MAT_DEAD = 15,
            MAT_FLOWER0 = 16,
            MAT_FLOWER1 = 17,
            MAT_FLOWER2 = 18,
            MAT_AIR = 19,
            MAT_DEADLEAVES = 20,
            MAT_WIREMESH = 21,
            MAT_DEAD_ANYDIR = 22,
            MAT_DAMAGE_THROUGH = 23,
            MAT_DRY_GRASS = 24,
            MAT_RELIC = 25,
            MAT_GIANT = 26,
            MAT_GRAVEL = 27,
            MAT_MUD_WATER = 28,
            MAT_SAND2 = 29,
            MAT_SAND3 = 30,
        };

        LayerType layer;
        MaterialType material;
        bool notStand;
        bool wall;
        bool parkour;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeightFieldConfigData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeightFieldConfigData* pInstance);
        static void Clean(HeightFieldConfigData* pInstance);
    };
}

namespace heur::rfl {
    struct HeightFieldConfig {
        heur::rfl::HeightFieldConfigData data[255];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeightFieldConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeightFieldConfig* pInstance);
        static void Clean(HeightFieldConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MonologueIslandParameters {
        float playSpanTime;
        csl::ut::VariableString labelNames[24];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MonologueIslandParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MonologueIslandParameters* pInstance);
        static void Clean(MonologueIslandParameters* pInstance);
    };
}

namespace heur::rfl {
    struct MonologueMultiTextParameters {
        csl::ut::VariableString labelNames[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MonologueMultiTextParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MonologueMultiTextParameters* pInstance);
        static void Clean(MonologueMultiTextParameters* pInstance);
    };
}

namespace heur::rfl {
    struct MonologueParameters {
        enum class Value : int8_t {
            SteppeIsland1 = 0,
            DesertIsland = 1,
            VolcanicIsland = 2,
            TowerIsland = 3,
            SteppeIsland2 = 4,
            Num = 5,
            ExtraIsland = 5,
            NumInExtra = 6,
        };

        heur::rfl::MonologueIslandParameters islands[5];
        heur::rfl::MonologueMultiTextParameters multiText[1];
        int8_t firstTheEndNotifyCount;
        int8_t theEndNotifyCount;
        Value dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MonologueParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MonologueParameters* pInstance);
        static void Clean(MonologueParameters* pInstance);
    };
}

namespace heur::rfl {
    struct BakeBoxParameter {
        csl::ut::VariableString name;
        csl::math::Vector3 center;
        csl::math::Vector3 halfExtents;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BakeBoxParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BakeBoxParameter* pInstance);
        static void Clean(BakeBoxParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BakeCameraParameter {
        csl::ut::VariableString name;
        csl::ut::MoveArray<heur::rfl::BakeCameraParameter> data;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BakeCameraParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BakeCameraParameter* pInstance);
        static void Clean(BakeCameraParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BakeCameraParameterData {
        csl::math::Vector3 target;
        csl::math::Vector3 eye;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BakeCameraParameterData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BakeCameraParameterData* pInstance);
        static void Clean(BakeCameraParameterData* pInstance);
    };
}

namespace heur::rfl {
    struct BattleRushPhaseRankParameter {
        uint32_t rankTime[4];
        uint32_t rankTimeAll[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BattleRushPhaseRankParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BattleRushPhaseRankParameter* pInstance);
        static void Clean(BattleRushPhaseRankParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BattleRushStageParameter {
        enum class BgmType : int8_t {
            INVALID = -1,
            ENEMY_BATTLE = 0,
            FORCE_BATTLE_FIELD = 1,
            MINIBOSS_CHARGER_BATTLE = 2,
            MINIBOSS_DARUMA_BATTLE = 3,
            MINIBOSS_SPIDER_BATTLE = 4,
            MINIBOSS_BLADE_BATTLE = 5,
            MINIBOSS_FLYER_BATTLE = 6,
            MINIBOSS_TRACKER_BATTLE = 7,
            MINIBOSS_ASHURA_BATTLE = 8,
            MINIBOSS_SKIER_BATTLE = 9,
            MINIBOSS_SUMO_BATTLE = 10,
            MINIBOSS_TYRANT_BATTLE = 11,
            MINIBOSS_STRIDER_BATTLE = 12,
            MINIBOSS_WARSHIP_BATTLE = 13,
            ENEMY_AQUABALL = 14,
            TUTORIAL_BLADE_BATTLE = 15,
        };

        uint32_t numPhases;
        float phaseLimitTime[11];
        float phaseClearedTime[11];
        float phaseResultTime[11];
        heur::rfl::BattleRushPhaseRankParameter phaseRank[11];
        BgmType phaseBgmType[11];
        uint32_t hour;
        uint32_t minute;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BattleRushStageParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BattleRushStageParameter* pInstance);
        static void Clean(BattleRushStageParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BattleRushParameter {
        heur::rfl::BattleRushStageParameter stages[4];
        float viewPaseResultTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BattleRushParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BattleRushParameter* pInstance);
        static void Clean(BattleRushParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CyKnuckleHoleTransitionParameter {
        enum class EasingType : uint8_t {
            LINEAR_EASEIN = 0,
            LINEAR_EASEOUT = 1,
            LINEAR_EASEINOUT = 2,
            QUADRATIC_EASEIN = 3,
            QUADRATIC_EASEOUT = 4,
            QUADRATIC_EASEINOUT = 5,
            CUBIC_EASEIN = 6,
            CUBIC_EASEOUT = 7,
            CUBIC_EASEINOUT = 8,
            QUARTIC_EASEIN = 9,
            QUARTIC_EASEOUT = 10,
            QUARTIC_EASEINOUT = 11,
            QUINTIC_EASEIN = 12,
            QUINTIC_EASEOUT = 13,
            QUINTIC_EASEINOUT = 14,
            SINE_EASEIN = 15,
            SINE_EASEOUT = 16,
            SINE_EASEINOUT = 17,
            EXPONENTAL_EASEIN = 18,
            EXPONENTAL_EASEOUT = 19,
            EXPONENTAL_EASEINOUT = 20,
            CIRCULAR_EASEIN = 21,
            CIRCULAR_EASEOUT = 22,
            CIRCULAR_EASEINOUT = 23,
            BACK_EASEIN = 24,
            BACK_EASEOUT = 25,
            BACK_EASEINOUT = 26,
            BOUNCE_EASEIN = 27,
            BOUNCE_EASEOUT = 28,
            BOUNCE_EASEINOUT = 29,
            ELASITC_EASEIN = 30,
            ELASITC_EASEOUT = 31,
            ELASITC_EASEINOUT = 32,
            NUM_EASINGTYPES = 33,
        };

        float easeTime;
        EasingType easing;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyKnuckleHoleTransitionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyKnuckleHoleTransitionParameter* pInstance);
        static void Clean(CyKnuckleHoleTransitionParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CyKnuckleHoleParameter {
        float radiusOpenSmall;
        float radiusOpen;
        heur::rfl::CyKnuckleHoleTransitionParameter closeToOpenSmall;
        heur::rfl::CyKnuckleHoleTransitionParameter closeToOpen;
        heur::rfl::CyKnuckleHoleTransitionParameter openSmallToClose;
        heur::rfl::CyKnuckleHoleTransitionParameter openSmallToOpen;
        heur::rfl::CyKnuckleHoleTransitionParameter openToClose;
        heur::rfl::CyKnuckleHoleTransitionParameter openToOpenSmall;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyKnuckleHoleParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyKnuckleHoleParameter* pInstance);
        static void Clean(CyKnuckleHoleParameter* pInstance);
    };
}

namespace heur::rfl {
    struct GameExpParameter {
        uint32_t maxExpPointBase;
        uint32_t maxExpPointAdd;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameExpParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameExpParameter* pInstance);
        static void Clean(GameExpParameter* pInstance);
    };
}

namespace heur::rfl {
    struct GameGrassInteractionParameterData {
        csl::ut::VariableString name;
        float radius;
        float height;
        float power;
        bool moveHitEnabled;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameGrassInteractionParameterData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameGrassInteractionParameterData* pInstance);
        static void Clean(GameGrassInteractionParameterData* pInstance);
    };
}

namespace heur::rfl {
    struct GameGrassInteractionParameter {
        heur::rfl::GameGrassInteractionParameterData data[32];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameGrassInteractionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameGrassInteractionParameter* pInstance);
        static void Clean(GameGrassInteractionParameter* pInstance);
    };
}

namespace heur::rfl {
    struct GameGrindLodParameter {
        float distances[4];
        float cullingDistances[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameGrindLodParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameGrindLodParameter* pInstance);
        static void Clean(GameGrindLodParameter* pInstance);
    };
}

namespace heur::rfl {
    struct GameHitStopParameterData {
        csl::ut::VariableString name;
        float scale;
        float time;
        float easeOutTime;
        float delayTime;
        bool layerPlayer;
        bool layerEnemy;
        bool layerDamagedEnemy;
        bool layerCamera;
        bool layerOthers;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameHitStopParameterData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameHitStopParameterData* pInstance);
        static void Clean(GameHitStopParameterData* pInstance);
    };
}

namespace heur::rfl {
    struct GameHitStopParameter {
        heur::rfl::GameHitStopParameterData data[64];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameHitStopParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameHitStopParameter* pInstance);
        static void Clean(GameHitStopParameter* pInstance);
    };
}

namespace heur::rfl {
    struct SkillParam {
        uint8_t unlockPoint;
        uint8_t addUnlockPoint;
        bool present;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SkillParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SkillParam* pInstance);
        static void Clean(SkillParam* pInstance);
    };
}

namespace heur::rfl {
    struct SkillLinkSetting {
        bool down;
        bool left;
        bool right;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SkillLinkSetting* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SkillLinkSetting* pInstance);
        static void Clean(SkillLinkSetting* pInstance);
    };
}

namespace heur::rfl {
    struct SkillNodeParam {
        enum class Value : int8_t {
            BeginSonicSkill = 0,
            Cyloop = 0,
            Smash = 1,
            QuickCyloop = 2,
            AcceleLevel = 3,
            ChargeAttack = 4,
            RecoverySmash = 5,
            AirTrick = 6,
            SonicBoom = 7,
            Crasher = 8,
            LoopKick = 9,
            SpinSlash = 10,
            StompingAttack = 11,
            HomingShot = 12,
            CrossSlash = 13,
            AutoCombo = 14,
            NumUsed = 15,
            Dummy0 = 15,
            CrossSlash2 = 15,
            Dummy1 = 16,
            Dummy2 = 17,
            Dummy3 = 18,
            Dummy4 = 19,
            Num = 20,
            BeginAmySkill = 20,
            AmyJump = 20,
            AmyPropellerJump = 21,
            AmyHomingAtatck = 22,
            AmyBoost = 23,
            AmyPowerBoost = 24,
            AmyTarotAttack = 25,
            AmyTarotRolling = 26,
            AmyCharmAttack = 27,
            AmyStomp = 28,
            AmyHighJump = 29,
            AmyCyHammer = 30,
            AmyTarotRollingInfinity = 31,
            AmySpinDash = 32,
            AmyParry = 33,
            AmyParryDebuff = 34,
            AmyCyloop = 35,
            AmyDoubleJump = 36,
            AmyNumUsed = 37,
            AmyDummy0 = 37,
            AmyDummy1 = 38,
            AmyDummy2 = 39,
            AmyNum = 40,
            BeginKnucklesSkill = 40,
            KnucklesJump = 40,
            KnucklesGliding = 41,
            KnucklesHomingAtatck = 42,
            KnucklesBoost = 43,
            KnucklesWallRun = 44,
            KnucklesPowerBoost = 45,
            KnucklesComboAttack = 46,
            KnucklesMaximumHeatKnuckle = 47,
            KnucklesStomp = 48,
            KnucklesCyKnuckle = 49,
            KnucklesGlidingInfinity = 50,
            KnucklesSpinDash = 51,
            KnucklesParry = 52,
            KnucklesDoubleJump = 53,
            KnucklesParryDebuff = 54,
            KnucklesCyloop = 55,
            KnucklesNumUsed = 56,
            KnucklesDummy0 = 56,
            KnucklesDummy1 = 57,
            KnucklesDummy2 = 58,
            KnucklesDummy3 = 59,
            KnucklesNum = 60,
            BeginTailsSkill = 60,
            TailsJump = 60,
            TailsFly = 61,
            TailsHomingAtatck = 62,
            TailsBoost = 63,
            TailsPowerBoost = 64,
            TailsSpannerAttack = 65,
            TailsChargeSpanner = 66,
            TailsStomp = 67,
            TailsCyBlaster = 68,
            TailsCycloneCannon = 69,
            TailsSpinDash = 70,
            TailsParry = 71,
            TailsDoubleJump = 72,
            TailsParryDebuff = 73,
            TailsCyloop = 74,
            TailsNumUsed = 75,
            TailsDummy0 = 75,
            TailsDummy1 = 76,
            TailsDummy2 = 77,
            TailsDummy3 = 78,
            TailsDummy4 = 79,
            TailsNum = 80,
            AllNum = 80,
            Invalid = -1,
        };

        bool enable;
        Value skill;
        heur::rfl::SkillLinkSetting link;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SkillNodeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SkillNodeParam* pInstance);
        static void Clean(SkillNodeParam* pInstance);
    };
}

namespace heur::rfl {
    struct SkillTreeParam {
        heur::rfl::SkillNodeParam nodeParams[30];
        int8_t startIndex;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SkillTreeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SkillTreeParam* pInstance);
        static void Clean(SkillTreeParam* pInstance);
    };
}

namespace heur::rfl {
    struct GameSkillParameter {
        heur::rfl::SkillParam skillParams[80];
        heur::rfl::SkillTreeParam treeParams[1];
        heur::rfl::SkillTreeParam treeParamsAmy[1];
        heur::rfl::SkillTreeParam treeParamsKnuckles[1];
        heur::rfl::SkillTreeParam treeParamsTails[1];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameSkillParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameSkillParameter* pInstance);
        static void Clean(GameSkillParameter* pInstance);
    };
}

namespace heur::rfl {
    struct PhotoModeCameraParameters {
        float translationLimit;
        float translationSpeedXZ;
        float translationSpeedY;
        float elevLimit;
        float rotationSpeed;
        float rollRange;
        float rollSpeed;
        float fovyRange;
        float fovySpeed;
        float speedRatioFast;
        float speedRatioSlow;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PhotoModeCameraParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PhotoModeCameraParameters* pInstance);
        static void Clean(PhotoModeCameraParameters* pInstance);
    };
}

namespace heur::rfl {
    struct PhotoModeFilterParameters {
        float sepiaSaturationOffset;
        float sepiaColorizeRate;
        float sepiaColorizeHue;
        float increaseSaturationOffset;
        int32_t warmColorROffset;
        int32_t warmColorGOffset;
        int32_t warmColorBOffset;
        int32_t coldColorROffset;
        int32_t coldColorGOffset;
        int32_t coldColorBOffset;
        float retroContrastOffset;
        int32_t retroROffset;
        int32_t retroGOffset;
        int32_t retroBOffset;
        float retroSaturationOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PhotoModeFilterParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PhotoModeFilterParameters* pInstance);
        static void Clean(PhotoModeFilterParameters* pInstance);
    };
}

namespace heur::rfl {
    struct PhotoModeParameters {
        heur::rfl::PhotoModeCameraParameters camera;
        heur::rfl::PhotoModeFilterParameters filter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PhotoModeParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PhotoModeParameters* pInstance);
        static void Clean(PhotoModeParameters* pInstance);
    };
}

namespace heur::rfl {
    struct PracticeAction {
        enum class Type : uint16_t {
            None = 0,
            ControlCamera = 1,
            Cyloop = 2,
            QuickCyloop = 3,
            FocusCamera = 4,
            Parry = 5,
            Avoid = 6,
            AcceleCombo = 7,
            Crasher = 8,
            HomingShot = 9,
            StompingAttack = 10,
            SonicBoom = 11,
            SpinSlash = 12,
            LoopKick = 13,
            CrossSlash = 14,
            ChargeAttack = 15,
            Smash = 16,
            RecoverySmash = 17,
            Jump = 18,
            DoubleJump = 19,
            HomingAttack = 20,
            Boost = 21,
            Stomping = 22,
            BoundStomping = 23,
            AirBoost = 24,
            QuickStep = 25,
            LightDash = 26,
            DropDash = 27,
            Sliding = 28,
            WallRun = 29,
            Discontinued = 30,
            AirTrick = 31,
            AirTrickEnd = 32,
            CancelHomingAttackBounceStomping = 33,
            CancelAirBoostStomping = 34,
            Squat = 35,
            SpinBoostCharge = 36,
            SpinBoost = 37,
            RunToSpinBoost = 38,
            SpinBoostAny = 39,
            AmyPropellerJump = 40,
            AmyTarotBoost = 41,
            AmyTarotAttack = 42,
            AmyTarotAttack2 = 43,
            AmyTarotRolling = 44,
            AmyCharmAttack = 45,
            AmyStomp = 46,
            AmyHighJump = 47,
            AmyCyHammer = 48,
            AmyTarotRollingInfinity = 49,
            AmyParryDebuff = 50,
            KnucklesGliding = 51,
            KnucklesDrillBoost = 52,
            KnucklesComboAttack1 = 53,
            KnucklesComboAttack2 = 54,
            KnucklesComboAttack3 = 55,
            KnucklesMaximumHeatKnuckle = 56,
            KnucklesStomp = 57,
            KnucklesCyKnuckle = 58,
            KnucklesGlidingInfinity = 59,
            KnucklesParryDebuff = 60,
            TailsFly = 61,
            TailsCycloneBoost = 62,
            TailsSpannerAttack = 63,
            TailsChargeSpanner = 64,
            TailsChargeSpannerJump = 65,
            TailsStomp = 66,
            TailsCyBlaster = 67,
            TailsCycloneCannon = 68,
            TailsParryDebuff = 69,
            DefeatEnemy = 70,
            Num = 71,
        };

        enum class Judge : int8_t {
            Succeed = 0,
            Failed = 1,
            Skiped = 2,
            Waiting = 3,
            Unknown = 4,
            NumJudges = 5,
        };

        Type action;
        Judge dummy;
        csl::ut::Bitset<uint64_t> skipableActions;
        csl::ut::Bitset<uint64_t> skipableActions2;
        csl::ut::VariableString label;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticeAction* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticeAction* pInstance);
        static void Clean(PracticeAction* pInstance);
    };
}

namespace heur::rfl {
    struct PracticePrerequisite {
        csl::ut::Bitset<uint64_t> skill;
        csl::ut::Bitset<uint64_t> skill2;
        csl::ut::Bitset<uint64_t> clearedSubject;
        csl::ut::Bitset<uint64_t> clearedSubject2;
        csl::ut::Bitset<uint64_t> clearedSubject3;
        csl::ut::Bitset<uint64_t> clearedSubject4;
        bool unlockSpinBoost;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticePrerequisite* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticePrerequisite* pInstance);
        static void Clean(PracticePrerequisite* pInstance);
    };
}

namespace heur::rfl {
    struct PracticeSubject {
        enum class Checker : int8_t {
            InvalidChecker = -1,
            CountActions = 0,
            CountAirTrick = 1,
            CountControlCamera = 2,
            CountInfinityCombo = 3,
            CountFiveCombo = 4,
            CountDefeatEnemies = 5,
            NumCheckers = 6,
        };

        enum class Value : int8_t {
            Invalid = -1,
            Sonic = 0,
            Amy = 1,
            Knuckles = 2,
            Tails = 3,
            Num = 4,
            Default = 0,
        };

        enum class Option {
            BattleMode = 0,
            AutoComboDisabled = 1,
            QuickCyloopTutorial = 2,
            SubjectViewDisabled = 3,
            RingMax = 4,
        };

        Checker checker;
        heur::rfl::PracticeAction actions[6];
        int32_t count;
        heur::rfl::PracticePrerequisite prerequisite;
        csl::ut::Bitset<uint8_t> options;
        Value character;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticeSubject* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticeSubject* pInstance);
        static void Clean(PracticeSubject* pInstance);
    };
}

namespace heur::rfl {
    struct PracticeText {
        csl::ut::VariableString labels[10];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticeText* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticeText* pInstance);
        static void Clean(PracticeText* pInstance);
    };
}

namespace heur::rfl {
    struct PracticeTime {
        float readyTime;
        float countTime;
        float subjectViewTime;
        float clearedPostTime;
        float fadeoutWaitTime;
        float rebuildWaitTime1;
        float rebuildWaitTime2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticeTime* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticeTime* pInstance);
        static void Clean(PracticeTime* pInstance);
    };
}

namespace heur::rfl {
    struct PracticeTipsPrerequisite {
        csl::ut::Bitset<uint64_t> skill;
        csl::ut::Bitset<uint64_t> skill2;
        bool tutorialCleared;
        bool unlockArcadeMode;
        bool unlockCyberPowerBoost;
        bool unlockVeryHardMode;
        bool unlockStrongNewGame;
        bool unlockSpinBoost;
        bool masterKodamaCleared;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticeTipsPrerequisite* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticeTipsPrerequisite* pInstance);
        static void Clean(PracticeTipsPrerequisite* pInstance);
    };
}

namespace heur::rfl {
    struct PracticeTips {
        heur::rfl::PracticeTipsPrerequisite prerequisite;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticeTips* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticeTips* pInstance);
        static void Clean(PracticeTips* pInstance);
    };
}

namespace heur::rfl {
    struct PracticeSet {
        int16_t subjects[20];
        int16_t tips[100];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticeSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticeSet* pInstance);
        static void Clean(PracticeSet* pInstance);
    };
}

namespace heur::rfl {
    struct PracticeParameters {
        heur::rfl::PracticeSubject subjects[200];
        heur::rfl::PracticeText text;
        heur::rfl::PracticeTime time;
        float notifyTime;
        heur::rfl::PracticeTips tips[256];
        float tipsMinViewTime;
        heur::rfl::PracticeSet sets[181];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PracticeParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PracticeParameters* pInstance);
        static void Clean(PracticeParameters* pInstance);
    };
}

namespace heur::rfl {
    struct TimeServiceParam {
        float speed;
        float timeMagnification;
        int32_t addMinuteReturnFromCyber;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TimeServiceParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TimeServiceParam* pInstance);
        static void Clean(TimeServiceParam* pInstance);
    };
}

namespace heur::rfl {
    struct WeatherBlockParameter {
        uint8_t blockWeights[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherBlockParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherBlockParameter* pInstance);
        static void Clean(WeatherBlockParameter* pInstance);
    };
}

namespace heur::rfl {
    struct WeatherTypeParameter {
        uint8_t transitWeights[5];
        heur::rfl::WeatherBlockParameter blockParams[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherTypeParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherTypeParameter* pInstance);
        static void Clean(WeatherTypeParameter* pInstance);
    };
}

namespace heur::rfl {
    struct WeatherTimeParameter {
        uint8_t hour;
        uint8_t minute;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherTimeParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherTimeParameter* pInstance);
        static void Clean(WeatherTimeParameter* pInstance);
    };
}

namespace heur::rfl {
    struct WeatherTimeControlParameter {
        heur::rfl::WeatherTimeParameter sunriseBeginTime;
        heur::rfl::WeatherTimeParameter dayBeginTime;
        heur::rfl::WeatherTimeParameter sunsetBeginTime;
        heur::rfl::WeatherTimeParameter nightBeginTime;
        heur::rfl::WeatherTimeParameter blockTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherTimeControlParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherTimeControlParameter* pInstance);
        static void Clean(WeatherTimeControlParameter* pInstance);
    };
}

namespace heur::rfl {
    struct WeatherParameters {
        heur::rfl::WeatherTypeParameter type[5];
        heur::rfl::WeatherTimeControlParameter timeControl;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherParameters* pInstance);
        static void Clean(WeatherParameters* pInstance);
    };
}

namespace heur::rfl {
    struct EffectParameters {
        float localLightIntensityScale;
        bool dropPriorityEnabled;
        int8_t dropPriority;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EffectParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EffectParameters* pInstance);
        static void Clean(EffectParameters* pInstance);
    };
}

namespace heur::rfl {
    struct AuraEffectLerpNode {
        float distance;
        float noiseTextureScrollSpeed;
        float blurScale;
        float colorGain;
        float noiseGain;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AuraEffectLerpNode* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AuraEffectLerpNode* pInstance);
        static void Clean(AuraEffectLerpNode* pInstance);
    };
}

namespace heur::rfl {
    struct AuraEffectLerpParameter {
        csl::ut::VariableString name;
        heur::rfl::AuraEffectLerpNode node[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AuraEffectLerpParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AuraEffectLerpParameter* pInstance);
        static void Clean(AuraEffectLerpParameter* pInstance);
    };
}

namespace heur::rfl {
    struct AuraEffectParameters {
        heur::rfl::AuraEffectLerpParameter params[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AuraEffectParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AuraEffectParameters* pInstance);
        static void Clean(AuraEffectParameters* pInstance);
    };
}

namespace heur::rfl {
    struct GraphicsParameters {
        heur::rfl::AuraEffectParameters aura;
        heur::rfl::EffectParameters effect;
        heur::rfl::WeatherParameters weather;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GraphicsParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GraphicsParameters* pInstance);
        static void Clean(GraphicsParameters* pInstance);
    };
}

namespace heur::rfl {
    struct NoisePresetParameters {
        hh::needle::FxCyberSpaceStartNoiseParameter presets[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NoisePresetParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NoisePresetParameters* pInstance);
        static void Clean(NoisePresetParameters* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFlashSwitchConfig {
        float recoveryQuickCyloopValue;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFlashSwitchConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFlashSwitchConfig* pInstance);
        static void Clean(ObjFlashSwitchConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonAttackSignParam {
        float delayTime[6];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonAttackSignParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonAttackSignParam* pInstance);
        static void Clean(BossDragonAttackSignParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonCameraParam {
        csl::ut::VariableString gazeFrame;
        csl::ut::VariableString gazeFrameMirror;
        csl::math::Vector3 gazeOffset;
        float distance;
        csl::math::Vector3 playerOffset;
        float elevationOffset;
        csl::math::Vector3 followRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonCameraParam* pInstance);
        static void Clean(BossDragonCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonChaseParam {
        float distance;
        float goalOffset;
        float speed;
        float boostSpeed;
        float width;
        float height;
        float closeDistance;
        float closeSpeedScale;
        float fastMoveDistance;
        float stunTime;
        float stunSpeedScale;
        float superBoostDelayTime;
        float superBoostTime;
        float superBoostSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonChaseParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonChaseParam* pInstance);
        static void Clean(BossDragonChaseParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonCollisionParamBase {
        csl::ut::VariableString name;
        csl::ut::VariableString parentFrame;
        csl::math::Vector3 size;
        csl::math::Vector3 localPosition;
        csl::math::Vector3 localRotation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonCollisionParamBase* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonCollisionParamBase* pInstance);
        static void Clean(BossDragonCollisionParamBase* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonHitBoxParam : heur::rfl::BossDragonCollisionParamBase {
        csl::math::Vector3 damageVelocity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonHitBoxParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonHitBoxParam* pInstance);
        static void Clean(BossDragonHitBoxParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonHurtBoxParam : heur::rfl::BossDragonCollisionParamBase {
        bool isEnableHoming;
        csl::ut::VariableString homingNode;
        csl::ut::VariableString homingNodeMirror;
        csl::math::Vector3 homingPosition;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonHurtBoxParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonHurtBoxParam* pInstance);
        static void Clean(BossDragonHurtBoxParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonScratchParam {
        float aimTime;
        float stunTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonScratchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonScratchParam* pInstance);
        static void Clean(BossDragonScratchParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonReflectShotParam {
        float radius;
        float speed;
        float maxSpeed;
        float accel;
        float reflectSpeedScale;
        float intervalTime;
        float lifeTime;
        float pitchOffsetRange;
        float yawOffsetRange;
        bool isBound;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonReflectShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonReflectShotParam* pInstance);
        static void Clean(BossDragonReflectShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonShotParam {
        float radius;
        float speed;
        float intervalTime;
        float lifeTime;
        float pitchOffsetRange;
        float yawOffsetRange;
        int32_t count;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonShotParam* pInstance);
        static void Clean(BossDragonShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonSpiralShotParam {
        float radius;
        float speed;
        float intervalTime;
        float lifeTime;
        float pitchSpeed;
        float yawSpeed;
        float circleIntervalTime;
        int32_t count;
        int32_t parriableCount;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonSpiralShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonSpiralShotParam* pInstance);
        static void Clean(BossDragonSpiralShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonSplashShotParam {
        float radius;
        float speed;
        float gravity;
        float intervalTime;
        float lifeTime;
        float pitch;
        float pitchInterval;
        float yawInterval;
        int32_t count;
        int32_t parriableCount;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonSplashShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonSplashShotParam* pInstance);
        static void Clean(BossDragonSplashShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonHomingLaserParam {
        float radius;
        float speed;
        float maxAccel;
        float intervalTime;
        float arrivalTime;
        float lifeTime;
        float minPitchOffset;
        float maxPitchOffset;
        float yawOffsetRange;
        int32_t count;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonHomingLaserParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonHomingLaserParam* pInstance);
        static void Clean(BossDragonHomingLaserParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonHomingMissileParam {
        float radius;
        float length;
        float speed;
        float intervalTime;
        float lifeTime;
        float minPitchOffset;
        float maxPitchOffset;
        float yawOffsetRange;
        int32_t count;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonHomingMissileParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonHomingMissileParam* pInstance);
        static void Clean(BossDragonHomingMissileParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonRippleLaserParam {
        float innerRadius;
        float outerRadius;
        float speed;
        float intervalTime;
        float lifeTime;
        float pitchOffsetRange;
        float yawOffsetRange;
        int32_t count;
        int32_t parriableCount;
        float intervalTimeInGroup;
        int32_t countInGroup;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonRippleLaserParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonRippleLaserParam* pInstance);
        static void Clean(BossDragonRippleLaserParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonRippleLaserRageParam {
        float innerRadius;
        float outerRadius;
        float speed;
        float intervalTime;
        float lifeTime;
        float maxPitch;
        float maxYaw;
        int32_t verticalCount;
        int32_t horizontalCount;
        int32_t extraFrontCount;
        int32_t parriableCount;
        float intervalTimeInGroup;
        int32_t countInGroup;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonRippleLaserRageParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonRippleLaserRageParam* pInstance);
        static void Clean(BossDragonRippleLaserRageParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonRippleLaserDummyParam {
        float innerRadius;
        float outerRadius;
        float speed;
        float intervalTime;
        float lifeTime;
        float pitchOffsetRange;
        float yawOffsetRange;
        int32_t count;
        float intervalTimeInGroup;
        int32_t countInGroup;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonRippleLaserDummyParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonRippleLaserDummyParam* pInstance);
        static void Clean(BossDragonRippleLaserDummyParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonWaveParam {
        float speed;
        float rotSpeed;
        float accel;
        float rotAccel;
        float intervalTime;
        float lifeTime;
        int32_t segmentCount;
        float waveRate;
        int32_t count;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonWaveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonWaveParam* pInstance);
        static void Clean(BossDragonWaveParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonLaserParam {
        float radius;
        float length;
        float rotSpeed;
        float rotAccel;
        float roll;
        float intervalTime;
        float standbyTime;
        int32_t count;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonLaserParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonLaserParam* pInstance);
        static void Clean(BossDragonLaserParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonCounterLaserParam {
        float radius;
        float speed;
        float lifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonCounterLaserParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonCounterLaserParam* pInstance);
        static void Clean(BossDragonCounterLaserParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonRingSupplyMissileParam {
        int32_t missileNum;
        float missileWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonRingSupplyMissileParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonRingSupplyMissileParam* pInstance);
        static void Clean(BossDragonRingSupplyMissileParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonRingSupplyParam {
        csl::math::Vector3 playerPosition;
        float moveTime;
        float moveRange;
        float rotSpeed;
        heur::rfl::BossDragonRingSupplyMissileParam missile[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonRingSupplyParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonRingSupplyParam* pInstance);
        static void Clean(BossDragonRingSupplyParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonLayoutParam {
        enum class EaseType : int8_t {
            SMOOTH = 0,
            EASE_IN = 1,
            EASE_OUT = 2,
            EASE_IN_OUT = 3,
        };

        csl::math::Vector3 bossPosition;
        float bossYaw;
        EaseType bossEaseType;
        float bossEaseTime;
        csl::math::Vector3 playerPosition;
        float playerFieldRange;
        float playerFieldHeight;
        float playerFieldYaw;
        EaseType playerEaseType;
        float playerEaseTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonLayoutParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonLayoutParam* pInstance);
        static void Clean(BossDragonLayoutParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonMoveParam {
        csl::math::Vector3 playerNodes[8];
        csl::math::Vector3 bossNodes[8];
        int32_t playerNodeCount;
        int32_t bossNodeCount;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonMoveParam* pInstance);
        static void Clean(BossDragonMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonFireBarParam {
        float radius;
        float length;
        float rotSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonFireBarParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonFireBarParam* pInstance);
        static void Clean(BossDragonFireBarParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonEscapeShotParam {
        uint32_t vertRatio[3];
        float initSpeed;
        float maxSpeed;
        float acc;
        float lifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonEscapeShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonEscapeShotParam* pInstance);
        static void Clean(BossDragonEscapeShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonObstacleParam {
        enum class Type : int8_t {
            None = 0,
            FireBar = 1,
            FireBar4 = 2,
            Spark = 3,
        };

        enum class Location : int8_t {
            Left = 0,
            Center = 1,
            Right = 2,
        };

        float distance;
        Type type;
        Location location;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonObstacleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonObstacleParam* pInstance);
        static void Clean(BossDragonObstacleParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonHoleParam {
        float start;
        float end;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonHoleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonHoleParam* pInstance);
        static void Clean(BossDragonHoleParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonRoadParam {
        float interval;
        int32_t recordNum;
        float width;
        heur::rfl::BossDragonFireBarParam fireBar;
        heur::rfl::BossDragonEscapeShotParam shot;
        heur::rfl::BossDragonObstacleParam obstacles[64];
        heur::rfl::BossDragonHoleParam holes[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonRoadParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonRoadParam* pInstance);
        static void Clean(BossDragonRoadParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonLaunchParam {
        float outStrength;
        float inStrength;
        float outElev;
        float inElev;
        float speed;
        csl::math::Vector3 targetOffset;
        float launchCameraInterpolateTime;
        csl::math::Vector3 launchCameraPos;
        csl::math::Vector3 launchCameraTarget;
        float launchCameraRoll;
        float launchCameraTime;
        float fallCameraInterpolateTime;
        float fallCameraDistance;
        float fallCameraElavation;
        float landingCameraInterpolateTime;
        float landingCameraDistance;
        float landingCameraElavation;
        float landingCameraAzimuth;
        float landingCameraChangeDistance;
        float landingCameraNearInterpolateTime;
        float landingCameraNearDistance;
        float landingCameraNearElavation;
        float landingCameraNearAzimuth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonLaunchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonLaunchParam* pInstance);
        static void Clean(BossDragonLaunchParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonQuickStepParam {
        float speed;
        float boostSpeed;
        float boostSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonQuickStepParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonQuickStepParam* pInstance);
        static void Clean(BossDragonQuickStepParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonMissileIndividualParam {
        bool isValid;
        float rotForce;
        float maxRotForce;
        float rotForceSpeed;
        float rotDamper;
        float straightTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonMissileIndividualParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonMissileIndividualParam* pInstance);
        static void Clean(BossDragonMissileIndividualParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonMissileFirePattern {
        float hpRatioThreshold;
        int32_t count;
        float intervalTime;
        float waitTime;
        float badRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonMissileFirePattern* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonMissileFirePattern* pInstance);
        static void Clean(BossDragonMissileFirePattern* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonMissileParam {
        float radius;
        float length;
        float speed;
        float maxSpeed;
        float accel;
        float lifeTime;
        heur::rfl::BossDragonMissileIndividualParam individuals[16];
        heur::rfl::BossDragonMissileIndividualParam badIndividuals[8];
        heur::rfl::BossDragonMissileFirePattern firePatterns[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonMissileParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonMissileParam* pInstance);
        static void Clean(BossDragonMissileParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonInterruptParam {
        enum class BossDragonInterrupt : int8_t {
            NOP = 0,
            RAGE = 1,
            SPECIAL_ATTACK = 2,
            SPECIAL_ATTACK2 = 3,
        };

        float hpRatio;
        BossDragonInterrupt interrupt;
        bool forceInterrupt;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonInterruptParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonInterruptParam* pInstance);
        static void Clean(BossDragonInterruptParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonCyloopBindParam {
        float postCameraTime[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonCyloopBindParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonCyloopBindParam* pInstance);
        static void Clean(BossDragonCyloopBindParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonParrySlowParam {
        float scale;
        float time;
        float easeOutTime;
        bool cameraSlow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonParrySlowParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonParrySlowParam* pInstance);
        static void Clean(BossDragonParrySlowParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonParryParam {
        heur::rfl::BossDragonParrySlowParam slowParams[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonParryParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonParryParam* pInstance);
        static void Clean(BossDragonParryParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonNotifierParam {
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigClimb;
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigBattle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonNotifierParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonNotifierParam* pInstance);
        static void Clean(BossDragonNotifierParam* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerMoveableRangeParam {
        csl::ut::MoveArray<hh::game::ObjectId> initPositions;
        csl::ut::VariableString heightTargetNodeName;
        float heightMoveSpeed;
        float bossToPlayerDistanceMin;
        float bossToPlayerDistanceMax;
        float offsetHeightMin;
        float offsetHeightMax;
        float areaDistanceMin;
        float areaDistanceMax;
        float playerSpawnDistance;
        float playerRespawnDistance;
        float playerRespawnDistance2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerMoveableRangeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerMoveableRangeParam* pInstance);
        static void Clean(PlayerMoveableRangeParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossPhaseParam {
        bool isUse;
        bool isUsePillar;
        float phaseChangeHpRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossPhaseParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossPhaseParam* pInstance);
        static void Clean(BossPhaseParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossLockOnCameraParam {
        enum class EaseType : int8_t {
            ET_Sin = 0,
            ET_Cubic = 1,
            ET_Quadratic = 2,
        };

        float easeTime;
        EaseType easeType;
        csl::ut::VariableString mainLookAtNodeName;
        csl::math::Vector3 mainLookOffsetPos;
        csl::ut::VariableString subLookAtNodeName;
        csl::math::Vector3 subLookOffsetPos;
        float distance;
        csl::math::Vector3 playerOffsetPos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossLockOnCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossLockOnCameraParam* pInstance);
        static void Clean(BossLockOnCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossStatusConfig {
        uint32_t healthPoint;
        float stunTime;
        float maxStunPoint[3];
        float maxStaggerPoint[5];
        uint16_t exp;
        heur::rfl::PlayerMoveableRangeParam moveRangeParam;
        heur::rfl::PlayerMoveableRangeParam cyloopDamageMoveRangeParam;
        heur::rfl::BossPhaseParam phaseParams[8];
        heur::rfl::BossLockOnCameraParam cameraParam;
        bool isDebugDraw;
        uint32_t debugDrawPhaseIndex;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossStatusConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossStatusConfig* pInstance);
        static void Clean(BossStatusConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossPillarParam {
        enum class GimmickType : int8_t {
            GT_A = 0,
            GT_B = 1,
            GT_C = 2,
            GT_D = 3,
            GT_E = 4,
            NUM_GIMMICK_TYPE = 5,
        };

        enum class AttackType : int8_t {
            AT_A = 0,
            AT_B = 1,
            AT_C = 2,
            AT_D = 3,
            AT_E = 4,
            NUM_ATTACK_TYPE = 5,
        };

        bool isUse;
        float gimmickPhaseTime;
        float attackPhaseTime;
        bool isUnique;
        GimmickType gimmickType;
        float gimmickIntervalTime;
        AttackType attackType;
        float attackIntervalTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossPillarParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossPillarParam* pInstance);
        static void Clean(BossPillarParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossPillarConfig {
        enum class GimmickType : int8_t {
            GT_A = 0,
            GT_B = 1,
            GT_C = 2,
            GT_D = 3,
            GT_E = 4,
            NUM_GIMMICK_TYPE = 5,
        };

        enum class AttackType : int8_t {
            AT_A = 0,
            AT_B = 1,
            AT_C = 2,
            AT_D = 3,
            AT_E = 4,
            NUM_ATTACK_TYPE = 5,
        };

        GimmickType gimmickTypeAll;
        float gimmickIntervalTimeAll;
        AttackType attackTypeAll;
        float attackIntervalTimeAll;
        heur::rfl::BossPillarParam pillars[32];
        csl::ut::VariableString spawnPositionName;
        uint32_t pillarHealthPoint;
        uint32_t pillarBreakDamage;
        float pillarBreakStun;
        bool isDebugDraw;
        uint32_t DebugDrawType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossPillarConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossPillarConfig* pInstance);
        static void Clean(BossPillarConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossColliderStatus {
        enum class ColliderActiveType : int8_t {
            Always = 0,
            OnContactActive = 1,
            OnContactInactive = 2,
            OnMotionActive = 3,
            OnMotionInactive = 4,
            Manual = 5,
            NUM_COLLIDER_ACTIVE_TYPE = 6,
        };

        enum class ColliderProperty : int16_t {
            CpNone = 0,
            CpBattleUse = 1,
            CpBattleUnuse = 2,
            CpRestPoint = 3,
            CpHomingTarget = 4,
            CpPerceive = 5,
            CpDamage = 6,
            CpAttack = 7,
            CpContactActive = 8,
            CpContactInactive = 9,
            CpMotionActive = 10,
            CpMotionInactive = 11,
            CpManual = 12,
            CpUpperSide = 13,
            CpLowerSide = 14,
            CpFrontSide = 15,
            CpBackSide = 16,
            CpLeftSide = 17,
            CpRightSide = 18,
            CpPointA = 19,
            CpPointB = 20,
            CpPointC = 21,
            CpPointD = 22,
            CpCyloopDownUnuse = 23,
            CpDummyDamage = 24,
            CpCable = 25,
            CpTackleHand = 26,
            NUM_COLLIDER_PROPERTY = 27,
        };

        ColliderActiveType type;
        ColliderProperty propertys[4];
        csl::ut::VariableString text;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossColliderStatus* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossColliderStatus* pInstance);
        static void Clean(BossColliderStatus* pInstance);
    };
}

namespace heur::rfl {
    struct BossPerceiveCollisionParam {
        enum class CollisionType : int8_t {
            CT_SPHERE = 0,
            CT_CAPSULE = 1,
            CT_CYLINDER = 2,
            CT_BOX = 3,
            NUM_COLLISION_TYPE = 4,
        };

        bool isUse;
        int16_t priority;
        CollisionType type;
        csl::ut::VariableString attachNodeName;
        csl::ut::VariableString name;
        heur::rfl::BossColliderStatus status;
        csl::math::Vector3 size;
        csl::math::Vector3 offset;
        csl::math::Vector3 rotation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossPerceiveCollisionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossPerceiveCollisionParam* pInstance);
        static void Clean(BossPerceiveCollisionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossPerceivePartsWithCollisionConfig {
        heur::rfl::BossPerceiveCollisionParam perceiveCollisions[64];
        bool isDebugDraw;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossPerceivePartsWithCollisionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossPerceivePartsWithCollisionConfig* pInstance);
        static void Clean(BossPerceivePartsWithCollisionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossHomingPointParam {
        heur::rfl::BossColliderStatus status;
        float distance;
        float nextSearchDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossHomingPointParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossHomingPointParam* pInstance);
        static void Clean(BossHomingPointParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossMinionParam {
        uint32_t num;
        float interval;
        float liveTime;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossMinionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossMinionParam* pInstance);
        static void Clean(BossMinionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossTrigerParam {
        enum class Shape : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CYLINDER = 2,
            SHAPE_CAPSULE = 3,
        };

        Shape ShapeType;
        float CollisionWidth;
        float CollisionHeight;
        float CollisionDepth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossTrigerParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossTrigerParam* pInstance);
        static void Clean(BossTrigerParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossStickParam {
        float phaseTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossStickParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossStickParam* pInstance);
        static void Clean(BossStickParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDamagePointParam {
        bool isCyloopDownUnuse;
        csl::ut::VariableString text;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDamagePointParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDamagePointParam* pInstance);
        static void Clean(BossDamagePointParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossDashCirclPointParam {
        int32_t focusGeometryIndex;
        int32_t focusTriangleIndex;
        float sizeScale;
        float impulseSpeed;
        float ocTime;
        float slowRateBoss;
        float slowRatePlayer;
        float slowTime;
        float slowEaseInTime;
        float slowEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDashCirclPointParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDashCirclPointParam* pInstance);
        static void Clean(BossDashCirclPointParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossMeshFrameParam {
        enum class PointType : int8_t {
            PT_HOMINGPOINT = 0,
            PT_HEROSAGE = 1,
            PT_MINIONGENERATOR = 2,
            PT_TRIGGER = 3,
            PT_ANCHOR = 4,
            PT_DAMAGEPOINT = 5,
            PT_STICK = 6,
            PT_DAMAGEEFFECT = 7,
            PT_DASHCIRCLE = 8,
            NUM_POINT_TYPE = 9,
        };

        bool isUse;
        uint32_t geometryIndex;
        uint32_t triangleIndex;
        PointType type;
        heur::rfl::BossHomingPointParam homingPoint;
        heur::rfl::BossMinionParam minionParam;
        heur::rfl::BossTrigerParam trigger;
        heur::rfl::BossStickParam stickParam;
        heur::rfl::BossDamagePointParam damagePoint;
        heur::rfl::BossDashCirclPointParam dashCirclPoint;
        int32_t linkNums[5];
        csl::math::Vector3 offsetPos;
        csl::math::Vector3 offsetRot;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossMeshFrameParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossMeshFrameParam* pInstance);
        static void Clean(BossMeshFrameParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossMeshFrameConfig {
        heur::rfl::BossMeshFrameParam meshShapeKeyFrames[256];
        bool isDebugDraw;
        bool isDebugDrawPoint;
        bool isDebugDrawMesh;
        bool isDebugDrawMeshIndivid;
        float debugDrawMeshTriangleDistance;
        uint32_t debugDrawMeshTriangleNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossMeshFrameConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossMeshFrameConfig* pInstance);
        static void Clean(BossMeshFrameConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossAttackCollisionParam {
        enum class AttackType : int8_t {
            AT_NONE = 0,
            AT_BLOWOFF = 1,
            AT_SLAMDOWNWARD = 2,
            AT_KILLING = 3,
            AT_NOTPARRY = 4,
            AT_NOTDAMAGE = 5,
            AT_NOTDAMAGETRIGGER = 6,
            NUM_ATTACK_TYPE = 7,
        };

        bool isUse;
        csl::ut::VariableString attachNodeName;
        float damageVelocityRaito;
        AttackType types[4];
        heur::rfl::BossColliderStatus status;
        float size;
        csl::math::Vector3 offset;
        csl::ut::VariableString parryCounterTargetCollisionName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossAttackCollisionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossAttackCollisionParam* pInstance);
        static void Clean(BossAttackCollisionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossAttackCollisionConfig {
        heur::rfl::BossAttackCollisionParam attackCollisions[64];
        bool isDebugDraw;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossAttackCollisionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossAttackCollisionConfig* pInstance);
        static void Clean(BossAttackCollisionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossBattlePhaseCollisionParam {
        bool isUse;
        csl::ut::VariableString attachNodeName;
        csl::ut::VariableString name;
        float size;
        csl::math::Vector3 offset;
        csl::math::Vector3 rotation;
        bool isParryActive;
        float cyloopRadius;
        bool onlyRigidBody;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossBattlePhaseCollisionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossBattlePhaseCollisionParam* pInstance);
        static void Clean(BossBattlePhaseCollisionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossBattlePhaseCollisionConfig {
        heur::rfl::BossBattlePhaseCollisionParam battleCollisions[16];
        bool isDebugDraw;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossBattlePhaseCollisionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossBattlePhaseCollisionConfig* pInstance);
        static void Clean(BossBattlePhaseCollisionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossDropRingConfig {
        uint32_t ringNumQuickCyloopUp;
        uint32_t ringNumQuickCyloopDown;
        uint32_t ringNumSonicSpecial;
        float ringSpawnDistance;
        float ringSuckedVelocity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDropRingConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDropRingConfig* pInstance);
        static void Clean(BossDropRingConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossBaseConfig {
        heur::rfl::BossStatusConfig status;
        heur::rfl::BossPillarConfig pillar;
        heur::rfl::BossPerceivePartsWithCollisionConfig perceivPartsWithCollision;
        heur::rfl::BossMeshFrameConfig meshShapeKeyFrame;
        heur::rfl::BossAttackCollisionConfig attackCollision;
        heur::rfl::BossBattlePhaseCollisionConfig battleCollision;
        heur::rfl::BossDropRingConfig dropRing;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossBaseConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossBaseConfig* pInstance);
        static void Clean(BossBaseConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossDragonConfig : heur::rfl::BossBaseConfig {
        enum class BossDragonSequence : int8_t {
            NOP = 0,
            BITE = 1,
            LIGHT_SCRATCH = 2,
            SCRATCH = 3,
            SHOOT = 4,
            SHOOT_NORMAL = 5,
            SHOOT_SPIRAL = 6,
            SHOOT_SPIRAL_ALTERNATE = 7,
            SHOOT_SPIRAL_VERTICAL = 8,
            SHOOT_SPLASH = 9,
            SHOOT_HOMING_LASER = 10,
            SHOOT_HOMING_MISSILE = 11,
            SHOOT_RIPPLE_LASER = 12,
            SHOOT_RIPPLE_LASER_RAGE = 13,
            SHOOT_WAVE = 14,
            SHOOT_LASER_WINDER = 15,
            SHOOT_RANDOM_LASER = 16,
            SHOOT_END = 17,
            SWAP_SIDE = 18,
            CHASE = 19,
        };

        float cruisePathSpeed;
        float patrolPathSpeed;
        float approachPathSpeedMin;
        float approachPathSpeedMax;
        float climbPathSpeed;
        float pathSpeed;
        float ringSupplyPathSpeed;
        float sideDistance;
        float shootEndTime;
        int32_t staggerPoint;
        int32_t staggerPointRage;
        float staggerTime;
        float biteParriedTime;
        float scratchParriedTime;
        int32_t knockBackStaggerCount;
        int32_t knockBackPoint;
        float knockBackTime;
        float hardStunTime;
        float cyloopBindTime;
        float cyloopBind2Time;
        float cyloopEscapeHpRatio;
        float cyloopEscapeTime;
        float fallDeadHeight;
        int32_t specialAttackDamage;
        int32_t qte1Damage;
        csl::ut::VariableString accessNodeNames[16];
        heur::rfl::BossDragonHitBoxParam hitBoxes[32];
        heur::rfl::BossDragonHurtBoxParam hurtBoxes[32];
        heur::rfl::BossDragonScratchParam scratch;
        heur::rfl::BossDragonReflectShotParam reflect;
        heur::rfl::BossDragonShotParam shot;
        heur::rfl::BossDragonSpiralShotParam spiral;
        heur::rfl::BossDragonSpiralShotParam spiralAlternate;
        heur::rfl::BossDragonSpiralShotParam spiralVertical;
        heur::rfl::BossDragonSplashShotParam splash;
        heur::rfl::BossDragonHomingLaserParam homingLaser;
        heur::rfl::BossDragonHomingMissileParam homingMissile;
        heur::rfl::BossDragonRippleLaserParam rippleLaser;
        heur::rfl::BossDragonRippleLaserRageParam rippleLaserRage;
        heur::rfl::BossDragonRippleLaserDummyParam rippleLaserDummy;
        heur::rfl::BossDragonWaveParam wave;
        heur::rfl::BossDragonLaserParam laserWinder;
        heur::rfl::BossDragonLaserParam randomLaser;
        heur::rfl::BossDragonCounterLaserParam counterLaser;
        heur::rfl::BossDragonRingSupplyParam ringSupply;
        float damageRates[4];
        heur::rfl::BossDragonLayoutParam layouts[46];
        heur::rfl::BossDragonCameraParam cameras[47];
        heur::rfl::BossDragonMoveParam swapMove;
        heur::rfl::BossDragonRoadParam road;
        heur::rfl::BossDragonLaunchParam launch;
        heur::rfl::BossDragonQuickStepParam quickStep;
        heur::rfl::BossDragonChaseParam chase;
        heur::rfl::BossDragonMissileParam missile;
        BossDragonSequence seq[16];
        BossDragonSequence seq2[16];
        heur::rfl::BossDragonInterruptParam interrupts[8];
        heur::rfl::BossDragonCyloopBindParam cyloopBind;
        heur::rfl::BossDragonParryParam parry[4];
        heur::rfl::BossDragonAttackSignParam attackSign;
        heur::rfl::BossDragonNotifierParam notifier;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossDragonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossDragonConfig* pInstance);
        static void Clean(BossDragonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossGiantPhaseParam {
        enum class ActionType : int8_t {
            AT_NONE = 0,
            AT_HAND_L = 1,
            AT_HAND_R = 2,
            AT_BACKHAND_L = 3,
            AT_BACKHAND_R = 4,
            AT_HEAD = 5,
            AT_HOWL = 6,
            AT_LASER = 7,
            AT_COUNTER_NORMAL = 8,
            AT_COUNTER_SP_01 = 9,
            AT_COUNTER_SP_02 = 10,
            AT_COUNTER_SP_03 = 11,
            AT_ROTATION = 12,
            AT_STEP = 13,
            AT_JUMP = 14,
            AT_TURN = 15,
            NUM_ACTION_TYPE = 16,
        };

        float attackWaitTime;
        float attackSpeedRatio;
        uint32_t knockbackCountMax;
        ActionType attackTypes[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossGiantPhaseParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossGiantPhaseParam* pInstance);
        static void Clean(BossGiantPhaseParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossGiantPhaseAttackActionParam {
        enum class ActionAttribute : int8_t {
            AA_NONE = 0,
            AA_ALL = 1,
            AA_FRONT = 2,
            AA_BACK = 3,
            AA_LEFT = 4,
            AA_RIGHT = 5,
        };

        ActionAttribute attribute1;
        ActionAttribute attribute2;
        float useDistanceMin;
        float useDistanceMax;
        float useHeightMin;
        float useHeightMax;
        float useAngleMin;
        float useAngleMax;
        float useAbsAngleOver;
        float useHpRatioMin;
        float useHpRatioMax;
        float useAreaOver;
        uint32_t priority;
        float coolTime;
        float initCoolTime;
        float readyTime;
        uint32_t consecutiveUsesLimit;
        float consecutiveUsesLimitCoolTime;
        bool isCounterUse;
        bool isCounterOnly;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossGiantPhaseAttackActionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossGiantPhaseAttackActionParam* pInstance);
        static void Clean(BossGiantPhaseAttackActionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossGiantCyloopFloatActionParam {
        float landingCounterHPRatio;
        float floatCounterHPRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossGiantCyloopFloatActionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossGiantCyloopFloatActionParam* pInstance);
        static void Clean(BossGiantCyloopFloatActionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossGiantThresholdRingSupplyParam {
        enum class LaserType : int8_t {
            LT_NONE = 0,
            LT_STRAIGHT = 1,
            LT_HOMING = 2,
        };

        float hpRatio;
        LaserType type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossGiantThresholdRingSupplyParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossGiantThresholdRingSupplyParam* pInstance);
        static void Clean(BossGiantThresholdRingSupplyParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossGiantBattleParam {
        enum class ActionType : int8_t {
            AT_NONE = 0,
            AT_HAND_L = 1,
            AT_HAND_R = 2,
            AT_BACKHAND_L = 3,
            AT_BACKHAND_R = 4,
            AT_HEAD = 5,
            AT_HOWL = 6,
            AT_LASER = 7,
            AT_COUNTER_NORMAL = 8,
            AT_COUNTER_SP_01 = 9,
            AT_COUNTER_SP_02 = 10,
            AT_COUNTER_SP_03 = 11,
            AT_ROTATION = 12,
            AT_STEP = 13,
            AT_JUMP = 14,
            AT_TURN = 15,
            NUM_ACTION_TYPE = 16,
        };

        heur::rfl::BossGiantPhaseParam giantPhaseParams[4];
        heur::rfl::BossGiantPhaseAttackActionParam actionParams[15];
        ActionType immediateActions[20];
        heur::rfl::BossGiantCyloopFloatActionParam cyloopFloatAction;
        heur::rfl::BossGiantThresholdRingSupplyParam thresholdRingSupply[3];
        float thresholdDamageEffectHPRatio[3];
        bool isDebugDraw;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossGiantBattleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossGiantBattleParam* pInstance);
        static void Clean(BossGiantBattleParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossGiantNotifierParam {
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigClimb;
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigBattle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossGiantNotifierParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossGiantNotifierParam* pInstance);
        static void Clean(BossGiantNotifierParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossGiantConfig : heur::rfl::BossBaseConfig {
        heur::rfl::BossGiantBattleParam battleParam;
        heur::rfl::BossGiantNotifierParam notifierParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossGiantConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossGiantConfig* pInstance);
        static void Clean(BossGiantConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightIdleConfig {
        float runSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightIdleConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightIdleConfig* pInstance);
        static void Clean(KnightIdleConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightClimbIdleConfig {
        float moveIntervalAfterSlam;
        float moveIntervalAfterMove;
        float moveIntervalAfterFall;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightClimbIdleConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightClimbIdleConfig* pInstance);
        static void Clean(KnightClimbIdleConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightClimbMoveConfig {
        float speedAvg;
        float angle1Min;
        float angle1Max;
        float angle2Min;
        float angle2Max;
        float move2WaitDuration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightClimbMoveConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightClimbMoveConfig* pInstance);
        static void Clean(KnightClimbMoveConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightClimbSlamLookupCameraConfig {
        float duration;
        float lockonDistance;
        float unlockDistance;
        float distance;
        float minElevation;
        float maxElevation;
        float panningSuspensionK;
        float interiorPanningSuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightClimbSlamLookupCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightClimbSlamLookupCameraConfig* pInstance);
        static void Clean(KnightClimbSlamLookupCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightClimbSlamWaveConfig {
        float interval;
        uint32_t generateNum;
        float coolTime;
        float radius;
        float appearRadius;
        float keepRadius;
        float disappearRadius;
        float heightMin;
        float heightMax;
        float lifeTime;
        float modelScale;
        float modelDiameter;
        float effectDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightClimbSlamWaveConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightClimbSlamWaveConfig* pInstance);
        static void Clean(KnightClimbSlamWaveConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightClimbSlamConfig {
        float rotateSpeedBeforeSlam;
        float slamAnimSpeed;
        float waitTimeAfterSlam;
        float liftUpStartAnimSpeed;
        float liftUpEndAnimSpeed;
        float liftUpStartAnimSpeedMiss;
        float liftUpEndAnimSpeedMiss;
        heur::rfl::KnightClimbSlamLookupCameraConfig lookupCam;
        heur::rfl::KnightClimbSlamWaveConfig wave;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightClimbSlamConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightClimbSlamConfig* pInstance);
        static void Clean(KnightClimbSlamConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightGrindCameraConfig {
        enum class PlayerOffsetType : int8_t {
            PLAYER_OFFSET_NORMAL = 0,
            PLAYER_OFFSET_ABSOLUTE = 1,
        };

        float fovy;
        float zRot;
        float distance;
        float pathOffset;
        bool usePathVerticalComponent;
        bool usePathNormal;
        float angleSensitivity;
        float angleSensitivityBoost;
        float azimuthOffsetDeg;
        float elevationOffsetDeg;
        float gravityOffset;
        csl::math::Vector3 playerOffset;
        PlayerOffsetType playerOffsetType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightGrindCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightGrindCameraConfig* pInstance);
        static void Clean(KnightGrindCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightGrindTrapConfig {
        int32_t damage;
        bool blowOff;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightGrindTrapConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightGrindTrapConfig* pInstance);
        static void Clean(KnightGrindTrapConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightGrindLaunchCameraConfig {
        csl::math::Vector3 lookAtOffset;
        csl::math::Vector3 eyeOffset;
        float duration;
        float easeTimeBegin;
        float easeTimeEnd;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightGrindLaunchCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightGrindLaunchCameraConfig* pInstance);
        static void Clean(KnightGrindLaunchCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightGrindLaunchConfig {
        float outStrength;
        float inStrength;
        float outElev;
        float inElev;
        float speed;
        csl::ut::VariableString landFrameName;
        csl::math::Vector3 landOffset;
        csl::math::Vector3 landRayOffset;
        csl::math::Vector3 landOffsetAfterRaycast;
        heur::rfl::KnightGrindLaunchCameraConfig camera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightGrindLaunchConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightGrindLaunchConfig* pInstance);
        static void Clean(KnightGrindLaunchConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightClimbGrindConfig {
        heur::rfl::KnightGrindCameraConfig camera;
        float playerSpeed;
        heur::rfl::KnightGrindTrapConfig trap;
        heur::rfl::KnightGrindLaunchConfig launch;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightClimbGrindConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightClimbGrindConfig* pInstance);
        static void Clean(KnightClimbGrindConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightClimbTraceWaveConfig {
        float traceSpeed;
        float traceRotSpeed;
        float traceLifeTime;
        float traceWidth;
        float traceHeight;
        float traceAppearDistance;
        float traceKeepDistance;
        float traceDisappearDistance;
        float traceModelScale;
        float traceModelDiameter;
        float traceModelInterval;
        float traceCollisionDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightClimbTraceWaveConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightClimbTraceWaveConfig* pInstance);
        static void Clean(KnightClimbTraceWaveConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightClimbConfig {
        heur::rfl::KnightClimbIdleConfig idle;
        heur::rfl::KnightClimbMoveConfig move;
        heur::rfl::KnightClimbSlamConfig slam;
        heur::rfl::KnightClimbGrindConfig grind;
        float climbTimeLimit;
        heur::rfl::KnightClimbTraceWaveConfig trace;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightClimbConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightClimbConfig* pInstance);
        static void Clean(KnightClimbConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle1IdleConfig {
        float moveInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle1IdleConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle1IdleConfig* pInstance);
        static void Clean(KnightBattle1IdleConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle1MoveConfig {
        float speedAvg;
        float angle1Min;
        float angle1Max;
        float angle2Min;
        float angle2Max;
        float move2WaitDuration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle1MoveConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle1MoveConfig* pInstance);
        static void Clean(KnightBattle1MoveConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle1GuardConfig {
        float guardStaggerMax;
        float damageStaggerMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle1GuardConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle1GuardConfig* pInstance);
        static void Clean(KnightBattle1GuardConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightShieldRideConfig {
        float startDistance;
        float startXOffset;
        float startYOffset;
        float startAngle;
        float speed;
        float turnAcc;
        float turnSpeedMax;
        float areaRadius;
        float windPowerMin;
        float windPowerMax;
        float windTimeMin;
        float windTimeMax;
        float windInterval;
        float camRideElevation;
        float camRideDistance;
        csl::math::Vector3 camRideOffset;
        float camCompeteElevation;
        float camCompeteAzimuth;
        float camCompeteDistance;
        float camHitElevation;
        float camHitAzimuth;
        float camHitDistance;
        float camShakeHitLoopMagnitude;
        int32_t camShakeHitLoopFreq;
        float camShakeRejectLoopMagnitude;
        int32_t camShakeRejectLoopFreq;
        uint8_t missileNum;
        float missileInterval;
        float missileStartTime;
        float missileSpeed;
        float missileRotateSpeed;
        float missileMidPosDistance;
        float missileMidPosHeightOffset;
        float missileShotAngle;
        float missileShotStartWait;
        float missileRiseSpeed;
        float missileRiseTime;
        float missileHideTime;
        float missileAppearDistance;
        float missileAppearHeight;
        float missileAppearWidth;
        float missileLifeTime;
        float missileLifeTimeNoHit;
        float missileHitPower;
        float missileHitPowerRateDown;
        float missileHitPowerKeepTime;
        float missileHeightShakeMax;
        float missileHeightShakeMin;
        float missileWidthShake;
        float rejectCompeteDuration;
        float hitShaveDamageSum;
        uint32_t hitShaveHitNum;
        float hitShaveHitInterval;
        float damageRatio;
        float staggerValue;
        float knockbackDistance;
        float durationAfterHit;
        uint32_t missileHitPattern[10];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightShieldRideConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightShieldRideConfig* pInstance);
        static void Clean(KnightShieldRideConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle1InterruptConfig {
        float parriedDuration;
        float slowRate;
        float slowTime;
        float cameraOffset;
        float cameraFade;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle1InterruptConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle1InterruptConfig* pInstance);
        static void Clean(KnightBattle1InterruptConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle1CyFloat {
        float height;
        float riseDuration;
        float floatDuration;
        float fallDuration;
        float cyFallDuration;
        float cyFallDelay;
        float downDuration;
        float enableDownCounterHPRatio;
        float enableGuardHPRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle1CyFloat* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle1CyFloat* pInstance);
        static void Clean(KnightBattle1CyFloat* pInstance);
    };
}

namespace heur::rfl {
    struct KnightThresholdRingSupplyParam {
        float hpRatio;
        int32_t missileNum;
        float missileWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightThresholdRingSupplyParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightThresholdRingSupplyParam* pInstance);
        static void Clean(KnightThresholdRingSupplyParam* pInstance);
    };
}

namespace heur::rfl {
    struct KnightRageShieldAttackCameraConfig {
        float interpolateTimeBegin;
        float interpolateTimeEnd;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightRageShieldAttackCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightRageShieldAttackCameraConfig* pInstance);
        static void Clean(KnightRageShieldAttackCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightRageShieldConfig {
        float modelScale;
        float hitEffectScale;
        float actionGuideOffsetX;
        float actionGuideOffsetY;
        float heightOffset;
        float flySpeed;
        float flyLineWidth;
        float flyLineAfterHitWallLength;
        float flyLineDuration;
        float hitWallTargetingStart;
        float hitWallTargetingAdd;
        float hitWallTargetingSub;
        float hitWallTargeting;
        uint8_t hitWallTargetingCycle;
        float hitWallTargetAreaRadius;
        float hitWallStopDuration;
        float hitWallFlySpeed;
        float hitWallAccStartTime;
        float hitWallAccDuration;
        float parryTargetRange;
        float parryTargetAngVel;
        float parryTargetTimeLimit;
        float parryTargetLineWidth;
        float parryTargetLineLength;
        float parryFlySpeedStart;
        float parryFlySpeed;
        float parryAccStartTime;
        float parryAccDuration;
        float parryFlyLineWidth;
        float parryFlyLineDuration;
        float parryFlySuspendDuration;
        float parryFlySuspendEndDistance;
        heur::rfl::KnightRageShieldAttackCameraConfig attackCamera;
        float damageRatio;
        float damageVelocity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightRageShieldConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightRageShieldConfig* pInstance);
        static void Clean(KnightRageShieldConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightRageOverlookCameraConfig {
        float azimuth;
        float elevation;
        float distance;
        float zRoll;
        float fovy;
        csl::math::Vector3 offset;
        float followPlayerRatio;
        float lookCenterRatio;
        float interpolateTimeBegin;
        float interpolateTimeEnd;
        float controlAngAcc;
        float controlAngVel;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightRageOverlookCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightRageOverlookCameraConfig* pInstance);
        static void Clean(KnightRageOverlookCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle1Rage {
        heur::rfl::KnightRageShieldConfig shield;
        heur::rfl::KnightRageOverlookCameraConfig normalCamera;
        heur::rfl::KnightRageOverlookCameraConfig targetingCamera;
        float moveRestartAnimSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle1Rage* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle1Rage* pInstance);
        static void Clean(KnightBattle1Rage* pInstance);
    };
}

namespace heur::rfl {
    struct KnightAerialCamera {
        float downTime;
        float downCutChangeTime[2];
        csl::math::Vector3 downCamOffset;
        float riseTime;
        csl::math::Vector3 riseCamOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightAerialCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightAerialCamera* pInstance);
        static void Clean(KnightAerialCamera* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle1Config {
        float closedAreaRadius;
        heur::rfl::KnightBattle1IdleConfig idle;
        heur::rfl::KnightBattle1MoveConfig move;
        heur::rfl::KnightBattle1GuardConfig guard;
        heur::rfl::KnightShieldRideConfig shieldRide;
        heur::rfl::KnightBattle1InterruptConfig interrupt;
        float normalKnockbackDistance;
        heur::rfl::KnightBattle1CyFloat cyFloat;
        heur::rfl::KnightThresholdRingSupplyParam ringSupply[3];
        heur::rfl::KnightBattle1Rage rage;
        float rageHPRatio;
        float atkSpecialHPRatio;
        heur::rfl::KnightAerialCamera aerialCamera;
        float damageEventTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle1Config* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle1Config* pInstance);
        static void Clean(KnightBattle1Config* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2RunCamera {
        float azimuth;
        float elevation;
        float distance;
        float zRoll;
        float fovy;
        csl::math::Vector3 frameOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2RunCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2RunCamera* pInstance);
        static void Clean(KnightBattle2RunCamera* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2RunConfig {
        float speed;
        float moveWidth;
        float moveHeight;
        csl::math::Vector3 playerOffset;
        csl::math::Vector3 playerOffsetFar;
        csl::math::Vector3 playerOffsetNear;
        csl::math::Vector3 playerOffsetTackle;
        float attackInterval;
        float attackIntervalDelayOnHit;
        heur::rfl::KnightBattle2RunCamera camera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2RunConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2RunConfig* pInstance);
        static void Clean(KnightBattle2RunConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2ShieldSplineNode {
        enum class XType : uint8_t {
            Zero = 0,
            HitPosX = 1,
            Indivisual = 2,
        };

        bool enable;
        XType xType;
        float xIndivisual;
        float y;
        float z;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2ShieldSplineNode* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2ShieldSplineNode* pInstance);
        static void Clean(KnightBattle2ShieldSplineNode* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2ShieldUTurnCameraConfig {
        float duration;
        float interpolateTimeBegin;
        float interpolateTimeEnd;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2ShieldUTurnCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2ShieldUTurnCameraConfig* pInstance);
        static void Clean(KnightBattle2ShieldUTurnCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2ShieldConfig {
        heur::rfl::KnightBattle2ShieldSplineNode nodesStraight[8];
        float stopPosRatioStraight;
        float stopDecStartPosRatioStraight;
        float stopAccEndPosRatioStraight;
        float stopDurationStraight;
        float speedStraight1;
        float speedStraight2;
        float hitPosXStraight;
        float uTurnEndPosStraight;
        float swordDelayStraight;
        heur::rfl::KnightBattle2ShieldSplineNode nodesSlalom[8];
        float stopPosRatioSlalom;
        float stopDecStartPosRatioSlalom;
        float stopAccEndPosRatioSlalom;
        float stopDurationSlalom;
        float speedSlalom1;
        float speedSlalom2;
        float hitPosXSlalom;
        float uTurnEndPosSlalom;
        float magnitudeSlalomFar;
        float magnitudeSlalomNear;
        uint8_t slalomNumMin;
        uint8_t slalomNumMax;
        float slalomEndPosRatio;
        float swordDelaySlalom;
        float uTurnSpeedRatioDuringCam;
        float uTurnSpeedRatioAfterCam;
        heur::rfl::KnightBattle2ShieldUTurnCameraConfig uTurnCamera;
        float attackLineWidth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2ShieldConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2ShieldConfig* pInstance);
        static void Clean(KnightBattle2ShieldConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2SwordConfig {
        float parriedDuration;
        float animSpeedOnDoubleAtkParried;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2SwordConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2SwordConfig* pInstance);
        static void Clean(KnightBattle2SwordConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2InterruptConfig {
        float parriedDuration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2InterruptConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2InterruptConfig* pInstance);
        static void Clean(KnightBattle2InterruptConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2CyFloat {
        float height;
        float riseDuration;
        float floatDuration;
        float fallDuration;
        float cyFallDuration;
        float cyFallDelay;
        float downDuration;
        float enableDownCounterHPRatio;
        float enableGuardHPRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2CyFloat* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2CyFloat* pInstance);
        static void Clean(KnightBattle2CyFloat* pInstance);
    };
}

namespace heur::rfl {
    struct KnightBattle2Config {
        heur::rfl::KnightBattle2RunConfig run;
        heur::rfl::KnightBattle2ShieldConfig shield;
        heur::rfl::KnightBattle2SwordConfig sword;
        heur::rfl::KnightBattle2InterruptConfig interrupt;
        float knockbackDistance;
        heur::rfl::KnightBattle2CyFloat cyFloat;
        heur::rfl::KnightAerialCamera aerialCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightBattle2Config* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightBattle2Config* pInstance);
        static void Clean(KnightBattle2Config* pInstance);
    };
}

namespace heur::rfl {
    struct KnightSonicSpecialConfig {
        float damageRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightSonicSpecialConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightSonicSpecialConfig* pInstance);
        static void Clean(KnightSonicSpecialConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightCyFloatSpearConfig {
        csl::math::Vector3 upOffset[8];
        csl::math::Vector3 upRotationAngle[8];
        float upMoveDistanceOffset;
        csl::math::Vector3 downOffset;
        float downMoveDelay;
        float downMoveDistance[3];
        float downMoveDuration[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightCyFloatSpearConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightCyFloatSpearConfig* pInstance);
        static void Clean(KnightCyFloatSpearConfig* pInstance);
    };
}

namespace heur::rfl {
    struct KnightAttackSignParam {
        float delayTime[6];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnightAttackSignParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnightAttackSignParam* pInstance);
        static void Clean(KnightAttackSignParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossKnightNotifierParam {
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigClimb;
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigBattle1;
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigBattle2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossKnightNotifierParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossKnightNotifierParam* pInstance);
        static void Clean(BossKnightNotifierParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossKnightConfig : heur::rfl::BossBaseConfig {
        heur::rfl::KnightIdleConfig idle;
        heur::rfl::KnightClimbConfig climb;
        heur::rfl::KnightBattle1Config battle1;
        heur::rfl::KnightBattle2Config battle2;
        heur::rfl::KnightSonicSpecialConfig sonicSpecial;
        heur::rfl::KnightCyFloatSpearConfig cyFloatSpear;
        uint8_t knockbackStaggerCount;
        float thresholdDamageEffectHPRatio[3];
        heur::rfl::KnightAttackSignParam attackSign;
        heur::rfl::BossKnightNotifierParam notifier;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossKnightConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossKnightConfig* pInstance);
        static void Clean(BossKnightConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleAttackData {
        enum class ActionType : int8_t {
            AT_NONE = 0,
            AT_HAND_L = 1,
            AT_HAND_R = 2,
            AT_SHOT1 = 3,
            AT_SHOT2 = 4,
            AT_SHOT3 = 5,
            AT_SHOT4 = 6,
            AT_QTE_NONE = 7,
            AT_WAIT = 8,
            AT_LASER = 9,
            AT_HOMINGLASER_NORMAL = 10,
            AT_HOMINGLASER_FLY = 11,
            AT_BIT_WAVE = 12,
            AT_BIT_WAVE_END = 13,
            AT_COUNTER_BLOW = 14,
            AT_SP01 = 15,
            AT_SP02 = 16,
            NUM_ACTION_TYPE = 17,
        };

        ActionType attackType;
        csl::ut::VariableString waveName;
        csl::ut::VariableString subWaveName;
        float actionTime;
        int16_t nextStep;
        bool isBitActionReset;
        bool isFlyMoveReverse;
        bool isFlyWait;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleAttackData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleAttackData* pInstance);
        static void Clean(BossRifleAttackData* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleAttackPatternParam {
        heur::rfl::BossRifleAttackData attackDatas[16];
        heur::rfl::BossRifleAttackData bitBreakAttackDatas[2];
        uint32_t breakBitNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleAttackPatternParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleAttackPatternParam* pInstance);
        static void Clean(BossRifleAttackPatternParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleAttackHandLaserPatternParam {
        float intarvalDistance;
        float delay;
        csl::math::Vector3 localStartPos;
        csl::math::Vector3 localEndPos;
        csl::math::Vector3 localStartDir;
        csl::math::Vector3 localEndDir;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleAttackHandLaserPatternParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleAttackHandLaserPatternParam* pInstance);
        static void Clean(BossRifleBattleAttackHandLaserPatternParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleAttackHandLaser {
        float bulletRadius;
        float bulletSpeed;
        float wayAngle;
        uint32_t wayNum;
        float limitDistance;
        float blowoffSpeed;
        float outOfControlTime;
        float keepVelocity;
        heur::rfl::BossRifleBattleAttackHandLaserPatternParam handLeftPatterns[4];
        heur::rfl::BossRifleBattleAttackHandLaserPatternParam handRightPatterns[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleAttackHandLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleAttackHandLaser* pInstance);
        static void Clean(BossRifleBattleAttackHandLaser* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleAttackHomingLaserShotPoint {
        bool isParry;
        bool isUse;
        float shotDirElevation;
        float shotDirRoll;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleAttackHomingLaserShotPoint* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleAttackHomingLaserShotPoint* pInstance);
        static void Clean(BossRifleBattleAttackHomingLaserShotPoint* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleAttackHomingLaserAttackParam {
        csl::ut::VariableString nodeName;
        csl::math::Vector3 nodePos;
        csl::math::Vector3 nodeFront;
        csl::math::Vector3 nodeAxis;
        float straightKeepTime;
        uint32_t parryMax;
        uint32_t num;
        uint32_t countMax;
        float initSpeed;
        float speed;
        float acceleDelay;
        float acceleTime;
        float interval;
        float intervals[8];
        float delay;
        heur::rfl::BossRifleBattleAttackHomingLaserShotPoint points[32];
        csl::math::Vector3 fixedCameraEyePos;
        csl::math::Vector3 fixedCameraLookAtPos;
        float fixedCameraDelay;
        float fixedCameraTime;
        float fixedCameraStartEaseTime;
        float fixedCameraEndEaseTime;
        csl::math::Vector3 parryCameraEyePos;
        csl::math::Vector3 parryCameraLookAtPos;
        float parryCameraStartEaseTime;
        float parryCameraEndEaseTime;
        bool isParrySlow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleAttackHomingLaserAttackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleAttackHomingLaserAttackParam* pInstance);
        static void Clean(BossRifleBattleAttackHomingLaserAttackParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleAttackHomingLaser {
        float bulletScale;
        float parryMoveTime;
        heur::rfl::BossRifleBattleAttackHomingLaserAttackParam headShotParam;
        heur::rfl::BossRifleBattleAttackHomingLaserAttackParam headShotFlyParam;
        heur::rfl::BossRifleBattleAttackHomingLaserAttackParam normalShotParam;
        bool isDebugDraw;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleAttackHomingLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleAttackHomingLaser* pInstance);
        static void Clean(BossRifleBattleAttackHomingLaser* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleZoomCamera {
        float distance;
        float elevation;
        float playerHeight;
        float easeInTime;
        float easeOutTime;
        float changeParamDistanceMin;
        float changeParamDistanceMax;
        float addDistance;
        float addElevation;
        float addPlayerHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleZoomCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleZoomCamera* pInstance);
        static void Clean(BossRifleBattleZoomCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleCameraParam {
        heur::rfl::BossRifleBattleZoomCamera normalCamera[2];
        heur::rfl::BossRifleBattleZoomCamera flyCamera[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleCameraParam* pInstance);
        static void Clean(BossRifleBattleCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleFlyParam {
        float flyHeight;
        float flyRotationSpeed;
        float flyMoveHitDamageDownSpeedRatio;
        float flyMoveHitDamageDownSpeedTime;
        float flyMoveSpeed;
        float flyMoveCircleRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleFlyParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleFlyParam* pInstance);
        static void Clean(BossRifleBattleFlyParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRiflePhaseParam {
        float attackWaitTime;
        float attackSpeedRatio;
        uint32_t knockbackCountMax;
        heur::rfl::BossRifleAttackPatternParam patterns[4];
        float patternChangeHpRatios[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRiflePhaseParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRiflePhaseParam* pInstance);
        static void Clean(BossRiflePhaseParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRiflePhaseAttackActionParam {
        enum class ActionAttribute : int8_t {
            AA_NONE = 0,
            AA_ALL = 1,
            AA_FRONT = 2,
            AA_BACK = 3,
            AA_LEFT = 4,
            AA_RIGHT = 5,
        };

        ActionAttribute attribute1;
        ActionAttribute attribute2;
        float useDistanceMin;
        float useDistanceMax;
        float useHeightMin;
        float useHeightMax;
        float useAngleMin;
        float useAngleMax;
        float useAbsAngleOver;
        float useHpRatioMin;
        float useHpRatioMax;
        float useAreaOver;
        uint32_t priority;
        float coolTime;
        float initCoolTime;
        float readyTime;
        uint32_t consecutiveUsesLimit;
        float consecutiveUsesLimitCoolTime;
        bool isCounterUse;
        bool isCounterOnly;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRiflePhaseAttackActionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRiflePhaseAttackActionParam* pInstance);
        static void Clean(BossRiflePhaseAttackActionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleCyloopFloatActionParam {
        float landingCounterHPRatio;
        float floatCounterHPRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleCyloopFloatActionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleCyloopFloatActionParam* pInstance);
        static void Clean(BossRifleCyloopFloatActionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleParrySlowParam {
        float scale;
        float time;
        float easeOutTime;
        bool cameraSlow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleParrySlowParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleParrySlowParam* pInstance);
        static void Clean(BossRifleParrySlowParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleParryParam {
        heur::rfl::BossRifleParrySlowParam homingLaserParrySlow;
        heur::rfl::BossRifleParrySlowParam homingLaserLastParrySlow;
        heur::rfl::BossRifleParrySlowParam homingLaserOneShotParrySlow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleParryParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleParryParam* pInstance);
        static void Clean(BossRifleParryParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBattleParam {
        enum class ActionType : int8_t {
            AT_NONE = 0,
            AT_HAND_L = 1,
            AT_HAND_R = 2,
            AT_SHOT1 = 3,
            AT_SHOT2 = 4,
            AT_SHOT3 = 5,
            AT_SHOT4 = 6,
            AT_QTE_NONE = 7,
            AT_WAIT = 8,
            AT_LASER = 9,
            AT_HOMINGLASER_NORMAL = 10,
            AT_HOMINGLASER_FLY = 11,
            AT_BIT_WAVE = 12,
            AT_BIT_WAVE_END = 13,
            AT_COUNTER_BLOW = 14,
            AT_SP01 = 15,
            AT_SP02 = 16,
            NUM_ACTION_TYPE = 17,
        };

        heur::rfl::BossRiflePhaseParam giantPhaseParams[4];
        heur::rfl::BossRiflePhaseAttackActionParam actionParams[16];
        ActionType immediateActions[20];
        heur::rfl::BossRifleCyloopFloatActionParam cyloopFloatAction;
        heur::rfl::BossRifleBattleAttackHomingLaser attackHomingLaser;
        heur::rfl::BossRifleBattleAttackHandLaser attackHandLaser;
        heur::rfl::BossRifleBattleFlyParam flyParam;
        heur::rfl::BossRifleBattleCameraParam cameraParam;
        heur::rfl::BossRifleParryParam parryParam;
        float thresholdDamageEffectHPRatio[3];
        float qteSucceedWaitTimes[4];
        bool isDebugDraw;
        bool isSkip;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBattleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBattleParam* pInstance);
        static void Clean(BossRifleBattleParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleNotifierParam {
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigBattle1;
        heur::rfl::EnemyPracticeNotifierConfig notifierConfigBattle2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleNotifierParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleNotifierParam* pInstance);
        static void Clean(BossRifleNotifierParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleConfig : heur::rfl::BossBaseConfig {
        heur::rfl::BossRifleBattleParam battleParam;
        heur::rfl::BossRifleNotifierParam notifierParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleConfig* pInstance);
        static void Clean(BossRifleConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleThresholdRingSupplyParam {
        enum class LaserType : int8_t {
            LT_NONE = 0,
            LT_STRAIGHT = 1,
            LT_HOMING = 2,
        };

        float hpRatio;
        LaserType type;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleThresholdRingSupplyParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleThresholdRingSupplyParam* pInstance);
        static void Clean(BossRifleThresholdRingSupplyParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleArmSetting {
        float angleSide;
        float angleFront;
        float upLine;
        float linePos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleArmSetting* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleArmSetting* pInstance);
        static void Clean(BossRifleBeastBattleArmSetting* pInstance);
    };
}

namespace heur::rfl {
    struct RifleBeastClawCamera {
        csl::math::Vector3 camLookAtOffset;
        csl::math::Vector3 camEyeOffset;
        float camFovy;
        float camEaseInTime;
        float camEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RifleBeastClawCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RifleBeastClawCamera* pInstance);
        static void Clean(RifleBeastClawCamera* pInstance);
    };
}

namespace heur::rfl {
    struct RifleBeastClawRange {
        float useDistanceMin;
        float useDistanceMax;
        float useHeightMin;
        float useHeightMax;
        float useAngleMin;
        float useAngleMax;
        float useAbsAngleOver;
        float useAreaOver;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RifleBeastClawRange* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RifleBeastClawRange* pInstance);
        static void Clean(RifleBeastClawRange* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleAttackHomingLaserBase {
        enum class ArmType : int8_t {
            AL = 0,
            BL = 1,
            C = 2,
            BR = 3,
            AR = 4,
            NUM_ACTION_TYPE = 5,
        };

        float waitTime;
        ArmType armNum;
        bool isContinuousFire;
        float plusSpeed;
        bool useSpecialCamera;
        bool useUpMotion;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleAttackHomingLaserBase* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleAttackHomingLaserBase* pInstance);
        static void Clean(BossRifleBeastBattleAttackHomingLaserBase* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleAttackHomingLaserPattern {
        enum class CameraType : int8_t {
            CameraPatern0 = 0,
            CameraPatern1 = 1,
            CameraPatern2 = 2,
            CameraPatern3 = 3,
            CameraPatern4 = 4,
            NUM_ACTION_TYPE = 5,
        };

        heur::rfl::BossRifleBeastBattleAttackHomingLaserBase patterns[20];
        int32_t laserNum;
        CameraType cameraPatern;
        float endCamera;
        float delayCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleAttackHomingLaserPattern* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleAttackHomingLaserPattern* pInstance);
        static void Clean(BossRifleBeastBattleAttackHomingLaserPattern* pInstance);
    };
}

namespace heur::rfl {
    struct RifleBeastClawQTE {
        float QTEStunTime;
        heur::rfl::BossRifleBeastBattleAttackHomingLaserPattern laserPattern;
        float FirstShot;
        float IntervalShot;
        csl::math::Vector3 QTEPlayerPos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RifleBeastClawQTE* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RifleBeastClawQTE* pInstance);
        static void Clean(RifleBeastClawQTE* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleAttackClaw {
        heur::rfl::RifleBeastClawCamera camera[2];
        heur::rfl::RifleBeastClawRange range;
        float waitTime;
        float damageWaitTime;
        csl::math::Vector3 playerPos[2];
        float stateWaitTime;
        bool useSlow;
        heur::rfl::RifleBeastClawQTE QTEParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleAttackClaw* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleAttackClaw* pInstance);
        static void Clean(BossRifleBeastBattleAttackClaw* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleAttackHomingLaser {
        float radius;
        float speed;
        int32_t EasyDamage;
        int32_t NormalDamage;
        int32_t HardDamage;
        int32_t VeryHardDamage;
        int32_t EnemyDamage;
        float velocity;
        float velocityKeepTime;
        float controlTime;
        int32_t spritBomb;
        float homingRatio;
        heur::rfl::BossRifleBeastBattleArmSetting armSet[5];
        float motionSeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleAttackHomingLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleAttackHomingLaser* pInstance);
        static void Clean(BossRifleBeastBattleAttackHomingLaser* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleAttackPattern {
        enum class AtackType : int8_t {
            AT_HIMING00 = 0,
            AT_HIMING01 = 1,
            AT_HIMING02 = 2,
            AT_HIMING03 = 3,
            AT_HIMING04 = 4,
            AT_HIMING05 = 5,
            AT_HIMING06 = 6,
            AT_HIMING07 = 7,
            AT_HIMING08 = 8,
            AT_HIMING09 = 9,
            AT_CROW_L = 10,
            AT_CROW_R = 11,
            AT_TACKLE = 12,
            NUM_ACTION_TYPE = 13,
        };

        AtackType attackPattern[10];
        int32_t attackNum;
        bool isUse;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleAttackPattern* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleAttackPattern* pInstance);
        static void Clean(BossRifleBeastBattleAttackPattern* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleZoomCamera {
        float distance;
        float elevation;
        float playerHeight;
        float easeInTime;
        float easeOutTime;
        float changeParamDistanceMin;
        float changeParamDistanceMax;
        float addDistance;
        float addElevation;
        float addPlayerHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleZoomCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleZoomCamera* pInstance);
        static void Clean(BossRifleBeastBattleZoomCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCameraParam {
        heur::rfl::BossRifleBeastBattleZoomCamera normalCamera[6];
        heur::rfl::BossRifleBeastBattleZoomCamera homingCamera[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCameraParam* pInstance);
        static void Clean(BossRifleBeastBattleCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopFocusFrameCamera {
        csl::ut::VariableString nodeName;
        float fovyDeg;
        float rollDeg;
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraOffset;
        float delayTime;
        float playTime;
        float easeInTime;
        float easeOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopFocusFrameCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopFocusFrameCamera* pInstance);
        static void Clean(BossRifleBeastBattleCyloopFocusFrameCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopCameraFixedCamera {
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraOffset;
        float fovyDeg;
        float rollDeg;
        float easeInTime;
        float easeOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopCameraFixedCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopCameraFixedCamera* pInstance);
        static void Clean(BossRifleBeastBattleCyloopCameraFixedCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopCameraShake {
        bool enabled;
        float waitTime;
        float magnitude;
        float shakeTime;
        float attnRatio;
        uint8_t freq;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopCameraShake* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopCameraShake* pInstance);
        static void Clean(BossRifleBeastBattleCyloopCameraShake* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopCamera {
        heur::rfl::BossRifleBeastBattleCyloopFocusFrameCamera cameraFocus;
        heur::rfl::BossRifleBeastBattleCyloopCameraFixedCamera cameraFixed;
        heur::rfl::BossRifleBeastBattleCyloopCameraShake cameraShakePress;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopCamera* pInstance);
        static void Clean(BossRifleBeastBattleCyloopCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopLaserCamera {
        csl::math::Vector3 camLookAtOffset;
        csl::math::Vector3 camEyeOffset;
        float camFovy;
        float camEaseInTime;
        float camEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopLaserCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopLaserCamera* pInstance);
        static void Clean(BossRifleBeastBattleCyloopLaserCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopEffectPos {
        csl::math::Vector3 toptOffset;
        csl::math::Vector3 bottomOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopEffectPos* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopEffectPos* pInstance);
        static void Clean(BossRifleBeastBattleCyloopEffectPos* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastParrySlowParam {
        float scale;
        float time;
        float easeOutTime;
        float delayTime;
        bool cameraSlow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastParrySlowParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastParrySlowParam* pInstance);
        static void Clean(BossRifleBeastParrySlowParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloop {
        float restraintTime;
        float pressDamageRatio;
        float playerHeight;
        float beginPressDelay;
        float blowAwayCameraTime;
        int32_t counterDamage;
        csl::math::Vector3 warpOffset;
        bool isUsePressVibration;
        csl::ut::VariableString pressVibrationName;
        csl::math::Vector3 pressPlayerPos;
        heur::rfl::BossRifleBeastBattleCyloopCamera camera;
        float StartBlowTime;
        float LaserRadius;
        float LaserHight;
        float keepCameraTime;
        csl::math::Vector3 cunterWarpOffset;
        heur::rfl::BossRifleBeastBattleCyloopLaserCamera laserCamera;
        heur::rfl::BossRifleBeastBattleCyloopEffectPos EffectPos;
        float waitTime;
        heur::rfl::BossRifleBeastParrySlowParam slowSetting;
        float effectSize;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloop* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloop* pInstance);
        static void Clean(BossRifleBeastBattleCyloop* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopAttackHomingLaser {
        heur::rfl::BossRifleBeastBattleArmSetting armSet[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopAttackHomingLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopAttackHomingLaser* pInstance);
        static void Clean(BossRifleBeastBattleCyloopAttackHomingLaser* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopBlowOffCamera {
        float blowAwayTime;
        heur::rfl::BossRifleBeastBattleCyloopFocusFrameCamera blowUpCamera;
        heur::rfl::BossRifleBeastBattleCyloopCameraFixedCamera cameraFixed;
        heur::rfl::BossRifleBeastBattleCyloopCameraShake cameraShakePress;
        heur::rfl::BossRifleBeastBattleCyloopFocusFrameCamera landingCamera;
        heur::rfl::BossRifleBeastBattleCyloopCameraShake cameraShakeLanding;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopBlowOffCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopBlowOffCamera* pInstance);
        static void Clean(BossRifleBeastBattleCyloopBlowOffCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopBlowOffLaser {
        float changeDelay;
        float speed;
        float blowOffPower;
        float blowOffUpRate;
        float controlTime;
        float slowScale;
        float slowTime;
        float slowEaseOutTime;
        heur::rfl::BossRifleBeastBattleAttackHomingLaserPattern laserPattern;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopBlowOffLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopBlowOffLaser* pInstance);
        static void Clean(BossRifleBeastBattleCyloopBlowOffLaser* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopBlowOff {
        float restraintTime;
        float pressDamageRatio;
        float playerHeight;
        float floatHeight;
        float floatHeightChangeDelay;
        float floatHeightChangeTime;
        float playerMoveTime;
        float playerCurveDistance;
        csl::math::Vector3 playerPosFixedOffset;
        csl::math::Vector3 pressPlayerPos;
        bool isUsePressVibration;
        csl::ut::VariableString pressVibrationName;
        bool isUseLandingVibration;
        csl::ut::VariableString landingVibrationName;
        csl::math::Vector3 landingPlayerOffSet;
        heur::rfl::BossRifleBeastBattleCyloopBlowOffCamera camera;
        heur::rfl::BossRifleBeastBattleCyloopBlowOffLaser laser;
        heur::rfl::BossRifleBeastBattleCyloopEffectPos EffectPos;
        heur::rfl::BossRifleBeastParrySlowParam slowSetting;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopBlowOff* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopBlowOff* pInstance);
        static void Clean(BossRifleBeastBattleCyloopBlowOff* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleCyloopState {
        heur::rfl::BossRifleBeastBattleCyloop cyloop;
        heur::rfl::BossRifleBeastBattleCyloopBlowOff blowOff;
        float cyloopDamageRate;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleCyloopState* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleCyloopState* pInstance);
        static void Clean(BossRifleBeastBattleCyloopState* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleDownRifle {
        float angleX;
        float angleY;
        float angleZ;
        csl::math::Vector3 endPosition;
        csl::math::Vector3 collOffset;
        csl::math::Vector3 collEndOffset;
        float collSize;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleDownRifle* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleDownRifle* pInstance);
        static void Clean(BossRifleBeastBattleDownRifle* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleDownState {
        float waitTime;
        uint16_t lowerHP;
        float fase4DownTime;
        bool isPlayerFixHeight;
        float playerHeight;
        heur::rfl::BossRifleBeastBattleDownRifle rifle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleDownState* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleDownState* pInstance);
        static void Clean(BossRifleBeastBattleDownState* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleFirstAttackHomingLaserPattern {
        enum class CameraType : int8_t {
            CameraPatern0 = 0,
            CameraPatern1 = 1,
            CameraPatern2 = 2,
            CameraPatern3 = 3,
            CameraPatern4 = 4,
            NUM_ACTION_TYPE = 5,
        };

        heur::rfl::BossRifleBeastBattleAttackHomingLaserBase patterns[20];
        uint16_t Num;
        int32_t laserNum;
        float endTime;
        CameraType cameraPatern;
        float endCamera;
        float delayCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleFirstAttackHomingLaserPattern* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleFirstAttackHomingLaserPattern* pInstance);
        static void Clean(BossRifleBeastBattleFirstAttackHomingLaserPattern* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastPhaseAttackActionParam {
        float coolTime;
        float initCoolTime;
        float cableDamege;
        float cableRecoveryTime;
        float cableRecovering;
        uint16_t cableLowestHp;
        float changePatternHP;
        float changeHP;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastPhaseAttackActionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastPhaseAttackActionParam* pInstance);
        static void Clean(BossRifleBeastPhaseAttackActionParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleSonic2FirstAttackHomingLaserPattern {
        enum class CameraType : int8_t {
            CameraPatern0 = 0,
            CameraPatern1 = 1,
            CameraPatern2 = 2,
            CameraPatern3 = 3,
            CameraPatern4 = 4,
            NUM_ACTION_TYPE = 5,
        };

        heur::rfl::BossRifleBeastBattleAttackHomingLaserBase patterns[8];
        uint16_t Num;
        int32_t laserNum;
        CameraType cameraPatern;
        float endCamera;
        float delayCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleSonic2FirstAttackHomingLaserPattern* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleSonic2FirstAttackHomingLaserPattern* pInstance);
        static void Clean(BossRifleBeastBattleSonic2FirstAttackHomingLaserPattern* pInstance);
    };
}

namespace heur::rfl {
    struct RifleBeastTackleCamera {
        csl::math::Vector3 camLookAtOffset;
        csl::math::Vector3 camEyeOffset;
        float camFovy;
        float camEaseInTime;
        float camEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RifleBeastTackleCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RifleBeastTackleCamera* pInstance);
        static void Clean(RifleBeastTackleCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleTackleCamera {
        csl::ut::VariableString nodeName;
        float fovyDeg;
        float rollDeg;
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraOffset;
        float playTime;
        float easeInTime;
        float easeOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleTackleCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleTackleCamera* pInstance);
        static void Clean(BossRifleBeastBattleTackleCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleTackle {
        heur::rfl::RifleBeastTackleCamera barrierCamera;
        heur::rfl::RifleBeastTackleCamera behindCamera;
        float cameraDirection;
        float cameraHight;
        int32_t easyBarrierHP;
        int32_t normalBarrierHP;
        int32_t hardBarrierHP;
        int32_t veryHardBarrierHP;
        int32_t tackleDamage;
        float parryDistance;
        float waitTime;
        float damageWaitTime;
        csl::math::Vector3 tackleColliderOffset;
        csl::math::Vector3 tackleColliderSize;
        heur::rfl::BossRifleBeastBattleCyloopCameraShake cameraShake;
        int32_t drummingNum[10];
        csl::math::Vector3 playerPos;
        float drummingTime;
        float playerHoldTime;
        heur::rfl::BossRifleBeastBattleTackleCamera playerCamera;
        heur::rfl::BossRifleBeastBattleTackleCamera playerCamera2;
        csl::math::Vector3 BehindPos;
        heur::rfl::BossRifleBeastParrySlowParam behindSetting;
        float behindHoldTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleTackle* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleTackle* pInstance);
        static void Clean(BossRifleBeastBattleTackle* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleState {
        float ClosedAreaRadius;
        float ClosedAreaHeght;
        float SmashDamageRatio;
        float InitPlayerHeight;
        float RotationStartAngle;
        float RotationStartAngleMiddle;
        float RotationStartAngleLarge;
        float RotationWaitTime;
        float RotationAngle;
        int32_t FirstMiniHP;
        float FirstDamageRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleState* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleState* pInstance);
        static void Clean(BossRifleBeastBattleState* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastParryParam {
        heur::rfl::BossRifleBeastParrySlowParam homingLaserParrySlow;
        heur::rfl::BossRifleBeastParrySlowParam homingLaserLastParrySlow;
        heur::rfl::BossRifleBeastParrySlowParam homingLaserOneShotParrySlow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastParryParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastParryParam* pInstance);
        static void Clean(BossRifleBeastParryParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastDebugCommand {
        enum class DebugCameraDrawTypeCyloop : uint8_t {
            Cyloop1Start = 0,
            Cyloop1Press = 1,
            Cyloop2BlowUp = 2,
            Cyloop2Press = 3,
            Cyloop2Landing = 4,
        };

        enum class DebugPlayerWarpPosTypeCyloop : uint8_t {
            Cyloop1PlayerStart = 0,
            Cyloop1PlayerPress = 1,
            Cyloop2PlayerBlowUp = 2,
            Cyloop2PlayerPress = 3,
            Cyloop2PlayerLanding = 4,
        };

        bool startFase4;
        bool skipMove;
        bool isDebugDrawCamera;
        DebugCameraDrawTypeCyloop debugDrawTypeCyloop;
        bool isDebugDrawPlayerWarpPosCyloop;
        DebugPlayerWarpPosTypeCyloop debugDrawTypePlayerWarpPosCyloop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastDebugCommand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastDebugCommand* pInstance);
        static void Clean(BossRifleBeastDebugCommand* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastBattleParam {
        heur::rfl::BossRifleBeastPhaseAttackActionParam actionParams[2];
        heur::rfl::BossRifleBeastBattleAttackPattern attackPattern[12];
        heur::rfl::BossRifleBeastBattleAttackPattern attackPatternAfter[12];
        heur::rfl::BossRifleBeastBattleDownState downState;
        heur::rfl::BossRifleBeastBattleAttackHomingLaserPattern attackHomingLaserPattern[10];
        heur::rfl::BossRifleBeastBattleFirstAttackHomingLaserPattern firstAttackHomingLaserPattern;
        heur::rfl::BossRifleBeastBattleSonic2FirstAttackHomingLaserPattern Sonic2firstAttackHomingLaserPattern;
        heur::rfl::BossRifleBeastBattleAttackHomingLaser attackHomingLaser;
        heur::rfl::BossRifleBeastBattleCyloopAttackHomingLaser cyloopAttackHomingLaser;
        heur::rfl::BossRifleBeastBattleCyloopAttackHomingLaser clawStunAttackHomingLaser;
        heur::rfl::BossRifleBeastBattleAttackClaw attackClaw;
        heur::rfl::BossRifleBeastBattleTackle attackTackle;
        heur::rfl::BossRifleBeastBattleCameraParam cameraParam;
        heur::rfl::BossRifleBeastBattleState battaleState;
        heur::rfl::BossRifleBeastBattleCyloopState cyloopState;
        heur::rfl::BossRifleBeastParryParam parryParam;
        heur::rfl::BossRifleBeastDebugCommand debugParam;
        float thresholdDamageEffectHPRatio[3];
        float qteSucceedWaitTimes[4];
        bool isDebugDraw;
        bool isSkip;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastBattleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastBattleParam* pInstance);
        static void Clean(BossRifleBeastBattleParam* pInstance);
    };
}

namespace heur::rfl {
    struct RifleBeastCableCamera {
        csl::math::Vector3 camLookAtOffset;
        csl::math::Vector3 camEyeOffset;
        float camFovy;
        float camEaseInTime;
        float camEaseOutTime;
        float camWaitTime;
        bool useCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RifleBeastCableCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RifleBeastCableCamera* pInstance);
        static void Clean(RifleBeastCableCamera* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastCableParam {
        uint32_t healthPoint;
        float colliderOffsetY;
        float attackRadius;
        float cyloopRadius;
        float targetableTime;
        float targetableDistance;
        heur::rfl::RifleBeastCableCamera camera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastCableParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastCableParam* pInstance);
        static void Clean(BossRifleBeastCableParam* pInstance);
    };
}

namespace heur::rfl {
    struct RifleBeastPracticeNotifierConfig {
        bool usePracticeNotifier;
        int8_t practiceNo;
        int16_t tipsNo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RifleBeastPracticeNotifierConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RifleBeastPracticeNotifierConfig* pInstance);
        static void Clean(RifleBeastPracticeNotifierConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastNotifierParam {
        heur::rfl::RifleBeastPracticeNotifierConfig notifierConfigBattle1;
        heur::rfl::RifleBeastPracticeNotifierConfig notifierConfigBattle2;
        heur::rfl::RifleBeastPracticeNotifierConfig notifierConfigBattle3;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastNotifierParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastNotifierParam* pInstance);
        static void Clean(BossRifleBeastNotifierParam* pInstance);
    };
}

namespace heur::rfl {
    struct BossRifleBeastConfig : heur::rfl::BossBaseConfig {
        heur::rfl::BossRifleBeastBattleParam battleParam;
        heur::rfl::BossRifleBeastCableParam cableParam;
        heur::rfl::BossRifleBeastNotifierParam notifierParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossRifleBeastConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossRifleBeastConfig* pInstance);
        static void Clean(BossRifleBeastConfig* pInstance);
    };
}

namespace heur::rfl {
    struct LaserTargetConfig {
        float scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(LaserTargetConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(LaserTargetConfig* pInstance);
        static void Clean(LaserTargetConfig* pInstance);
    };
}

namespace heur::rfl {
    struct SerifConfig {
        bool useHpBorder;
        float hpBorder;
        bool useWaveId;
        uint8_t waveId;
        float delayTime;
        csl::ut::VariableString voice;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SerifConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SerifConfig* pInstance);
        static void Clean(SerifConfig* pInstance);
    };
}

namespace heur::rfl {
    struct NotifierConfig {
        uint8_t waveId;
        heur::rfl::EnemyPracticeNotifierConfig practiceNotifierConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NotifierConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NotifierConfig* pInstance);
        static void Clean(NotifierConfig* pInstance);
    };
}

namespace heur::rfl {
    struct UIConfig {
        float borderLifeRatio;
        float sonicDamageRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(UIConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(UIConfig* pInstance);
        static void Clean(UIConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossTheEndConfig : heur::rfl::BossBaseConfig {
        heur::rfl::LaserTargetConfig target;
        heur::rfl::SerifConfig serifConfigs[26];
        heur::rfl::NotifierConfig notifierConfigStart;
        heur::rfl::NotifierConfig notifierConfigLaser;
        heur::rfl::UIConfig uiConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossTheEndConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossTheEndConfig* pInstance);
        static void Clean(BossTheEndConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BossResourceInfo {
        csl::ut::VariableString modelName;
        csl::ut::VariableString animName;
        csl::math::Vector3 scale;
        csl::ut::VariableString stageName;
        csl::math::Vector3 stagePos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossResourceInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossResourceInfo* pInstance);
        static void Clean(BossResourceInfo* pInstance);
    };
}

namespace heur::rfl {
    struct HoldPoint {
        csl::ut::VariableString nodeName;
        csl::math::Vector3 offset;
        csl::math::Vector3 rot;
        csl::ut::VariableString tagName;
        int32_t nextPointId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HoldPoint* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HoldPoint* pInstance);
        static void Clean(HoldPoint* pInstance);
    };
}

namespace heur::rfl {
    struct HoldPointParameter {
        heur::rfl::HoldPoint holdPoints[128];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HoldPointParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HoldPointParameter* pInstance);
        static void Clean(HoldPointParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CollisionPart {
        enum class Shape : int8_t {
            SHAPE_SPHERER = 0,
            SHAPE_BOX = 1,
            SHAPE_CYLINDER = 2,
            SHAPE_CAPCULE = 3,
        };

        csl::ut::VariableString nodeName;
        Shape shape;
        bool isPhysics;
        csl::math::Vector3 size;
        csl::math::Vector3 offset;
        csl::math::Vector3 rot;
        csl::ut::VariableString tagName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CollisionPart* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CollisionPart* pInstance);
        static void Clean(CollisionPart* pInstance);
    };
}

namespace heur::rfl {
    struct CollisionPartParameter {
        heur::rfl::CollisionPart colParts[32];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CollisionPartParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CollisionPartParameter* pInstance);
        static void Clean(CollisionPartParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BossCommonParameters {
        heur::rfl::BossResourceInfo resource;
        heur::rfl::HoldPointParameter holdParam;
        heur::rfl::CollisionPartParameter colParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossCommonParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossCommonParameters* pInstance);
        static void Clean(BossCommonParameters* pInstance);
    };
}

namespace heur::rfl {
    struct BossStatusParameterBase {
        int32_t maxHp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossStatusParameterBase* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossStatusParameterBase* pInstance);
        static void Clean(BossStatusParameterBase* pInstance);
    };
}

namespace heur::rfl {
    struct FSRow {
        uint8_t columns[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FSRow* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FSRow* pInstance);
        static void Clean(FSRow* pInstance);
    };
}

namespace heur::rfl {
    struct FSLayer {
        heur::rfl::FSRow rows[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FSLayer* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FSLayer* pInstance);
        static void Clean(FSLayer* pInstance);
    };
}

namespace heur::rfl {
    struct FreeShape {
        uint8_t numLayers;
        uint8_t numRows;
        uint8_t numColumns;
        csl::math::Vector3 offsetToTopLeft;
        heur::rfl::FSLayer layers[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FreeShape* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FreeShape* pInstance);
        static void Clean(FreeShape* pInstance);
    };
}

namespace heur::rfl {
    struct Obj3DPuzzleBlockConfig {
        heur::rfl::FreeShape freeShapes[29];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Obj3DPuzzleBlockConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Obj3DPuzzleBlockConfig* pInstance);
        static void Clean(Obj3DPuzzleBlockConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainScoreParameter {
        uint32_t score;
        uint32_t level1Meter;
        uint32_t level2Meter;
        uint32_t level3Meter;
        uint32_t level4Meter;
        uint32_t level5Meter;
        uint32_t level6Meter;
        uint32_t level7Meter;
        uint32_t level8Meter;
        uint32_t level9Meter;
        float delay;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainScoreParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainScoreParameter* pInstance);
        static void Clean(ActionChainScoreParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainAttackLevelParameter {
        uint32_t level1Param;
        uint32_t level99Param;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainAttackLevelParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainAttackLevelParameter* pInstance);
        static void Clean(ActionChainAttackLevelParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainAttackScoreParameter {
        heur::rfl::ActionChainAttackLevelParameter score;
        heur::rfl::ActionChainAttackLevelParameter level1Meter;
        heur::rfl::ActionChainAttackLevelParameter level2Meter;
        heur::rfl::ActionChainAttackLevelParameter level3Meter;
        heur::rfl::ActionChainAttackLevelParameter level4Meter;
        heur::rfl::ActionChainAttackLevelParameter level5Meter;
        heur::rfl::ActionChainAttackLevelParameter level6Meter;
        heur::rfl::ActionChainAttackLevelParameter level7Meter;
        heur::rfl::ActionChainAttackLevelParameter level8Meter;
        heur::rfl::ActionChainAttackLevelParameter level9Meter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainAttackScoreParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainAttackScoreParameter* pInstance);
        static void Clean(ActionChainAttackScoreParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainIntervalScoreParameter {
        float intervalTime;
        uint32_t score;
        uint32_t level1Meter;
        uint32_t level2Meter;
        uint32_t level3Meter;
        uint32_t level4Meter;
        uint32_t level5Meter;
        uint32_t level6Meter;
        uint32_t level7Meter;
        uint32_t level8Meter;
        uint32_t level9Meter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainIntervalScoreParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainIntervalScoreParameter* pInstance);
        static void Clean(ActionChainIntervalScoreParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainBoostScoreParameter {
        float intervalTime;
        float minSpeed;
        float maxSpeed;
        heur::rfl::ActionChainAttackLevelParameter score;
        heur::rfl::ActionChainAttackLevelParameter level1Meter;
        heur::rfl::ActionChainAttackLevelParameter level2Meter;
        heur::rfl::ActionChainAttackLevelParameter level3Meter;
        heur::rfl::ActionChainAttackLevelParameter level4Meter;
        heur::rfl::ActionChainAttackLevelParameter level5Meter;
        heur::rfl::ActionChainAttackLevelParameter level6Meter;
        heur::rfl::ActionChainAttackLevelParameter level7Meter;
        heur::rfl::ActionChainAttackLevelParameter level8Meter;
        heur::rfl::ActionChainAttackLevelParameter level9Meter;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainBoostScoreParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainBoostScoreParameter* pInstance);
        static void Clean(ActionChainBoostScoreParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainSpinBoostScoreParameter {
        float intervalTime;
        float minSpeed;
        float maxSpeed;
        heur::rfl::ActionChainAttackLevelParameter score;
        heur::rfl::ActionChainAttackLevelParameter level1Meter;
        heur::rfl::ActionChainAttackLevelParameter level2Meter;
        heur::rfl::ActionChainAttackLevelParameter level3Meter;
        heur::rfl::ActionChainAttackLevelParameter level4Meter;
        heur::rfl::ActionChainAttackLevelParameter level5Meter;
        heur::rfl::ActionChainAttackLevelParameter level6Meter;
        heur::rfl::ActionChainAttackLevelParameter level7Meter;
        heur::rfl::ActionChainAttackLevelParameter level8Meter;
        heur::rfl::ActionChainAttackLevelParameter level9Meter;
        float minHeight;
        float maxHeight;
        float maxHeightMagnification;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainSpinBoostScoreParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainSpinBoostScoreParameter* pInstance);
        static void Clean(ActionChainSpinBoostScoreParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainActionParameter {
        heur::rfl::ActionChainScoreParameter dashRollerScore;
        heur::rfl::ActionChainScoreParameter dashPanelScore;
        heur::rfl::ActionChainScoreParameter jumpBoardScore;
        heur::rfl::ActionChainScoreParameter jumpSelecterScore;
        heur::rfl::ActionChainScoreParameter poleScore;
        heur::rfl::ActionChainScoreParameter selectCannonScore;
        heur::rfl::ActionChainScoreParameter springScore;
        heur::rfl::ActionChainScoreParameter wideSpringScore;
        heur::rfl::ActionChainScoreParameter springClassicScore;
        heur::rfl::ActionChainScoreParameter balloonScore;
        heur::rfl::ActionChainScoreParameter upReelScore;
        heur::rfl::ActionChainScoreParameter wallJumpScore;
        heur::rfl::ActionChainScoreParameter propellerSpringScore;
        heur::rfl::ActionChainScoreParameter springPoleScore;
        heur::rfl::ActionChainScoreParameter dashRingScore;
        heur::rfl::ActionChainAttackScoreParameter acceleCombo1Score;
        heur::rfl::ActionChainAttackScoreParameter acceleCombo2Score;
        heur::rfl::ActionChainAttackScoreParameter comboFinishScore;
        heur::rfl::ActionChainAttackScoreParameter acceleRushCombo1Score;
        heur::rfl::ActionChainAttackScoreParameter acceleRushCombo2Score;
        heur::rfl::ActionChainAttackScoreParameter acceleRushComboFinishScore;
        heur::rfl::ActionChainAttackScoreParameter chargeAttackScore;
        heur::rfl::ActionChainAttackScoreParameter smashScore;
        heur::rfl::ActionChainAttackScoreParameter recoverySmashScore;
        heur::rfl::ActionChainAttackScoreParameter sonicBoomScore;
        heur::rfl::ActionChainAttackScoreParameter crasherScore;
        heur::rfl::ActionChainAttackScoreParameter loopKickScore;
        heur::rfl::ActionChainAttackScoreParameter spinSlashScore;
        heur::rfl::ActionChainAttackScoreParameter stompingAttackScore;
        heur::rfl::ActionChainAttackScoreParameter homingShotScore;
        heur::rfl::ActionChainAttackScoreParameter crossSlashScore;
        heur::rfl::ActionChainScoreParameter ringScore;
        heur::rfl::ActionChainScoreParameter gismoScore;
        heur::rfl::ActionChainScoreParameter homingScore;
        heur::rfl::ActionChainAttackScoreParameter enemyHomingScore;
        heur::rfl::ActionChainScoreParameter airTrickScore;
        heur::rfl::ActionChainScoreParameter chainBoosterScore;
        heur::rfl::ActionChainScoreParameter parryScore;
        heur::rfl::ActionChainAttackScoreParameter quickCyloopScore;
        heur::rfl::ActionChainScoreParameter defeatEnemyScore;
        heur::rfl::ActionChainScoreParameter defeatMiniBossScore;
        heur::rfl::ActionChainAttackScoreParameter slingShotScore;
        heur::rfl::ActionChainScoreParameter rippleLaserScore;
        heur::rfl::ActionChainIntervalScoreParameter grindRailScore;
        heur::rfl::ActionChainIntervalScoreParameter pulleyScore;
        heur::rfl::ActionChainIntervalScoreParameter fanScore;
        heur::rfl::ActionChainIntervalScoreParameter wallRunScore;
        heur::rfl::ActionChainBoostScoreParameter boostScore;
        heur::rfl::ActionChainIntervalScoreParameter powerBoostScore;
        heur::rfl::ActionChainIntervalScoreParameter sandSkiScore;
        heur::rfl::ActionChainIntervalScoreParameter acceleRailScore;
        heur::rfl::ActionChainSpinBoostScoreParameter spinBoostScore;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainActionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainActionParameter* pInstance);
        static void Clean(ActionChainActionParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainMeterParameter {
        uint32_t meterMax;
        float meterDecreaseTime;
        uint32_t meterDecrease;
        float decreaseWaitTime;
        float decreasePercent;
        float decreaseWaitTimeAddMeter;
        float meterResetDelayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainMeterParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainMeterParameter* pInstance);
        static void Clean(ActionChainMeterParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainParameter {
        heur::rfl::ActionChainActionParameter actionParam;
        heur::rfl::ActionChainMeterParameter level1MeterParam;
        heur::rfl::ActionChainMeterParameter level2MeterParam;
        heur::rfl::ActionChainMeterParameter level3MeterParam;
        heur::rfl::ActionChainMeterParameter level4MeterParam;
        heur::rfl::ActionChainMeterParameter level5MeterParam;
        heur::rfl::ActionChainMeterParameter level6MeterParam;
        heur::rfl::ActionChainMeterParameter level7MeterParam;
        heur::rfl::ActionChainMeterParameter level8MeterParam;
        heur::rfl::ActionChainMeterParameter level9MeterParam;
        float gimmickReuseTime;
        bool isChainBoosterLevelUp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainParameter* pInstance);
        static void Clean(ActionChainParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainScoreThresholdParameter {
        uint32_t scoreS;
        uint32_t scoreA;
        uint32_t scoreB;
        uint32_t scoreC;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainScoreThresholdParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainScoreThresholdParameter* pInstance);
        static void Clean(ActionChainScoreThresholdParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainPlaceParameter {
        float time;
        heur::rfl::ActionChainScoreThresholdParameter scoreEasy;
        heur::rfl::ActionChainScoreThresholdParameter scoreNormal;
        heur::rfl::ActionChainScoreThresholdParameter scoreHard;
        heur::rfl::ActionChainScoreThresholdParameter scoreVeryHard;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainPlaceParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainPlaceParameter* pInstance);
        static void Clean(ActionChainPlaceParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ActionChainStageParameter {
        heur::rfl::ActionChainPlaceParameter placeParam[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainStageParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainStageParameter* pInstance);
        static void Clean(ActionChainStageParameter* pInstance);
    };
}

namespace heur::rfl {
    struct GimmickCameraParam {
        float interoplateTimeActivate;
        float interoplateTimeDeactivate;
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraPosOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GimmickCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GimmickCameraParam* pInstance);
        static void Clean(GimmickCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBattingMachineConfig {
        heur::rfl::GimmickCameraParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBattingMachineConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBattingMachineConfig* pInstance);
        static void Clean(ObjBattingMachineConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBombBoxConfig {
        float fallStartSpeed;
        float gravity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBombBoxConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBombBoxConfig* pInstance);
        static void Clean(ObjBombBoxConfig* pInstance);
    };
}

namespace heur::rfl {
    struct LargeBitLaserParameter {
        float rangeMin;
        float rangeMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(LargeBitLaserParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(LargeBitLaserParameter* pInstance);
        static void Clean(LargeBitLaserParameter* pInstance);
    };
}

namespace heur::rfl {
    struct SmallBitLaserBulletParameter {
        float bulletRadius;
        float bulletMoveLimitDistance;
        float bitHp;
        float rotDamageAngleSpeed;
        float rotDamageSize;
        float hitDamageNotAttackTime;
        float blowoffSpeed;
        float outOfControlTime;
        float keepVelocity;
        float muzzleEffectMinTime;
        uint8_t dropRingNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SmallBitLaserBulletParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SmallBitLaserBulletParameter* pInstance);
        static void Clean(SmallBitLaserBulletParameter* pInstance);
    };
}

namespace heur::rfl {
    struct SmallBitAttackPatternParameter {
        enum class BulletType : uint8_t {
            Normal = 0,
            Normal2 = 1,
            Laser = 2,
            Homing = 3,
        };

        enum class RotType : uint8_t {
            Rotation = 0,
            RoundTrip = 1,
            Aim = 2,
            Fix = 3,
        };

        enum class CameraId : uint8_t {
            Invalid = 0,
            Rotate = 1,
            Trace = 2,
            Sub = 3,
            Num = 4,
        };

        enum class FormationId : uint8_t {
            Default = 0,
            FanShaped = 1,
        };

        bool isParry;
        float time;
        float angleSpeed;
        BulletType bulletType;
        RotType rotType;
        float rotAngle;
        float phaseRotTime;
        uint32_t shootNum;
        float shootSpeed;
        float addShootSpeed;
        float shootAccel;
        float shootAccelMax;
        float shootAccelDelay;
        uint8_t wayNum;
        float wayAngle;
        float shootTime;
        float phaseShootTime;
        uint32_t periodShootCool;
        float periodShootCoolTime;
        float homingAccuracy;
        float homingDelay;
        float homingLimitAngle;
        bool isHomingLowFly;
        CameraId overlookingId;
        float waveRotationSpeed;
        float flyMoveSpeed;
        FormationId formationId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SmallBitAttackPatternParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SmallBitAttackPatternParameter* pInstance);
        static void Clean(SmallBitAttackPatternParameter* pInstance);
    };
}

namespace heur::rfl {
    struct SmallBitSetPatternParameter {
        csl::ut::VariableString text;
        heur::rfl::SmallBitAttackPatternParameter param;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SmallBitSetPatternParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SmallBitSetPatternParameter* pInstance);
        static void Clean(SmallBitSetPatternParameter* pInstance);
    };
}

namespace heur::rfl {
    struct SmallBitFormationFanShaped {
        float distance;
        float height;
        float radius;
        float angleMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SmallBitFormationFanShaped* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SmallBitFormationFanShaped* pInstance);
        static void Clean(SmallBitFormationFanShaped* pInstance);
    };
}

namespace heur::rfl {
    struct SmallBitFormationParameter {
        float changeTime;
        float changeDelay;
        float changeOffsetHeight;
        heur::rfl::SmallBitFormationFanShaped fanShaped;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SmallBitFormationParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SmallBitFormationParameter* pInstance);
        static void Clean(SmallBitFormationParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BossBitConfig {
        heur::rfl::LargeBitLaserParameter largeBitLaserParam;
        heur::rfl::SmallBitLaserBulletParameter smallBitLaserParam;
        heur::rfl::SmallBitSetPatternParameter smallBitPatternDatas[64];
        heur::rfl::SmallBitFormationParameter smallBitFormation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BossBitConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BossBitConfig* pInstance);
        static void Clean(BossBitConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBossRingSupplyConfig {
        heur::rfl::RingParameter ringParam;
        float requestTime;
        float accessDistance;
        uint32_t numRings[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBossRingSupplyConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBossRingSupplyConfig* pInstance);
        static void Clean(ObjBossRingSupplyConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ExplosionParameter {
        csl::math::Vector3 centerPosOffsetMin;
        csl::math::Vector3 centerPosOffsetMax;
        float range;
        float powerMin;
        float powerMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExplosionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExplosionParameter* pInstance);
        static void Clean(ExplosionParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ImpulseParameter {
        csl::math::Vector3 impulseDir;
        float powerMin;
        float powerMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ImpulseParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ImpulseParameter* pInstance);
        static void Clean(ImpulseParameter* pInstance);
    };
}

namespace heur::rfl {
    struct DebrisPhaseParameter {
        float marginTime;
        float nextTime;
        float gravity;
        float moveStopTime;
        bool damping;
        heur::rfl::ExplosionParameter explosionParam;
        heur::rfl::ImpulseParameter impulseParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DebrisPhaseParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DebrisPhaseParameter* pInstance);
        static void Clean(DebrisPhaseParameter* pInstance);
    };
}

namespace heur::rfl {
    struct EffectDebrisParameter {
        heur::rfl::DebrisPhaseParameter debrisPhaseParameters[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EffectDebrisParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EffectDebrisParameter* pInstance);
        static void Clean(EffectDebrisParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjEffectDebrisParameters {
        heur::rfl::EffectDebrisParameter effectDebrisParameters[10];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjEffectDebrisParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjEffectDebrisParameters* pInstance);
        static void Clean(ObjEffectDebrisParameters* pInstance);
    };
}

namespace heur::rfl {
    struct ElectricLineConnectData {
        int32_t challengeNo0;
        int32_t challengeNo1;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ElectricLineConnectData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ElectricLineConnectData* pInstance);
        static void Clean(ElectricLineConnectData* pInstance);
    };
}

namespace heur::rfl {
    struct ElectricLineConnectParameter {
        int32_t challengeNo0;
        int32_t challengeNo1;
        heur::rfl::ElectricLineConnectData data[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ElectricLineConnectParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ElectricLineConnectParameter* pInstance);
        static void Clean(ElectricLineConnectParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ElectricLineParameter {
        heur::rfl::ElectricLineConnectParameter connect[200];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ElectricLineParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ElectricLineParameter* pInstance);
        static void Clean(ElectricLineParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjFishCAConfig {
        float fallStartSpeed;
        float gravity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjFishCAConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjFishCAConfig* pInstance);
        static void Clean(ObjFishCAConfig* pInstance);
    };
}

namespace heur::rfl {
    struct DebrisData {
        float gravity;
        float lifeTime;
        float mass;
        float friction;
        float explosionScale;
        float impulseScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DebrisData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DebrisData* pInstance);
        static void Clean(DebrisData* pInstance);
    };
}

namespace heur::rfl {
    struct EffectData {
        csl::ut::VariableString effectName;
        bool linkMotionStop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EffectData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EffectData* pInstance);
        static void Clean(EffectData* pInstance);
    };
}

namespace heur::rfl {
    struct GismoBasicParam {
        csl::ut::VariableString modelName;
        csl::ut::VariableString skeltonName;
        bool noInstance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GismoBasicParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GismoBasicParam* pInstance);
        static void Clean(GismoBasicParam* pInstance);
    };
}

namespace heur::rfl {
    struct GismoCollision {
        enum class ShapeType : int8_t {
            SHAPE_BOX = 0,
            SHAPE_SPHERE = 1,
            SHAPE_CAPSULE = 2,
            SHAPE_CYLINDER = 3,
            SHAPE_MESH = 4,
            SHAPE_NONE = 5,
        };

        enum class BasePoint : int8_t {
            BASE_CENTER = 0,
            BASE_Z_PLANE = 1,
            BASE_X_PLANE = 2,
            BASE_Y_PLANE = 3,
        };

        ShapeType shape;
        BasePoint basePoint;
        float width;
        float height;
        float depth;
        csl::ut::VariableString meshName;
        csl::math::Vector3 shapeOffset;
        float shapeSizeOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GismoCollision* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GismoCollision* pInstance);
        static void Clean(GismoCollision* pInstance);
    };
}

namespace heur::rfl {
    struct PhysicsParam {
        float mass;
        float friction;
        float gravityFactor;
        float restitution;
        float linearDamping;
        float angularDamping;
        float maxLinearVelocity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PhysicsParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PhysicsParam* pInstance);
        static void Clean(PhysicsParam* pInstance);
    };
}

namespace heur::rfl {
    struct GismoRegidBody {
        enum class RigidBodyType : int8_t {
            RIGID_BODY_NONE = 0,
            RIGID_BODY_STATIC = 1,
            RIGID_BODY_DYNAMIC = 2,
        };

        enum class RigidBodyMaterial : int8_t {
            RIGID_BODY_MAT_NONE = 0,
            RIGID_BODY_MAT_WOOD = 1,
            RIGID_BODY_MAT_IRON = 2,
            NUM_RIGID_BODY_MATS = 3,
        };

        RigidBodyType rigidBodyType;
        RigidBodyMaterial rigidBodyMaterial;
        heur::rfl::PhysicsParam physicsParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GismoRegidBody* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GismoRegidBody* pInstance);
        static void Clean(GismoRegidBody* pInstance);
    };
}

namespace heur::rfl {
    struct MotionData {
        csl::ut::VariableString motionName;
        bool syncFrame;
        bool stopEndFrame;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MotionData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MotionData* pInstance);
        static void Clean(MotionData* pInstance);
    };
}

namespace heur::rfl {
    struct MirageAnimData {
        csl::ut::VariableString texSrtAnimName[3];
        csl::ut::VariableString texPatAnimName[3];
        csl::ut::VariableString matAnimName[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MirageAnimData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MirageAnimData* pInstance);
        static void Clean(MirageAnimData* pInstance);
    };
}

namespace heur::rfl {
    struct ProgramMotionData {
        enum class MotionType : uint8_t {
            MOTION_SWING = 0,
            MOTION_ROTATE = 1,
            MOTION_LINEAR_SWING = 2,
        };

        MotionType motionType;
        csl::math::Vector3 axis;
        float power;
        float speedScale;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ProgramMotionData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ProgramMotionData* pInstance);
        static void Clean(ProgramMotionData* pInstance);
    };
}

namespace heur::rfl {
    struct SoundData {
        csl::ut::VariableString cueName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SoundData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SoundData* pInstance);
        static void Clean(SoundData* pInstance);
    };
}

namespace heur::rfl {
    struct KillData {
        enum class KillType : int8_t {
            KILL_TYPE_NOT_KILL = 0,
            KILL_TYPE_KILL = 1,
            KILL_TYPE_BREAK = 2,
            KILL_TYPE_MOTION = 3,
        };

        KillType killType;
        float killTime;
        csl::ut::VariableString breakMotionName;
        heur::rfl::DebrisData debrisData;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KillData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KillData* pInstance);
        static void Clean(KillData* pInstance);
    };
}

namespace heur::rfl {
    struct ReactionData {
        heur::rfl::MotionData motionData;
        heur::rfl::MirageAnimData mirageAnimData;
        heur::rfl::ProgramMotionData programMotionData;
        heur::rfl::EffectData effectData;
        heur::rfl::SoundData soundData;
        heur::rfl::KillData killData;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ReactionData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ReactionData* pInstance);
        static void Clean(ReactionData* pInstance);
    };
}

namespace heur::rfl {
    struct GismoConfigDesignData {
        float rangeIn;
        float rangeDistance;
        heur::rfl::GismoBasicParam basicParam;
        heur::rfl::GismoCollision collision;
        heur::rfl::GismoRegidBody rigidBody;
        heur::rfl::ReactionData reactionIdle;
        heur::rfl::ReactionData reactionEnter;
        heur::rfl::ReactionData reactionLeave;
        heur::rfl::ReactionData reactionStay;
        heur::rfl::ReactionData reactionStayMove;
        heur::rfl::ReactionData reactionDamage;
        bool ignoreMeteorShowerAndRespawnOnReenterRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GismoConfigDesignData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GismoConfigDesignData* pInstance);
        static void Clean(GismoConfigDesignData* pInstance);
    };
}

namespace heur::rfl {
    struct GismoConfigPlanData {
        enum class ContactDamageType : int8_t {
            CONTACT_DAMAGE_NONE = 0,
            CONTACT_DAMAGE_LOW_SPEED = 1,
            CONTACT_DAMAGE_MIDDLE_SPEED = 2,
            CONTACT_DAMAGE_HIGH_SPEED = 3,
        };

        ContactDamageType contactDamageType;
        bool noneDamageSpin;
        bool rideOnDamage;
        bool aerialBounce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GismoConfigPlanData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GismoConfigPlanData* pInstance);
        static void Clean(GismoConfigPlanData* pInstance);
    };
}

namespace heur::rfl {
    struct HackingConfig {
        uint32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HackingConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HackingConfig* pInstance);
        static void Clean(HackingConfig* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerMachineConfig {
        int32_t baseHp;
        int32_t lifeCount;
        int32_t lifeUpFailedCount[6];
        int32_t lifeMax;
        float gageUpVolume;
        float gageMax;
        int32_t laserNum;
        float laserInterval;
        float bulletInterval;
        float moveSpeed;
        float nodamageTime;
        float specialmoveTime;
        float bodyCol;
        float barrierCol;
        float attackRangeTime;
        float expandAttackCol;
        csl::math::Vector3 hitPos;
        csl::math::Vector3 barrierPos;
        csl::math::Vector3 expandAttackPos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerMachineConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerMachineConfig* pInstance);
        static void Clean(PlayerMachineConfig* pInstance);
    };
}

namespace heur::rfl {
    struct HomingLaserTrailConfig {
        float length;
        float minLength;
        float texWidth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HomingLaserTrailConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HomingLaserTrailConfig* pInstance);
        static void Clean(HomingLaserTrailConfig* pInstance);
    };
}

namespace heur::rfl {
    struct HomingLaserConfig {
        float radius;
        float speed;
        float maxAccel;
        float arrivalTime;
        float lifeTime;
        float minYaw;
        float maxYaw;
        float depthVelocity;
        uint32_t power;
        heur::rfl::HomingLaserTrailConfig trail;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HomingLaserConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HomingLaserConfig* pInstance);
        static void Clean(HomingLaserConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ElementBulletConfig {
        float radius;
        float speed;
        float scale;
        uint32_t power;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ElementBulletConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ElementBulletConfig* pInstance);
        static void Clean(ElementBulletConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHackingPlayerMachineConfig {
        heur::rfl::PlayerMachineConfig machine;
        heur::rfl::HomingLaserConfig laser;
        heur::rfl::ElementBulletConfig bullet;
        heur::rfl::HackingConfig hacking;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHackingPlayerMachineConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHackingPlayerMachineConfig* pInstance);
        static void Clean(ObjHackingPlayerMachineConfig* pInstance);
    };
}

namespace heur::rfl {
    struct TheEndConfig {
        float distance;
        float gageUpVolumeFromMiss;
        float hitViewScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TheEndConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TheEndConfig* pInstance);
        static void Clean(TheEndConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTheEndPlayerMachineConfig {
        heur::rfl::PlayerMachineConfig machine;
        heur::rfl::HomingLaserConfig laser;
        heur::rfl::ElementBulletConfig bullet;
        heur::rfl::TheEndConfig TheEnd;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTheEndPlayerMachineConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTheEndPlayerMachineConfig* pInstance);
        static void Clean(ObjTheEndPlayerMachineConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjHoverStoneConfig {
        float hoverUpSpeed;
        float fallSpeed;
        float homingAttackBounce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjHoverStoneConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjHoverStoneConfig* pInstance);
        static void Clean(ObjHoverStoneConfig* pInstance);
    };
}

namespace heur::rfl {
    struct CeilingInfo {
        enum class Symbol : int8_t {
            Invalid = -1,
            Seven = 0,
            Bar = 1,
            Fruit = 2,
            Bell = 3,
            NumSymbols = 4,
        };

        Symbol symbols[3];
        uint32_t rollCount;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CeilingInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CeilingInfo* pInstance);
        static void Clean(CeilingInfo* pInstance);
    };
}

namespace heur::rfl {
    struct ReelParam {
        enum class Symbol : int8_t {
            Invalid = -1,
            Seven = 0,
            Bar = 1,
            Fruit = 2,
            Bell = 3,
            NumSymbols = 4,
        };

        Symbol symbols[16];
        float spinSpeedMin;
        float spinSpeedMax;
        float autoStopTimeMin;
        float autoStopTimeMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ReelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ReelParam* pInstance);
        static void Clean(ReelParam* pInstance);
    };
}

namespace heur::rfl {
    struct RateInfo {
        enum class Symbol : int8_t {
            Invalid = -1,
            Seven = 0,
            Bar = 1,
            Fruit = 2,
            Bell = 3,
            NumSymbols = 4,
        };

        Symbol symbols[3];
        float rate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RateInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RateInfo* pInstance);
        static void Clean(RateInfo* pInstance);
    };
}

namespace heur::rfl {
    struct PayoutInfo {
        enum class Symbol : int8_t {
            Invalid = -1,
            Seven = 0,
            Bar = 1,
            Fruit = 2,
            Bell = 3,
            NumSymbols = 4,
        };

        Symbol symbols[3];
        uint32_t payout;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PayoutInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PayoutInfo* pInstance);
        static void Clean(PayoutInfo* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBonusSlotConfig {
        heur::rfl::ReelParam reelParams[3];
        float spinInterval;
        heur::rfl::RateInfo rateInfos[4];
        heur::rfl::CeilingInfo ceilingInfos[4];
        heur::rfl::PayoutInfo payoutInfos[4];
        uint32_t payoutOnBlank;
        bool WinEvenWithPush;
        float retrySpeed;
        float backSpeed;
        float stepSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBonusSlotConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBonusSlotConfig* pInstance);
        static void Clean(ObjBonusSlotConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MeteorShowerEffectParameter {
        float spawnIntervalMax;
        float spawnIntervalMin;
        float spawnHeightMax;
        float spawnHeightMin;
        float spawnHorizonMax;
        float spawnHorizonMin;
        float speedMax;
        float speedMin;
        float lengthMax;
        float lengthMin;
        float width;
        float angleMax;
        float angleMin;
        float moveTimeMax;
        float moveTimeMin;
        float fadeTimeMax;
        float fadeTimeMin;
        float spawnAngle;
        csl::math::Vector3 color;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MeteorShowerEffectParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MeteorShowerEffectParameter* pInstance);
        static void Clean(MeteorShowerEffectParameter* pInstance);
    };
}

namespace heur::rfl {
    struct MeteorShowerParameter {
        float rangeFromSonicObjectsDontRespawn;
        uint32_t intervalDay;
        uint32_t startHour;
        uint32_t startMinute;
        uint32_t durationHour;
        uint32_t durationMinute;
        uint32_t extraIslandSeedRate;
        uint32_t extraIslandKodamaRate;
        uint32_t extraIntervalDay;
        heur::rfl::MeteorShowerEffectParameter effect;
        heur::rfl::ObjBonusSlotConfig bonusSlotConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MeteorShowerParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MeteorShowerParameter* pInstance);
        static void Clean(MeteorShowerParameter* pInstance);
    };
}

namespace heur::rfl {
    struct SeedParameter {
        enum class SeedType : uint8_t {
            SeedSensor = 0,
            ObjItem = 1,
        };

        float suckedTime;
        SeedType seedType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SeedParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SeedParameter* pInstance);
        static void Clean(SeedParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ReflexesPanelCameraParam {
        float interoplateTimeActivate;
        float interoplateTimeDeactivate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ReflexesPanelCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ReflexesPanelCameraParam* pInstance);
        static void Clean(ReflexesPanelCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ReflexesPanelPanelParam {
        csl::math::Vector3 collisionHalfExtents;
        csl::math::Vector3 collisionOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ReflexesPanelPanelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ReflexesPanelPanelParam* pInstance);
        static void Clean(ReflexesPanelPanelParam* pInstance);
    };
}

namespace heur::rfl {
    struct ReflexesPanelParam {
        heur::rfl::ReflexesPanelCameraParam cameraParam;
        heur::rfl::ReflexesPanelPanelParam panelParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ReflexesPanelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ReflexesPanelParam* pInstance);
        static void Clean(ReflexesPanelParam* pInstance);
    };
}

namespace heur::rfl {
    struct TornadoRingParameter {
        float suckedTime;
        float launchAngle;
        float launchMaxSpeed;
        float launchMinSpeed;
        float randomRangeMin;
        float randomRangeMax;
        float lifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TornadoRingParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TornadoRingParameter* pInstance);
        static void Clean(TornadoRingParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjLaserMirrorConfig {
        heur::rfl::GimmickCameraParam rotateMirrorH;
        heur::rfl::GimmickCameraParam rotateMirrorV;
        heur::rfl::GimmickCameraParam moveMirror;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjLaserMirrorConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjLaserMirrorConfig* pInstance);
        static void Clean(ObjLaserMirrorConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRotatableStatueConfig {
        heur::rfl::GimmickCameraParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRotatableStatueConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRotatableStatueConfig* pInstance);
        static void Clean(ObjRotatableStatueConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjRotatableTombStoneConfig {
        heur::rfl::GimmickCameraParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjRotatableTombStoneConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjRotatableTombStoneConfig* pInstance);
        static void Clean(ObjRotatableTombStoneConfig* pInstance);
    };
}

namespace heur::rfl {
    struct SequenceParameter {
        enum class SequenceType : uint8_t {
            SequenceSensor = 0,
            ObjItem = 1,
        };

        float suckedTime;
        SequenceType sequenceType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SequenceParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SequenceParameter* pInstance);
        static void Clean(SequenceParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShotGunTouchCameraParam {
        csl::math::Vector3 cameraOffset;
        float cameraHoldTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShotGunTouchCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShotGunTouchCameraParam* pInstance);
        static void Clean(ObjShotGunTouchCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShotGunTouchTargetParam {
        float targetRadius;
        float catchDistance;
        float linearDamping;
        float angularDamping;
        float appearDelay;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShotGunTouchTargetParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShotGunTouchTargetParam* pInstance);
        static void Clean(ObjShotGunTouchTargetParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjShotGunTouchParam {
        heur::rfl::ObjShotGunTouchTargetParam targetParam;
        heur::rfl::ObjShotGunTouchCameraParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjShotGunTouchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjShotGunTouchParam* pInstance);
        static void Clean(ObjShotGunTouchParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjThornBallConfig {
        float fallStartSpeed;
        float gravity;
        float releaseAngle;
        float releaseSpeed;
        float releasegravity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjThornBallConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjThornBallConfig* pInstance);
        static void Clean(ObjThornBallConfig* pInstance);
    };
}

namespace heur::rfl {
    struct CollisionConfig {
        float radius;
        float friction;
        float restitution;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CollisionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CollisionConfig* pInstance);
        static void Clean(CollisionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct CorrectionsConfig {
        float CorrectionsMaxDistance;
        float CorrectionsMinDistance;
        float CorrectionsAngle;
        float CorrectionsRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CorrectionsConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CorrectionsConfig* pInstance);
        static void Clean(CorrectionsConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjTimeBallConfig {
        float mass;
        float linearDamping;
        float angularDamping;
        float maxLinearVelocity;
        float maxLinearAcceleration;
        float linearVelocityTimes;
        float gravity;
        heur::rfl::CollisionConfig collisionConfig;
        heur::rfl::CorrectionsConfig correctionsConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjTimeBallConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjTimeBallConfig* pInstance);
        static void Clean(ObjTimeBallConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWaveCannonConfig {
        uint32_t waveCannonBreakNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWaveCannonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWaveCannonConfig* pInstance);
        static void Clean(ObjWaveCannonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWeightConfig {
        float fallStartSpeed;
        float gravity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWeightConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWeightConfig* pInstance);
        static void Clean(ObjWeightConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWoodBoxConfig {
        float fallStartSpeed;
        float gravity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWoodBoxConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWoodBoxConfig* pInstance);
        static void Clean(ObjWoodBoxConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjAnimalConfig {
        float powerGettingOn;
        float timeGettingOn;
        float powerGettingOff;
        float timeGettingOff;
        int32_t numberOfRotations;
        int32_t numberOfRevolutions;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjAnimalConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjAnimalConfig* pInstance);
        static void Clean(ObjAnimalConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ExtremeConfig {
        enum class LineType : int8_t {
            LINE3 = 0,
            LINE5 = 1,
            LINE_INF = 2,
        };

        LineType lineType;
        float lineWidth;
        float roadLength;
        float speed;
        float barricadeInterval;
        float emergencyDistance;
        csl::math::Vector3 barricadeSize;
        csl::ut::Color8 roadColor;
        csl::ut::Color8 barricadeColor;
        float cameraFovy;
        float cameraDistance;
        float cameraUpOffset;
        float cameraShakeOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtremeConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtremeConfig* pInstance);
        static void Clean(ExtremeConfig* pInstance);
    };
}

namespace heur::rfl {
    struct NormalFloorSize {
        float length;
        float width;
        float height;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NormalFloorSize* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NormalFloorSize* pInstance);
        static void Clean(NormalFloorSize* pInstance);
    };
}

namespace heur::rfl {
    struct ObjNormalFloorConfig {
        heur::rfl::NormalFloorSize sizeInfo[10];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjNormalFloorConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjNormalFloorConfig* pInstance);
        static void Clean(ObjNormalFloorConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAquaballActionConfig {
        int32_t maxSuccessCount;
        csl::math::Vector2 bounceSuccessTiming[3];
        float captureLimitTime;
        float captureLimitHeight;
        float failLimitTime;
        float failNoticeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAquaballActionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAquaballActionConfig* pInstance);
        static void Clean(EnemyAquaballActionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAquaballCommonLevelParam {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAquaballCommonLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAquaballCommonLevelParam* pInstance);
        static void Clean(EnemyAquaballCommonLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAquaballPatrolConfig {
        float rotateSpeedMin;
        float rotateSpeedMax;
        float speedMin;
        float speedMax;
        float moveSpeed;
        float bounceHeight;
        float bounceInterval;
        float movePointUpdateInterval;
        float addForceOfHA;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAquaballPatrolConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAquaballPatrolConfig* pInstance);
        static void Clean(EnemyAquaballPatrolConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAquaballCommonParam {
        float killWaitTime;
        float colliderRadius;
        float colliderHeight;
        float damageColliderRadiusOffset;
        float hitPlayerColliderRadiusOffset;
        float checkBarrierDistance;
        float battleDistance;
        heur::rfl::RingParameter ringParam;
        heur::rfl::EnemyAquaballPatrolConfig patrolConfig;
        heur::rfl::EnemyAquaballActionConfig actionConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAquaballCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAquaballCommonParam* pInstance);
        static void Clean(EnemyAquaballCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAquaballLevelParam {
        int32_t level;
        heur::rfl::EnemyAquaballCommonLevelParam common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAquaballLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAquaballLevelParam* pInstance);
        static void Clean(EnemyAquaballLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAquaballLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAquaballLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAquaballLevelBand* pInstance);
        static void Clean(EnemyAquaballLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyAquaballConfig {
        heur::rfl::EnemyAquaballCommonParam commonParam;
        heur::rfl::EnemyAquaballLevelParam levelParams[5];
        heur::rfl::EnemyAquaballLevelBand levelBand[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyAquaballConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyAquaballConfig* pInstance);
        static void Clean(EnemyAquaballConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BirdApproachParam {
        float speed;
        float maxSpeed;
        float acceleration;
        float rotateDegreeToSonic;
        float stopDistanceFromSonic;
        csl::math::Vector3 offsetFromSonic;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdApproachParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdApproachParam* pInstance);
        static void Clean(BirdApproachParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdBackupParam {
        float speed;
        float maxSpeed;
        float acceleration;
        float backupTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdBackupParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdBackupParam* pInstance);
        static void Clean(BirdBackupParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdBarParam {
        float haWaitTime;
        float degreeOnPath;
        float speedOnPath;
        float speedToPath;
        float splineTension;
        float splineSpeed;
        csl::math::Vector3 velocityOnFail;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdBarParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdBarParam* pInstance);
        static void Clean(BirdBarParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdCameraParam {
        float azimuth;
        float elevation;
        float distance;
        float zRoll;
        float fovy;
        csl::math::Vector3 frameOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdCameraParam* pInstance);
        static void Clean(BirdCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdChargeParam {
        float waitTime;
        float speed;
        float maxSpeed;
        float acceleration;
        csl::math::Vector3 offsetFromSonic;
        float duration;
        float distance;
        float minElevation;
        float maxElevation;
        float panningSuspensionK;
        float interiorPanningSuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdChargeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdChargeParam* pInstance);
        static void Clean(BirdChargeParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdDeadParam {
        float minWaitTime;
        float maxWaitTime;
        float raycastDistance;
        float fallSpeedOnStomp;
        float maxFallSpeedOnStomp;
        float fallAccelerationOnStomp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdDeadParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdDeadParam* pInstance);
        static void Clean(BirdDeadParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdGlidingParam {
        float moveSpeed;
        float gidingVelocityY;
        float limitTime;
        float rotateSpeed;
        float rotateSpeedMin;
        float rotateSpeedMax;
        float rotateSpeedMaxSpeedMin;
        float rotateSpeedMinSpeedMax;
        float heightOfChangeShake;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdGlidingParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdGlidingParam* pInstance);
        static void Clean(BirdGlidingParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdLaserStateParam {
        float laserInterval;
        float rotateDegreeToSonic;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdLaserStateParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdLaserStateParam* pInstance);
        static void Clean(BirdLaserStateParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdOnBackCameraParam {
        float distToConsiderSonicAsOnBird;
        float distance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdOnBackCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdOnBackCameraParam* pInstance);
        static void Clean(BirdOnBackCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdRaycastParam {
        float distanceFront;
        float distanceBack;
        float distanceDown;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdRaycastParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdRaycastParam* pInstance);
        static void Clean(BirdRaycastParam* pInstance);
    };
}

namespace heur::rfl {
    struct BirdWanderParam {
        float speedOnPath;
        float speedToPath;
        float eyesightDelayAfterBarAction;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BirdWanderParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BirdWanderParam* pInstance);
        static void Clean(BirdWanderParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBirdCommonLevelParam {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBirdCommonLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBirdCommonLevelParam* pInstance);
        static void Clean(EnemyBirdCommonLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBirdCommonParam {
        csl::math::Vector3 backColliderExtents;
        csl::math::Vector3 backColliderOffset;
        csl::math::Vector3 backDamageColliderExtents;
        csl::math::Vector3 backDamageColliderOffset;
        csl::math::Vector3 chargeColliderExtents;
        csl::math::Vector3 chargeColliderOffset;
        float eyesightAngle;
        float eyesightDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBirdCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBirdCommonParam* pInstance);
        static void Clean(EnemyBirdCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBirdLevelParam {
        int32_t level;
        heur::rfl::EnemyBirdCommonLevelParam common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBirdLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBirdLevelParam* pInstance);
        static void Clean(EnemyBirdLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBirdLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBirdLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBirdLevelBand* pInstance);
        static void Clean(EnemyBirdLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBirdParam {
        csl::math::Vector3 haColliderExtents;
        csl::math::Vector3 haColliderOffset;
        csl::math::Vector3 haTargetOffset;
        float haTargetRadius;
        float haTargetHeight;
        heur::rfl::BirdWanderParam wanderParam;
        heur::rfl::BirdApproachParam approachParam;
        heur::rfl::BirdLaserStateParam laserStateParam;
        heur::rfl::BirdChargeParam chargeParam;
        heur::rfl::BirdBackupParam backupParam;
        heur::rfl::BirdBarParam barParam;
        heur::rfl::BirdGlidingParam glidingParam;
        heur::rfl::BirdDeadParam deadParam;
        heur::rfl::BirdRaycastParam raycastParam;
        bool useCamera;
        heur::rfl::BirdOnBackCameraParam onBackCameraParam;
        heur::rfl::BirdCameraParam cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBirdParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBirdParam* pInstance);
        static void Clean(EnemyBirdParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBirdConfig {
        heur::rfl::EnemyBirdCommonParam commonParam;
        heur::rfl::EnemyBirdLevelParam levelParams[5];
        heur::rfl::EnemyBirdLevelBand levelBand[5];
        heur::rfl::EnemyBirdParam birdParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBirdConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBirdConfig* pInstance);
        static void Clean(EnemyBirdConfig* pInstance);
    };
}

namespace heur::rfl {
    struct SpeedInfo {
        float speed;
        float maxSpeed;
        float acceleration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SpeedInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SpeedInfo* pInstance);
        static void Clean(SpeedInfo* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBirdLaserConfig {
        heur::rfl::SpeedInfo speedInfoToSonic;
        heur::rfl::SpeedInfo speedInfoToBird;
        float colliderLength;
        float colliderRadius;
        float lifeTime;
        csl::math::Vector3 laserScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBirdLaserConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBirdLaserConfig* pInstance);
        static void Clean(ObjBirdLaserConfig* pInstance);
    };
}

namespace heur::rfl {
    struct BommerCommonLevelConfig {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BommerCommonLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BommerCommonLevelConfig* pInstance);
        static void Clean(BommerCommonLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBommerAimingConfig {
        float moveDecerleration;
        float rotationAngleMax;
        float chargeTime;
        float rotateSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBommerAimingConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBommerAimingConfig* pInstance);
        static void Clean(EnemyBommerAimingConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBommerAttackConfig {
        float moveVelocity;
        float moveDecerleration;
        float moveDecelerationDamaged;
        float cooldownTime;
        float colliderOffsetRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBommerAttackConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBommerAttackConfig* pInstance);
        static void Clean(EnemyBommerAttackConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBommerChaseConfig {
        float moveVelocity;
        float moveAccerleration;
        float amplitude;
        float period;
        float rotateSpeedInFront;
        float rotateSpeedOnBack;
        float chaseTime;
        float parriedMoveDistance;
        float parriedShortenTime;
        float parriedCoolDownTime;
        float colliderOffsetRate;
        float cameraDistance;
        float cameraElevation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBommerChaseConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBommerChaseConfig* pInstance);
        static void Clean(EnemyBommerChaseConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBommerPatrolConfig {
        float rotationDeceleration;
        float rotationAngleMax;
        float changeTimeIdlePatrolMin;
        float changeTimeIdlePatrolMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBommerPatrolConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBommerPatrolConfig* pInstance);
        static void Clean(EnemyBommerPatrolConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBommerCommonConfig {
        heur::rfl::RingParameter ringParam;
        float mass;
        float slopeAngleMax;
        float checkBarrierDistance;
        float colliderRadius;
        float colliderHeight;
        float damageColliderRadiusOffset;
        float eyesightDistance;
        float eyesightDistanceMargin;
        heur::rfl::EnemyBommerPatrolConfig patrolConfig;
        heur::rfl::EnemyBommerAimingConfig aimingConfig;
        heur::rfl::EnemyBommerAttackConfig attackConfig;
        heur::rfl::EnemyBommerChaseConfig chaseConfig;
        float explodeSignalTime;
        float explodeColliderRadius;
        bool useUniqueDebrisSetting;
        heur::rfl::DebrisParameter debrisExplode;
        heur::rfl::DebrisParameter debrisCyloop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBommerCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBommerCommonConfig* pInstance);
        static void Clean(EnemyBommerCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBommerLevelConfig {
        int32_t level;
        heur::rfl::BommerCommonLevelConfig common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBommerLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBommerLevelConfig* pInstance);
        static void Clean(EnemyBommerLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBommerConfig {
        heur::rfl::EnemyBommerCommonConfig commonParams;
        heur::rfl::EnemyBommerLevelConfig levelParams[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBommerConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBommerConfig* pInstance);
        static void Clean(EnemyBommerConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleApproachConfig {
        float moveMinDistance;
        float moveSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleApproachConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleApproachConfig* pInstance);
        static void Clean(EnemyBubbleApproachConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleBlitzProtectionConfig {
        float moveMinDistance;
        float moveSpeedMax;
        float blitzProtectionAttackTime;
        float blitzProtectionIntervalTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleBlitzProtectionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleBlitzProtectionConfig* pInstance);
        static void Clean(EnemyBubbleBlitzProtectionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleBlitzProtectionReadyConfig {
        float moveMinDistance;
        float moveSpeedMax;
        float blitzProtectionMaxDistance;
        float blitzProtectionReadyTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleBlitzProtectionReadyConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleBlitzProtectionReadyConfig* pInstance);
        static void Clean(EnemyBubbleBlitzProtectionReadyConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleCommonLevelParam {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleCommonLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleCommonLevelParam* pInstance);
        static void Clean(EnemyBubbleCommonLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleShellConfig {
        float baseHeight;
        float innerDistance;
        float outerDistance;
        float innerRadius;
        float outerRadius;
        float innerAccelMax;
        float outerAccelMax;
        float innerSpeedMax;
        float outerSpeedMax;
        uint8_t innerNum;
        uint8_t outerNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleShellConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleShellConfig* pInstance);
        static void Clean(EnemyBubbleShellConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleCommonParam {
        float killWaitTime;
        float colliderRadius;
        float damageColliderRadiusOffset;
        float attackColliderRadiusOffset;
        float eyesightDistance;
        float moveAccerleration;
        float moveDeceleration;
        float rotationAngleMax;
        float mass;
        float slopeAngleMax;
        float knockBackTime;
        heur::rfl::EnemyBubbleApproachConfig approachConfig;
        heur::rfl::EnemyBubbleBlitzProtectionReadyConfig blitzReadyConfig;
        heur::rfl::EnemyBubbleBlitzProtectionConfig blitzConfig;
        heur::rfl::EnemyBubbleShellConfig shellConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleCommonParam* pInstance);
        static void Clean(EnemyBubbleCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleLevelParam {
        int32_t level;
        heur::rfl::EnemyBubbleCommonLevelParam common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleLevelParam* pInstance);
        static void Clean(EnemyBubbleLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleLevelBand* pInstance);
        static void Clean(EnemyBubbleLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyBubbleConfig {
        heur::rfl::EnemyBubbleCommonParam commonParam;
        heur::rfl::EnemyBubbleLevelParam levelParams[5];
        heur::rfl::EnemyBubbleLevelBand levelBand[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyBubbleConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyBubbleConfig* pInstance);
        static void Clean(EnemyBubbleConfig* pInstance);
    };
}

namespace heur::rfl {
    struct DefenderCommonLevelConfig {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DefenderCommonLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DefenderCommonLevelConfig* pInstance);
        static void Clean(DefenderCommonLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyDefenderPatrolConfig {
        float changeTimeIdlePatrolMin;
        float changeTimeIdlePatrolMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyDefenderPatrolConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyDefenderPatrolConfig* pInstance);
        static void Clean(EnemyDefenderPatrolConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyDefenderCommonConfig {
        heur::rfl::RingParameter ringParam;
        float mass;
        float slopeAngleMax;
        float checkBarrierDistance;
        float colliderRadius;
        float colliderHeight;
        float damageColliderRadiusOffset;
        float boomerangColliderRadius;
        float boomerangColliderHeight;
        float boomerangColliderOffset;
        float boomerangCameraKeepTimeMin;
        float eyesightDistance;
        float eyesightLostDelayTime;
        heur::rfl::EnemyDefenderPatrolConfig patrolConfig;
        float shieldBlowUpTime;
        float shieldBlowUpHeight;
        float shieldBoomerangSpeed;
        float shieldBoomerangMinDistance;
        float shieldBoomerangMaxDistance;
        float killWaitTime;
        float cameraDistance;
        float cameraElevation;
        int32_t parryBoomerangRound;
        float parryBoomerangOffset;
        float parryBoomerangSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyDefenderCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyDefenderCommonConfig* pInstance);
        static void Clean(EnemyDefenderCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyDefenderLevelConfig {
        int32_t level;
        heur::rfl::DefenderCommonLevelConfig common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyDefenderLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyDefenderLevelConfig* pInstance);
        static void Clean(EnemyDefenderLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyDefenderConfig {
        heur::rfl::EnemyDefenderCommonConfig commonParams;
        heur::rfl::EnemyDefenderLevelConfig levelParams[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyDefenderConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyDefenderConfig* pInstance);
        static void Clean(EnemyDefenderConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyEggRoboConfig {
        float scaleSv;
        float scaleFv;
        float appearEffTimer;
        float colliderRadius;
        float colliderHeight;
        csl::math::Vector3 colliderOffset;
        float laserColliderRadius;
        float laserColliderHeight;
        csl::math::Vector3 laserColliderSizeSV;
        float missileColliderRadius;
        float missileColliderHeight;
        csl::math::Vector3 missileColliderOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyEggRoboConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyEggRoboConfig* pInstance);
        static void Clean(EnemyEggRoboConfig* pInstance);
    };
}

namespace heur::rfl {
    struct HeliDamageCol {
        float radius;
        csl::math::Vector3 pos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliDamageCol* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliDamageCol* pInstance);
        static void Clean(HeliDamageCol* pInstance);
    };
}

namespace heur::rfl {
    struct HeliCommon {
        float followRotateSpeed;
        heur::rfl::HeliDamageCol damageCol;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliCommon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliCommon* pInstance);
        static void Clean(HeliCommon* pInstance);
    };
}

namespace heur::rfl {
    struct HeliAttackBase {
        float life;
        float attackInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliAttackBase* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliAttackBase* pInstance);
        static void Clean(HeliAttackBase* pInstance);
    };
}

namespace heur::rfl {
    struct HeliBullet : heur::rfl::HeliAttackBase {
        float bulletSpeed;
        float gunRotateSpeed;
        uint8_t attackChainNum;
        float attackChainInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliBullet* pInstance);
        static void Clean(HeliBullet* pInstance);
    };
}

namespace heur::rfl {
    struct HeliBomb : heur::rfl::HeliAttackBase {
        float bombSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeliBomb* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeliBomb* pInstance);
        static void Clean(HeliBomb* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyHelicopterConfig {
        heur::rfl::HeliCommon common;
        heur::rfl::HeliBullet attackBullet;
        heur::rfl::HeliBomb attackBomb;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyHelicopterConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyHelicopterConfig* pInstance);
        static void Clean(EnemyHelicopterConfig* pInstance);
    };
}

namespace heur::rfl {
    struct Movement {
        float rotateSpeedMin;
        float rotateSpeedMax;
        float rotateSpeedMaxSpeedMin;
        float rotateSpeedMinSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Movement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Movement* pInstance);
        static void Clean(Movement* pInstance);
    };
}

namespace heur::rfl {
    struct Eyesight {
        float distance;
        float angle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Eyesight* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Eyesight* pInstance);
        static void Clean(Eyesight* pInstance);
    };
}

namespace heur::rfl {
    struct Fight {
        float attackRange;
        float attackAngle;
        float attackSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Fight* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Fight* pInstance);
        static void Clean(Fight* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJellymanModeConfig {
        heur::rfl::Movement movement;
        heur::rfl::Eyesight eyesight;
        heur::rfl::Fight fight;
        float transformRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJellymanModeConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJellymanModeConfig* pInstance);
        static void Clean(EnemyJellymanModeConfig* pInstance);
    };
}

namespace heur::rfl {
    struct JellymanHumanCommonConfig {
        heur::rfl::EnemyJellymanModeConfig common;
        float actionDistance[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(JellymanHumanCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(JellymanHumanCommonConfig* pInstance);
        static void Clean(JellymanHumanCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct VolumeInfo {
        csl::math::Vector3 volumeSize;
        csl::math::Vector3 volumeOffset;
        csl::math::Vector3 volumeRotation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(VolumeInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(VolumeInfo* pInstance);
        static void Clean(VolumeInfo* pInstance);
    };
}

namespace heur::rfl {
    struct MappingPairInfo {
        enum class VolumeShape : int8_t {
            SPHERE = 0,
            BOX = 1,
            CYLINDER = 2,
            CAPSULE = 3,
            NUM = 4,
        };

        csl::ut::VariableString tagName;
        int8_t pieceNum;
        float pieceFuncFactor;
        VolumeShape volumeShape;
        csl::ut::VariableString humanNodeName;
        heur::rfl::VolumeInfo humanVolume;
        csl::ut::VariableString eggNodeName;
        heur::rfl::VolumeInfo eggVolume;
        bool effectActive;
        bool debugDraw;
        bool debugDrawVolumeAxis;
        bool debugDrawAxis;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MappingPairInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MappingPairInfo* pInstance);
        static void Clean(MappingPairInfo* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyCommonConfig {
        heur::rfl::JellymanHumanCommonConfig human;
        heur::rfl::RingParameter ringParam;
        int32_t codeDropNumMin;
        int32_t codeDropNumMax;
        int32_t codeXDropNumMin;
        int32_t codeXDropNumMax;
        heur::rfl::MappingPairInfo mappingPairInfo[32];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyCommonConfig* pInstance);
        static void Clean(EnemyCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct JellymanCommonLevelConfig {
        int32_t maxHealthPoint;
        float maxStunPoint[3];
        float stunDecreaseStartTime;
        float stunDecreaseSpeed;
        float maxStaggerPoint[3];
        float staggerDecreaseStartTime;
        float staggerDecreaseSpeed;
        float stunTime;
        float attackRate;
        float attackMotionSpeed;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(JellymanCommonLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(JellymanCommonLevelConfig* pInstance);
        static void Clean(JellymanCommonLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct JellymanHumanLevelConfig {
        float wallTime;
        int32_t wallLife;
        float guardTime;
        float guardCoolTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(JellymanHumanLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(JellymanHumanLevelConfig* pInstance);
        static void Clean(JellymanHumanLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyLevelConfig {
        int32_t level;
        heur::rfl::JellymanCommonLevelConfig common;
        heur::rfl::JellymanHumanLevelConfig human;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyLevelConfig* pInstance);
        static void Clean(EnemyLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct JellymanCommonActionConfig {
        enum class SuperArmorType : int8_t {
            None = 0,
            Attack = 1,
            Always = 2,
        };

        SuperArmorType superArmor;
        bool isTransform;
        float downTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(JellymanCommonActionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(JellymanCommonActionConfig* pInstance);
        static void Clean(JellymanCommonActionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct JellymanHumanActionRate {
        float actionRate[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(JellymanHumanActionRate* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(JellymanHumanActionRate* pInstance);
        static void Clean(JellymanHumanActionRate* pInstance);
    };
}

namespace heur::rfl {
    struct JellymanHumanActionConfig {
        heur::rfl::JellymanHumanActionRate rateTable[4];
        float coolTime[5];
        float attackCoolTime;
        float nearRange;
        int32_t nearRateId;
        int32_t farRateId;
        bool isCounterGuard;
        bool isCounterWall;
        bool isSpikeWall;
        int32_t waveNum;
        float waveUpTime;
        float waveLifeTime;
        float waveDownTime;
        float waveRadius;
        float waveAddRadius;
        float waveSpawnTime;
        float waveKeepRadius;
        float waveHeight;
        int32_t rushNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(JellymanHumanActionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(JellymanHumanActionConfig* pInstance);
        static void Clean(JellymanHumanActionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyLevelBandConfig {
        int32_t level;
        heur::rfl::JellymanCommonActionConfig common;
        heur::rfl::JellymanHumanActionConfig human;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyLevelBandConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyLevelBandConfig* pInstance);
        static void Clean(EnemyLevelBandConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemySquadAvarageLevelConfig {
        int32_t level;
        int32_t maxActionCount;
        float spAttackWaitTime;
        int32_t humanMaxActionCount[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemySquadAvarageLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemySquadAvarageLevelConfig* pInstance);
        static void Clean(EnemySquadAvarageLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemySquadConfig {
        heur::rfl::EnemySquadAvarageLevelConfig averageLevelConfig[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemySquadConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemySquadConfig* pInstance);
        static void Clean(EnemySquadConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJellymanConfig {
        heur::rfl::EnemyCommonConfig commonParams;
        heur::rfl::EnemyLevelConfig levelParams[8];
        heur::rfl::EnemyLevelBandConfig levelBands[5];
        heur::rfl::EnemySquadConfig squadParams;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJellymanConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJellymanConfig* pInstance);
        static void Clean(EnemyJellymanConfig* pInstance);
    };
}

namespace heur::rfl {
    struct VolumeSize {
        float width;
        float height;
        float depth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(VolumeSize* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(VolumeSize* pInstance);
        static void Clean(VolumeSize* pInstance);
    };
}

namespace heur::rfl {
    struct SpringPlayer {
        float velocity;
        float targetCursorMaxDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SpringPlayer* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SpringPlayer* pInstance);
        static void Clean(SpringPlayer* pInstance);
    };
}

namespace heur::rfl {
    struct BattleParam {
        float stompingRange;
        float stompingTotalNum;
        float interpalTimeFinal;
        float range;
        float riseDistance;
        float riseTime;
        float upLoopTime;
        float chaseSpeed;
        float speed;
        float groundImpactRadius;
        heur::rfl::SpringPlayer springPlayer;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BattleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BattleParam* pInstance);
        static void Clean(BattleParam* pInstance);
    };
}

namespace heur::rfl {
    struct CharacterControllerCollision {
        float height;
        float radius;
        csl::math::Vector3 offset;
        csl::math::Vector3 scale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CharacterControllerCollision* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CharacterControllerCollision* pInstance);
        static void Clean(CharacterControllerCollision* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperAutoLockonParam {
        float distance;
        float lockOnMinDistance;
        csl::math::Vector3 playerOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperAutoLockonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperAutoLockonParam* pInstance);
        static void Clean(EnemyJumperAutoLockonParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperCommonLevelParam {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperCommonLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperCommonLevelParam* pInstance);
        static void Clean(EnemyJumperCommonLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperPatrolConfig {
        float rotateSpeedMin;
        float rotateSpeedMax;
        float speedMin;
        float speedMax;
        float changeTimeIdlePatrolMin;
        float changeTimeIdlePatrolMax;
        float lockonDistance;
        float unlockDistance;
        float distance;
        float minElevation;
        float maxElevation;
        float panningSuspensionK;
        float interiorPanningSuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperPatrolConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperPatrolConfig* pInstance);
        static void Clean(EnemyJumperPatrolConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperCommonParam {
        float killWaitTime;
        float colliderRadius;
        float colliderHeight;
        float headRadius;
        float headHeight;
        float damageColliderRadiusOffset;
        float eyesightDistance;
        float maxSpeed;
        float checkBarrierDistance;
        heur::rfl::EnemyJumperPatrolConfig patrolConfig;
        heur::rfl::EnemyJumperAutoLockonParam lockonCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperCommonParam* pInstance);
        static void Clean(EnemyJumperCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperLevelParam {
        int32_t level;
        heur::rfl::EnemyJumperCommonLevelParam common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperLevelParam* pInstance);
        static void Clean(EnemyJumperLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperLevelBand* pInstance);
        static void Clean(EnemyJumperLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MovementParam {
        float rotateSpeedMin;
        float rotateSpeedMax;
        float speedMin;
        float speedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MovementParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MovementParam* pInstance);
        static void Clean(MovementParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperConfig {
        heur::rfl::EnemyJumperCommonParam commonParam;
        heur::rfl::EnemyJumperLevelParam levelParams[5];
        heur::rfl::EnemyJumperLevelBand levelBand[5];
        heur::rfl::CharacterControllerCollision characterControllerCollision;
        heur::rfl::MovementParam movement;
        heur::rfl::BattleParam battleParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperConfig* pInstance);
        static void Clean(EnemyJumperConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperSubCommonLevelParam {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperSubCommonLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperSubCommonLevelParam* pInstance);
        static void Clean(EnemyJumperSubCommonLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperSubCommonParam {
        float killWaitTime;
        float colliderRadius;
        float colliderHeight;
        float damageColliderRadiusOffset;
        float eyesightDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperSubCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperSubCommonParam* pInstance);
        static void Clean(EnemyJumperSubCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperSubLevelParam {
        int32_t level;
        heur::rfl::EnemyJumperSubCommonLevelParam common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperSubLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperSubLevelParam* pInstance);
        static void Clean(EnemyJumperSubLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperSubLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperSubLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperSubLevelBand* pInstance);
        static void Clean(EnemyJumperSubLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyJumperSubConfig {
        heur::rfl::EnemyJumperSubCommonParam commonParam;
        heur::rfl::EnemyJumperSubLevelParam levelParams[5];
        heur::rfl::EnemyJumperSubLevelBand levelBand[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyJumperSubConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyJumperSubConfig* pInstance);
        static void Clean(EnemyJumperSubConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyRobberCommonConfig {
        heur::rfl::RingParameter ringParam;
        float eyesightDistance;
        float idlingSpeed;
        float chasingSpeed;
        float escapeSpeed;
        float escapeSpeedPlayerOnPath;
        float onBoardSpeed;
        float restTime;
        float railMaxLength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyRobberCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyRobberCommonConfig* pInstance);
        static void Clean(EnemyRobberCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct RobbberCommonLevelConfig {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RobbberCommonLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RobbberCommonLevelConfig* pInstance);
        static void Clean(RobbberCommonLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyRobberLevelConfig {
        int32_t level;
        heur::rfl::RobbberCommonLevelConfig common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyRobberLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyRobberLevelConfig* pInstance);
        static void Clean(EnemyRobberLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyRobberConfig {
        heur::rfl::EnemyRobberCommonConfig commonParams;
        heur::rfl::EnemyRobberLevelConfig levelParams[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyRobberConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyRobberConfig* pInstance);
        static void Clean(EnemyRobberConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemySniperCommonConfig {
        heur::rfl::RingParameter ringParam;
        int32_t codeDropNumMin;
        int32_t codeDropNumMax;
        int32_t codeXDropNumMin;
        int32_t codeXDropNumMax;
        float eyesightDistancePatrol;
        float eyesightDistanceBattle;
        float hideCoreDistance;
        float showCoreDistance;
        float guardShotWaitTime;
        float guardShotAngle;
        float aimBendSpeed;
        float muzzleShrinkStartDist;
        float muzzleShrinkEndDist;
        float snipeMaxAngle;
        float guardMaxAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemySniperCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemySniperCommonConfig* pInstance);
        static void Clean(EnemySniperCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct SniperCommonLevelConfig {
        int32_t maxHealthPoint;
        int32_t maxGuardPoint;
        float stunTime;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;
        float snipeRotateSpeed;
        float chargeRotateSpeed;
        float predictRotateSpeed;
        float snipeWaitTime;
        float snipeShotSpeed;
        float snipeIntervalTime;
        float predictTime;
        float predictAngleRange;
        float guardShotSpeed;
        float guardShotRotateSpeed;
        float guardShotMotionSpeed;
        float guardShotLifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SniperCommonLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SniperCommonLevelConfig* pInstance);
        static void Clean(SniperCommonLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemySniperLevelConfig {
        int32_t level;
        heur::rfl::SniperCommonLevelConfig common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemySniperLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemySniperLevelConfig* pInstance);
        static void Clean(EnemySniperLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct SniperCommonActionConfig {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SniperCommonActionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SniperCommonActionConfig* pInstance);
        static void Clean(SniperCommonActionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemySniperLevelBandConfig {
        int32_t level;
        heur::rfl::SniperCommonActionConfig common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemySniperLevelBandConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemySniperLevelBandConfig* pInstance);
        static void Clean(EnemySniperLevelBandConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemySniperConfig {
        heur::rfl::EnemySniperCommonConfig commonParams;
        heur::rfl::EnemySniperLevelConfig levelParams[5];
        heur::rfl::EnemySniperLevelBandConfig levelBands[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemySniperConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemySniperConfig* pInstance);
        static void Clean(EnemySniperConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyTwisterCommonConfig {
        heur::rfl::RingParameter ringParam;
        float rigidColliderRadius;
        float damageColliderRadius;
        float battleDistance;
        float cyloopHeight;
        float rotateSpeed;
        bool useUniqueDebrisSetting;
        heur::rfl::DebrisParameter debris;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyTwisterCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyTwisterCommonConfig* pInstance);
        static void Clean(EnemyTwisterCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct TwisterCommonLevelConfig {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TwisterCommonLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TwisterCommonLevelConfig* pInstance);
        static void Clean(TwisterCommonLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyTwisterLevelConfig {
        int32_t level;
        heur::rfl::TwisterCommonLevelConfig common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyTwisterLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyTwisterLevelConfig* pInstance);
        static void Clean(EnemyTwisterLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyTwisterConfig {
        heur::rfl::EnemyTwisterCommonConfig commonParams;
        heur::rfl::EnemyTwisterLevelConfig levelParams[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyTwisterConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyTwisterConfig* pInstance);
        static void Clean(EnemyTwisterConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyUmbrellaCommonConfig {
        heur::rfl::RingParameter ringParam;
        int32_t codeDropNumMin;
        int32_t codeDropNumMax;
        int32_t codeXDropNumMin;
        int32_t codeXDropNumMax;
        float closeDistance;
        float cameraDistance;
        float cameraElevation;
        float pullStartHeight;
        float pullEndHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyUmbrellaCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyUmbrellaCommonConfig* pInstance);
        static void Clean(EnemyUmbrellaCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct UmbrellaCommonLevelConfig {
        enum class BarrageType : uint8_t {
            BOX = 0,
            CONE = 1,
            FAN = 2,
        };

        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;
        float backJumpHeight;
        float backJumpDistance;
        float flyingDuration;
        BarrageType barrageType;
        float barrageHeight;
        float barrageWidth;
        float barrageDistance;
        float bombRatio;
        float barrageFallSpeed;
        float barrageLifeTime;
        float barrageLifePassPower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(UmbrellaCommonLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(UmbrellaCommonLevelConfig* pInstance);
        static void Clean(UmbrellaCommonLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyUmbrellaLevelConfig {
        int32_t level;
        heur::rfl::UmbrellaCommonLevelConfig common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyUmbrellaLevelConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyUmbrellaLevelConfig* pInstance);
        static void Clean(EnemyUmbrellaLevelConfig* pInstance);
    };
}

namespace heur::rfl {
    struct UmbrellaCommonActionConfig {
        int32_t dummy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(UmbrellaCommonActionConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(UmbrellaCommonActionConfig* pInstance);
        static void Clean(UmbrellaCommonActionConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyUmbrellaLevelBandConfig {
        int32_t level;
        heur::rfl::UmbrellaCommonActionConfig common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyUmbrellaLevelBandConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyUmbrellaLevelBandConfig* pInstance);
        static void Clean(EnemyUmbrellaLevelBandConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyUmbrellaConfig {
        heur::rfl::EnemyUmbrellaCommonConfig commonParams;
        heur::rfl::EnemyUmbrellaLevelConfig levelParams[5];
        heur::rfl::EnemyUmbrellaLevelBandConfig levelBands[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyUmbrellaConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyUmbrellaConfig* pInstance);
        static void Clean(EnemyUmbrellaConfig* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyWolfCommonLevelParam {
        int32_t maxHealthPoint;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyWolfCommonLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyWolfCommonLevelParam* pInstance);
        static void Clean(EnemyWolfCommonLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct WolfMovementParam {
        float rotateSpeedMin;
        float rotateSpeedMax;
        float rotateSpeedMaxSpeedMin;
        float rotateSpeedMinSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WolfMovementParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WolfMovementParam* pInstance);
        static void Clean(WolfMovementParam* pInstance);
    };
}

namespace heur::rfl {
    struct WolfEyesightParam {
        float distance;
        float angle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WolfEyesightParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WolfEyesightParam* pInstance);
        static void Clean(WolfEyesightParam* pInstance);
    };
}

namespace heur::rfl {
    struct WolfVolumeInfo {
        csl::math::Vector3 volumeSize;
        csl::math::Vector3 volumeOffset;
        csl::math::Vector3 volumeRotation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WolfVolumeInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WolfVolumeInfo* pInstance);
        static void Clean(WolfVolumeInfo* pInstance);
    };
}

namespace heur::rfl {
    struct WolfMappingPairInfo {
        enum class WolfVolumeShape : int8_t {
            SPHERE = 0,
            BOX = 1,
            CYLINDER = 2,
            CAPSULE = 3,
            NUM = 4,
        };

        csl::ut::VariableString tagName;
        int8_t pieceNum;
        float pieceFuncFactor;
        WolfVolumeShape volumeShape;
        csl::ut::VariableString wolfNodeName;
        heur::rfl::WolfVolumeInfo wolfVolume;
        bool effectActive;
        bool debugDraw;
        bool debugDrawVolumeAxis;
        bool debugDrawAxis;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WolfMappingPairInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WolfMappingPairInfo* pInstance);
        static void Clean(WolfMappingPairInfo* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyWolfCommonParam {
        heur::rfl::RingParameter ringParam;
        heur::rfl::WolfMovementParam movement;
        heur::rfl::WolfEyesightParam eyesight;
        float killWaitTime;
        float blockColliderRadius;
        float blockColliderHeight;
        float damageColliderRadius;
        float damageColliderHeight;
        float eyesightDistance;
        csl::math::Vector3 cursorOffset;
        heur::rfl::WolfMappingPairInfo mappingPairInfo[32];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyWolfCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyWolfCommonParam* pInstance);
        static void Clean(EnemyWolfCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyWolfLevelParam {
        int32_t level;
        heur::rfl::EnemyWolfCommonLevelParam common;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyWolfLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyWolfLevelParam* pInstance);
        static void Clean(EnemyWolfLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyWolfLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyWolfLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyWolfLevelBand* pInstance);
        static void Clean(EnemyWolfLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyWolfConfig {
        heur::rfl::EnemyWolfCommonParam commonParam;
        heur::rfl::EnemyWolfLevelParam levelParams[5];
        heur::rfl::EnemyWolfLevelBand levelBand[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyWolfConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyWolfConfig* pInstance);
        static void Clean(EnemyWolfConfig* pInstance);
    };
}

namespace heur::rfl {
    struct FocusCameraConfig {
        float duration;
        float distance;
        float minElevation;
        float maxElevation;
        float panningSuspensionK;
        float interiorPanningSuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FocusCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FocusCameraConfig* pInstance);
        static void Clean(FocusCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWolfManagerConfig {
        heur::rfl::FocusCameraConfig focusCamera;
        float shotInterval;
        float shotInterval_Parried;
        float shotInterval_Reborn;
        float shotInterval_First;
        float shotInterval_NoReborn;
        float stunTime;
        float approachWait;
        float dispWait;
        float rollWait;
        float reactionTime;
        float controlDelay;
        float shotAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWolfManagerConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWolfManagerConfig* pInstance);
        static void Clean(ObjWolfManagerConfig* pInstance);
    };
}

namespace heur::rfl {
    struct WolfVolumeSize {
        float width;
        float height;
        float depth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WolfVolumeSize* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WolfVolumeSize* pInstance);
        static void Clean(WolfVolumeSize* pInstance);
    };
}

namespace heur::rfl {
    struct EventData {
        enum class EventType : int8_t {
            KEY = 0,
            INTERVAL = 1,
        };

        csl::ut::VariableString name;
        EventType type;
        float inTime;
        float outTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EventData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EventData* pInstance);
        static void Clean(EventData* pInstance);
    };
}

namespace heur::rfl {
    struct NodeInfoInAnim {
        csl::math::Vector3 position;
        csl::math::Quaternion rotation;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NodeInfoInAnim* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NodeInfoInAnim* pInstance);
        static void Clean(NodeInfoInAnim* pInstance);
    };
}

namespace heur::rfl {
    struct NodeData {
        csl::ut::VariableString name;
        csl::ut::MoveArray<heur::rfl::NodeInfoInAnim> nodeInfos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NodeData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NodeData* pInstance);
        static void Clean(NodeData* pInstance);
    };
}

namespace heur::rfl {
    struct DeltaMotionInfoInAnim {
        csl::math::Vector3 position;
        csl::math::Quaternion rotation;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DeltaMotionInfoInAnim* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DeltaMotionInfoInAnim* pInstance);
        static void Clean(DeltaMotionInfoInAnim* pInstance);
    };
}

namespace heur::rfl {
    struct DeltaMotionData {
        csl::ut::MoveArray<heur::rfl::DeltaMotionInfoInAnim> deltaInfos;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(DeltaMotionData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(DeltaMotionData* pInstance);
        static void Clean(DeltaMotionData* pInstance);
    };
}

namespace heur::rfl {
    struct AnimData {
        csl::ut::VariableString name;
        csl::ut::MoveArray<heur::rfl::EventData> eventDatas;
        csl::ut::MoveArray<heur::rfl::NodeData> nodeDatas;
        heur::rfl::DeltaMotionData deltaMotionData;
        float maxTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AnimData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AnimData* pInstance);
        static void Clean(AnimData* pInstance);
    };
}

namespace heur::rfl {
    struct RecordData {
        csl::ut::MoveArray<heur::rfl::AnimData> animDatas;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RecordData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RecordData* pInstance);
        static void Clean(RecordData* pInstance);
    };
}

namespace heur::rfl {
    struct ObjGFieldCylinderSplineSpawner : heur::rfl::GravityFieldCylinderSplineSetupParameter {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjGFieldCylinderSplineSpawner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjGFieldCylinderSplineSpawner* pInstance);
        static void Clean(ObjGFieldCylinderSplineSpawner* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossCommonConfig {
        float scoutDistance;
        float scoutDistanceOutside;
        float zoomDistance;
        csl::math::Vector3 zoomOffset;
        csl::math::Vector3 zoomAngle;
        float zoomFov;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossCommonConfig* pInstance);
        static void Clean(MiniBossCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraCommonParam* pInstance);
        static void Clean(MiniBossAshuraCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossLevelCommonConfig {
        int32_t maxHealthPoint;
        float maxStunPoint[3];
        float stunDecreaseStartTime;
        float stunDecreaseSpeed;
        float maxStaggerPoint[3];
        float staggerDecreaseStartTime;
        float staggerDecreaseSpeed;
        float attackRate;
        uint16_t expItemNum;
        uint16_t exp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossLevelCommonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossLevelCommonConfig* pInstance);
        static void Clean(MiniBossLevelCommonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraLevelParam* pInstance);
        static void Clean(MiniBossAshuraLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraLevelBand* pInstance);
        static void Clean(MiniBossAshuraLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraObjectCircleLaser {
        float rotationSpeed;
        float moveRadiusMin;
        float moveRadiusMax;
        float initKeepTime;
        float scaleUpTime;
        float scaleUpKeepTime;
        float scaleDownTime;
        float scaleDownKeepTime;
        int32_t num;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraObjectCircleLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraObjectCircleLaser* pInstance);
        static void Clean(MiniBossAshuraObjectCircleLaser* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraObjectCrawlSpark {
        int32_t createNum;
        int32_t createParkourNum;
        float createCycleTime;
        float moveSpeed;
        float lifeTime;
        float homingMaxAngle;
        float homingStartTime;
        float homingPowerMaxTime;
        float meanderingPower;
        float meanderingCycleTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraObjectCrawlSpark* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraObjectCrawlSpark* pInstance);
        static void Clean(MiniBossAshuraObjectCrawlSpark* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraObjectDashCircleBulletParamByType {
        float ocTime;
        float dashSpeed;
        float ocTimeOnGround;
        float dashSpeedOnGround;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraObjectDashCircleBulletParamByType* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraObjectDashCircleBulletParamByType* pInstance);
        static void Clean(MiniBossAshuraObjectDashCircleBulletParamByType* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraObjectDashCircleBullet {
        float moveSpeed;
        float lifeTime;
        heur::rfl::MiniBossAshuraObjectDashCircleBulletParamByType frontType;
        heur::rfl::MiniBossAshuraObjectDashCircleBulletParamByType backType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraObjectDashCircleBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraObjectDashCircleBullet* pInstance);
        static void Clean(MiniBossAshuraObjectDashCircleBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraObjectSlamWave {
        float blowOffRadius;
        float blowOffHeight;
        float killRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraObjectSlamWave* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraObjectSlamWave* pInstance);
        static void Clean(MiniBossAshuraObjectSlamWave* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraObjectParam {
        heur::rfl::MiniBossAshuraObjectCircleLaser circleLaser;
        heur::rfl::MiniBossAshuraObjectCrawlSpark crawlSpark;
        heur::rfl::MiniBossAshuraObjectDashCircleBullet dashCircleBullet;
        heur::rfl::MiniBossAshuraObjectSlamWave slamWave;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraObjectParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraObjectParam* pInstance);
        static void Clean(MiniBossAshuraObjectParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraPhaseOnArmCircleBulletPos {
        enum class OnArmCircleBulletType : int8_t {
            CBT_NONE = 0,
            CBT_FRONT = 1,
            CBT_BACK = 2,
            NUM_CBT = 3,
        };

        OnArmCircleBulletType left;
        OnArmCircleBulletType center;
        OnArmCircleBulletType right;
        float leftOffsetAngle;
        float centerOffsetAngle;
        float rightOffsetAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraPhaseOnArmCircleBulletPos* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraPhaseOnArmCircleBulletPos* pInstance);
        static void Clean(MiniBossAshuraPhaseOnArmCircleBulletPos* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraPhaseParam {
        bool isCircleLaser;
        bool isCrawlSpark;
        bool isAttackArmWave;
        bool isAttackArmCircleBulletOnArm;
        heur::rfl::MiniBossAshuraPhaseOnArmCircleBulletPos onArmCircleBullets[8];
        bool isAttackArmCircleBullet;
        int32_t circleBulletBackTypeFreq;
        int32_t circleBulletCreateNum;
        float circleBulletCreateAngle;
        float circleJumpTargetDistace;
        float circleBulletCreateIntervalTime;
        int32_t armAttackConsecutiveNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraPhaseParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraPhaseParam* pInstance);
        static void Clean(MiniBossAshuraPhaseParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossAshuraConfig {
        heur::rfl::MiniBossAshuraCommonParam commonParam;
        heur::rfl::MiniBossAshuraLevelParam levelParams[5];
        heur::rfl::MiniBossAshuraLevelBand levelBand[5];
        heur::rfl::MiniBossAshuraObjectParam objectParam;
        heur::rfl::MiniBossAshuraPhaseParam phaseParam[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossAshuraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossAshuraConfig* pInstance);
        static void Clean(MiniBossAshuraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeCommonAIParam {
        float backRange;
        float standRange;
        float shortRange;
        float middleRange;
        float runEndDistance;
        float dashEndDistance;
        float parryRange;
        float specialBeginDisappearTime;
        float specialEndDisappearTime;
        float endWarpWaitTime;
        float shiftTimeMin;
        float shiftTimeMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeCommonAIParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeCommonAIParam* pInstance);
        static void Clean(MiniBossBladeCommonAIParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;
        heur::rfl::MiniBossBladeCommonAIParam ai;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeCommonParam* pInstance);
        static void Clean(MiniBossBladeCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeLevelCommonParam {
        float angryHpRatio;
        float stunTime;
        float downTime;
        float strikeComboTimer;
        float cyloopComboTimer;
        float blowupComboTimer;
        float attackMotionSpeed;
        float preliminaryMotionSpeed;
        float ghostPreliminaryMotionSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeLevelCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeLevelCommonParam* pInstance);
        static void Clean(MiniBossBladeLevelCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeLevelAIParam {
        float firstContactWait;
        float specialAttackInterval;
        float shortRangeIntervalMin;
        float shortRangeIntervalMax;
        float middleRangeIntervalMin;
        float middleRangeIntervalMax;
        float counterIntervalMin;
        float counterIntervalMax;
        float afterDashIntervalMin;
        float afterDashIntervalMax;
        float parryIntervalMin;
        float parryIntervalMax;
        float parryDuration;
        float slashComboCoolTime;
        float ghostDashSlashCoolTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeLevelAIParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeLevelAIParam* pInstance);
        static void Clean(MiniBossBladeLevelAIParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeSpecialAttackParam {
        uint8_t spawnNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeSpecialAttackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeSpecialAttackParam* pInstance);
        static void Clean(MiniBossBladeSpecialAttackParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig common;
        heur::rfl::MiniBossBladeLevelCommonParam general;
        heur::rfl::MiniBossBladeLevelAIParam ai;
        heur::rfl::MiniBossBladeSpecialAttackParam special;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeLevelParam* pInstance);
        static void Clean(MiniBossBladeLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeLevelPhaseAction {
        float verticalSlashRate;
        float horizontalSlashRate;
        float slashComboRate;
        float backSlashRate;
        float dashRate;
        float dashSlashRate;
        float ghostDashSlashRate;
        float specialAttackRate;
        bool useTimeStopAttack;
        float guardBeginTime;
        float guardJumpLaserRate;
        float parryJumpLaserRate;
        float cyloopJumpLaserRate;
        float doubleJumpLaserRate;
        bool useParry;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeLevelPhaseAction* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeLevelPhaseAction* pInstance);
        static void Clean(MiniBossBladeLevelPhaseAction* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeLevelBand {
        uint32_t level;
        heur::rfl::MiniBossBladeLevelPhaseAction phases[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeLevelBand* pInstance);
        static void Clean(MiniBossBladeLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossBladeConfig {
        heur::rfl::MiniBossBladeCommonParam commonParam;
        heur::rfl::MiniBossBladeLevelParam levelParams[5];
        heur::rfl::MiniBossBladeLevelBand levelBands[5];
        heur::rfl::RingParameter ringParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossBladeConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossBladeConfig* pInstance);
        static void Clean(MiniBossBladeConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGAttachmentConfig {
        float radius;
        csl::ut::Color8 color;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGAttachmentConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGAttachmentConfig* pInstance);
        static void Clean(ObjCGGAttachmentConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGBulletNormalConfig {
        float radius;
        csl::ut::Color8 color;
        float speed;
        float waitFollowTime;
        float followTime;
        float waitKillTime;
        float radiusBulletCircle;
        float followLimitAngleHorizontal;
        float followLimitAngleVertical;
        float rotateDeceleration;
        float muzzuleEffectLoopTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGBulletNormalConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGBulletNormalConfig* pInstance);
        static void Clean(ObjCGGBulletNormalConfig* pInstance);
    };
}

namespace heur::rfl {
    struct RailCameraParam {
        float yOffset;
        float cameraElevation;
        float cameraDistance;
        float cameraFovy;
        float radius;
        float cameraLookAtPointOffsetY;
        float cameraDegreeForClockwiseMovement;
        float cameraDegreeForCounterClockwiseMovement;
        float cameraMaxChangeableDegreeByStickInput;
        float cameraMaxDegreeChangedByStickInputPerSec;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(RailCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(RailCameraParam* pInstance);
        static void Clean(RailCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGRootConfig {
        float radius;
        csl::math::Vector3 offset;
        csl::ut::Color8 colorActive;
        csl::ut::Color8 colorDeactive;
        float timerHeightOffset;
        heur::rfl::RailCameraParam twoRailCamera;
        heur::rfl::RailCameraParam threeRailCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGRootConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGRootConfig* pInstance);
        static void Clean(ObjCGGRootConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGResetBindConfig {
        float radius;
        csl::ut::Color8 color;
        float timeToReachTimer;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGResetBindConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGResetBindConfig* pInstance);
        static void Clean(ObjCGGResetBindConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGLaserConfig {
        float radius;
        float heightInterval;
        csl::ut::Color8 color;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGLaserConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGLaserConfig* pInstance);
        static void Clean(ObjCGGLaserConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjCGGConfig {
        heur::rfl::ObjCGGRootConfig root;
        heur::rfl::ObjCGGBulletNormalConfig bulletNormal;
        heur::rfl::ObjCGGResetBindConfig resetBind;
        heur::rfl::ObjCGGLaserConfig laser;
        heur::rfl::ObjCGGAttachmentConfig attachment;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjCGGConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjCGGConfig* pInstance);
        static void Clean(ObjCGGConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerAirDrop {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        float upRotOffset;
        float yAngleOffset;
        float maxAngle;
        float shotTime;
        float addSpeedMax;
        float lineTime;
        float fallPower;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerAirDrop* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerAirDrop* pInstance);
        static void Clean(MiniBossChagerAirDrop* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerBarrageParam {
        enum class BarrageType : int8_t {
            TYPE_LASER = 0,
            TYPE_BALL = 1,
            TYPE_BALL_L = 2,
            TYPE_BALL_LL = 3,
            TYPE_AIR_DROP = 4,
        };

        BarrageType type;
        csl::ut::VariableString damageTag;
        float startSpeed;
        float decelePower;
        float minSpeed;
        float lifeTime;
        float waitTime;
        float lineTime;
        float scale;
        float hitVelocity;
        float parriedSpeed;
        int32_t parriedDamage;
        float parriedStaggerValue;
        float parriedStunValue;
        csl::ut::VariableString hitEffName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerBarrageParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerBarrageParam* pInstance);
        static void Clean(MiniBossChagerBarrageParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerChaseShot {
        float startWaitTime;
        int32_t muzzleNum;
        csl::math::Vector3 muzzlePosOffset[10];
        float muzzleRotOffsetX[10];
        float muzzleRotOffsetY[10];
        float muzzleTimeOffset[10];
        float muzzleLaserStartOffset[10];
        float laserShotTimeMin;
        float laserShotTimeMax;
        int32_t laserNum;
        float laserRange;
        float laserEndTime;
        float laserSpeed;
        float laserRandomRangeMin;
        float laserRandomRangeMax;
        float laserHomingTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerChaseShot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerChaseShot* pInstance);
        static void Clean(MiniBossChagerChaseShot* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerCrossBullet {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        bool isFollowPlayer;
        float startWaitTime;
        float shotIntarval;
        float maxAngle;
        float rotateSpeed;
        float rotateAngle;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerCrossBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerCrossBullet* pInstance);
        static void Clean(MiniBossChagerCrossBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerCrossLaser {
        float startWaitTime;
        float moveSpeed;
        float setDeg;
        float lifeTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerCrossLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerCrossLaser* pInstance);
        static void Clean(MiniBossChagerCrossLaser* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerDiffuseLaser {
        float startWaitTime;
        float yOffset;
        float scale;
        int32_t muzzleNum;
        csl::math::Vector3 muzzlePosOffset[10];
        float muzzleRotOffset[10];
        float muzzleTimeOffset[10];
        float muzzleLaserStartOffset[10];
        int32_t laserNum;
        int32_t attackNum;
        float laserRandomRange;
        float laserTime;
        float laserEndTime;
        float laserNextTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerDiffuseLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerDiffuseLaser* pInstance);
        static void Clean(MiniBossChagerDiffuseLaser* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerFollowLaser {
        float startWaitTime;
        float yOffset;
        float zOffset;
        float moveSpeed;
        float followDeg;
        int32_t shotNum;
        float intervalTime;
        float lifeTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerFollowLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerFollowLaser* pInstance);
        static void Clean(MiniBossChagerFollowLaser* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerGroundObj {
        int32_t bulletDamage;
        float bulletStaggerPoint;
        float bulletSpeed;
        float bulletFallSpeed;
        float bulletCyloopSpeed;
        float bulletGroundTime;
        float bulletFallTime;
        float yOffset;
        float zOffset;
        float upRotOffset;
        float yAngleOffset;
        float maxAngle;
        float shotTime;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerGroundObj* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerGroundObj* pInstance);
        static void Clean(MiniBossChagerGroundObj* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerMassLaser {
        float startWaitTime;
        float yOffset;
        float scale;
        float lifeTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerMassLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerMassLaser* pInstance);
        static void Clean(MiniBossChagerMassLaser* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerSimpleRotateBullet {
        int32_t barrageIndex;
        float startWaitTime;
        int32_t muzzleNum;
        float yOffset;
        float zOffset;
        float heightLength;
        float rotSpeed;
        float shakeSpeed;
        float intervalTime;
        float activeTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerSimpleRotateBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerSimpleRotateBullet* pInstance);
        static void Clean(MiniBossChagerSimpleRotateBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerVerticalRoundBullet {
        int32_t barrageIndex;
        float startWaitTime;
        int32_t muzzleNum;
        int32_t verticalNum;
        float radius;
        float spaceRate;
        float verticalWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerVerticalRoundBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerVerticalRoundBullet* pInstance);
        static void Clean(MiniBossChagerVerticalRoundBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChagerVortexLaser {
        float startWaitTime;
        int32_t muzzleNum;
        float yOffset;
        float zOffset;
        float rotSpeed;
        float moveSpeed;
        float activeTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChagerVortexLaser* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChagerVortexLaser* pInstance);
        static void Clean(MiniBossChagerVortexLaser* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerAttackParam {
        enum class AttackType : int32_t {
            AttackTypeInvalid = 0,
            AttackSimpleRotateBullet = 1,
            AttackFollowLaser = 2,
            AttackVortexLaser = 3,
            AttackCrossLaser = 4,
            AttackCrossBullet = 5,
            AttackMassLaser = 6,
            AttackVerticalRoundBullet = 7,
            AttackPyramidRoundBullet = 8,
            AttackPlaneUpDownBullet = 9,
            AttackTriangleBatteryBullet = 10,
            AttackPlayerFallBullet = 11,
            AttackGatlingRevolverBullet = 12,
            AttackWinderBullet = 13,
            AttackShotgunBullet = 14,
            AttackAirDropBullet = 15,
            AttackChaseShotObject = 16,
            AttackDiffuseLaser = 17,
            AttackChaseShot = 18,
            AttackTypeNum = 19,
        };

        AttackType type;
        int32_t index;
        float rate;
        float restTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerAttackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerAttackParam* pInstance);
        static void Clean(MiniBossChargerAttackParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerCameraShake {
        float time;
        float magnitude;
        int32_t freq;
        float attnRatio;
        float shakeRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerCameraShake* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerCameraShake* pInstance);
        static void Clean(MiniBossChargerCameraShake* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerCatchParam {
        float hitDistance;
        float durationBind;
        float distanceStartBlackOut;
        float timeEaseBlackOut;
        float timeDelayEndtBlackOut;
        csl::math::Vector3 tangentFrom;
        csl::math::Vector3 tangentTo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerCatchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerCatchParam* pInstance);
        static void Clean(MiniBossChargerCatchParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossPyramidRoundBullet {
        int32_t barrageIndex;
        float startWaitTime;
        int32_t muzzleNum;
        float radius;
        float height;
        float scale;
        int32_t sideNum;
        int32_t attackNum;
        float intervalTime;
        float nextDeg;
        float shotWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossPyramidRoundBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossPyramidRoundBullet* pInstance);
        static void Clean(MiniBossPyramidRoundBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossPlaneUpDownBullet {
        int32_t barrageIndex;
        float startWaitTime;
        float yOffset;
        float scale;
        float step;
        int32_t allNum;
        float upRate;
        float downRate;
        float frontRate;
        float shotWaitTimeMin;
        float shotWaitTimeMax;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossPlaneUpDownBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossPlaneUpDownBullet* pInstance);
        static void Clean(MiniBossPlaneUpDownBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTriangleBatteryBullet {
        int32_t barrageIndex;
        float startWaitTime;
        float yOffset;
        float edgeLength;
        float activeTime;
        float intervalTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTriangleBatteryBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTriangleBatteryBullet* pInstance);
        static void Clean(MiniBossTriangleBatteryBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossPlayerFallBullet {
        int32_t barrageIndex;
        float startWaitTime;
        float yOffset;
        float scale;
        float lengthMin;
        float lengthMax;
        float intervalTime;
        float shotWaitTime;
        float activeTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossPlayerFallBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossPlayerFallBullet* pInstance);
        static void Clean(MiniBossPlayerFallBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossGatlingRevolverBullet {
        int32_t barrageIndex;
        float startWaitTime;
        float yOffset;
        float zOffset;
        float scale;
        int32_t muzzleNum;
        float bulletRad;
        float intervalTime;
        float activeTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossGatlingRevolverBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossGatlingRevolverBullet* pInstance);
        static void Clean(MiniBossGatlingRevolverBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWinderBullet {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        bool isFollowPlayer;
        float shotIntarval;
        float maxAngle;
        float rotateSpeed;
        float rotateAngle;
        float barrageAngleDiff;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWinderBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWinderBullet* pInstance);
        static void Clean(MiniBossWinderBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossShotgunBullet {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        bool isFollowPlayer;
        float shotIntarval;
        float maxAngle;
        float yAngleOffset;
        float shotTime;
        float addSpeedMax;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossShotgunBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossShotgunBullet* pInstance);
        static void Clean(MiniBossShotgunBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;
        heur::rfl::MiniBossChagerBarrageParam barrage[16];
        heur::rfl::MiniBossChagerSimpleRotateBullet simpleRotateBullet[3];
        heur::rfl::MiniBossChagerFollowLaser followLaser[3];
        heur::rfl::MiniBossChagerVortexLaser vortexLaser[3];
        heur::rfl::MiniBossChagerCrossLaser crossLaser[3];
        heur::rfl::MiniBossChagerCrossBullet crossBullet[3];
        heur::rfl::MiniBossChagerMassLaser massLaser[3];
        heur::rfl::MiniBossChagerVerticalRoundBullet verticalRoundBullet[3];
        heur::rfl::MiniBossPyramidRoundBullet pyramidRoundBullet[3];
        heur::rfl::MiniBossPlaneUpDownBullet planeUpDownBullet[3];
        heur::rfl::MiniBossTriangleBatteryBullet triangleBatteryBullet[3];
        heur::rfl::MiniBossPlayerFallBullet playerFallBullet[3];
        heur::rfl::MiniBossGatlingRevolverBullet gatlingRevolverBullet[3];
        heur::rfl::MiniBossWinderBullet winderBullet[3];
        heur::rfl::MiniBossShotgunBullet shotgunBullet[3];
        heur::rfl::MiniBossChagerAirDrop airDrop[3];
        heur::rfl::MiniBossChagerGroundObj groundObj[3];
        heur::rfl::MiniBossChagerDiffuseLaser diffuseLaser[3];
        heur::rfl::MiniBossChagerChaseShot chaseShot[3];
        heur::rfl::MiniBossChargerCatchParam atkCatch;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerCommonParam* pInstance);
        static void Clean(MiniBossChargerCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;
        float stunTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerLevelParam* pInstance);
        static void Clean(MiniBossChargerLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerHPRateParam {
        int32_t rateHp;
        csl::ut::VariableString grindSetName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerHPRateParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerHPRateParam* pInstance);
        static void Clean(MiniBossChargerHPRateParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerLevelBand {
        enum class AttackType : int32_t {
            AttackTypeInvalid = 0,
            AttackSimpleRotateBullet = 1,
            AttackFollowLaser = 2,
            AttackVortexLaser = 3,
            AttackCrossLaser = 4,
            AttackCrossBullet = 5,
            AttackMassLaser = 6,
            AttackVerticalRoundBullet = 7,
            AttackPyramidRoundBullet = 8,
            AttackPlaneUpDownBullet = 9,
            AttackTriangleBatteryBullet = 10,
            AttackPlayerFallBullet = 11,
            AttackGatlingRevolverBullet = 12,
            AttackWinderBullet = 13,
            AttackShotgunBullet = 14,
            AttackAirDropBullet = 15,
            AttackChaseShotObject = 16,
            AttackDiffuseLaser = 17,
            AttackChaseShot = 18,
            AttackTypeNum = 19,
        };

        int32_t level;
        float rate;
        float chanceTime;
        float chanceTimeMoveSpeed;
        float chanceTimeDecSpeed;
        float chanceTimeSpeedMin;
        float damageTime;
        float chanceTimeAddSpeed;
        AttackType attackTable[10];
        int32_t attackIndexTable[10];
        heur::rfl::MiniBossChargerHPRateParam hpRateParams[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerLevelBand* pInstance);
        static void Clean(MiniBossChargerLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerLevel1 {
        enum class AttackType : int32_t {
            AttackTypeInvalid = 0,
            AttackSimpleRotateBullet = 1,
            AttackFollowLaser = 2,
            AttackVortexLaser = 3,
            AttackCrossLaser = 4,
            AttackCrossBullet = 5,
            AttackMassLaser = 6,
            AttackVerticalRoundBullet = 7,
            AttackPyramidRoundBullet = 8,
            AttackPlaneUpDownBullet = 9,
            AttackTriangleBatteryBullet = 10,
            AttackPlayerFallBullet = 11,
            AttackGatlingRevolverBullet = 12,
            AttackWinderBullet = 13,
            AttackShotgunBullet = 14,
            AttackAirDropBullet = 15,
            AttackChaseShotObject = 16,
            AttackDiffuseLaser = 17,
            AttackChaseShot = 18,
            AttackTypeNum = 19,
        };

        float range;
        AttackType attackTable[2];
        int32_t attackIndexTable[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerLevel1* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerLevel1* pInstance);
        static void Clean(MiniBossChargerLevel1* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossChargerConfig {
        heur::rfl::MiniBossChargerCommonParam commonParam;
        heur::rfl::MiniBossChargerLevelParam levelParams[5];
        heur::rfl::MiniBossChargerLevelBand levelBands[5];
        heur::rfl::MiniBossChargerLevel1 level1Params[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossChargerConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossChargerConfig* pInstance);
        static void Clean(MiniBossChargerConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaSpecialShotParamBase {
        enum class ScatterType : int8_t {
            RANDOM = 0,
            HOMING = 1,
            SPIRAL = 2,
        };

        int32_t count;
        float intervalTime;
        float shootPitchMin;
        float shootPitchMax;
        float initialSpeedMin;
        float initialSpeedMax;
        float maxAngle;
        float moveRadius;
        float maxMoveSpeed;
        float accel;
        float waitTime;
        float featherLifeTime;
        ScatterType m_scatterTypeTable[6];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaSpecialShotParamBase* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaSpecialShotParamBase* pInstance);
        static void Clean(MiniBossDarumaSpecialShotParamBase* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaBombParam : heur::rfl::MiniBossDarumaSpecialShotParamBase {
        float explosionRadius;
        float explosionEffectScale;
        float explosionTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaBombParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaBombParam* pInstance);
        static void Clean(MiniBossDarumaBombParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaCameraShakeParam {
        float time;
        float magnitude;
        int32_t freq;
        float attnRatio;
        float shakeRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaCameraShakeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaCameraShakeParam* pInstance);
        static void Clean(MiniBossDarumaCameraShakeParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaShotParam {
        int32_t count;
        float intervalTime;
        float pitchMin;
        float pitchMax;
        float pitchOffsetMin;
        float pitchOffsetMax;
        float yawOffsetRange;
        bool sweepFire;
        bool predict;
        float radius;
        float speed;
        float lifeTime;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaShotParam* pInstance);
        static void Clean(MiniBossDarumaShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaFlamePillarParam : heur::rfl::MiniBossDarumaSpecialShotParamBase {
        float burnLifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaFlamePillarParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaFlamePillarParam* pInstance);
        static void Clean(MiniBossDarumaFlamePillarParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaWaveBombParam : heur::rfl::MiniBossDarumaSpecialShotParamBase {
        float burnLifeTime;
        float cycleTime;
        float cycleDistance;
        float homingLimitAngle;
        float maxTurnAngle;
        uint32_t cycleCount;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaWaveBombParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaWaveBombParam* pInstance);
        static void Clean(MiniBossDarumaWaveBombParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaStompingParam {
        float range;
        float riseDistance;
        float riseTime;
        float chaseSpeed;
        float chaseTime;
        float speed;
        float rotationSpeed;
        float timingGap;
        float spinTime;
        float ringRiseTime;
        float waitTime;
        float staggerTime;
        float staggerDistance;
        float groundImpactRadius;
        float waveRadius;
        float waveAppearRadius;
        float waveKeepRadius;
        float waveDisappearRadius;
        float waveHeightMin;
        float waveHeightMax;
        float waveLifeTime;
        float waveVelocityX;
        float waveVelocityY;
        float laserRadius;
        float laserLength;
        float laserTime;
        float laserRotationInitialSpeed;
        float laserRotationAccel;
        float laserRotationMaxSpeed;
        float laserAccelDelayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaStompingParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaStompingParam* pInstance);
        static void Clean(MiniBossDarumaStompingParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaCyloopReactionParam {
        csl::math::Vector3 targetOffSet;
        float azimuth;
        float elevation;
        float distance;
        float zRoll;
        float fovy;
        csl::math::Vector3 cameraMoveDir;
        float cameraMoveSpeed;
        float interpolateTime;
        float bodyBreakWaitTime;
        float changeStateWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaCyloopReactionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaCyloopReactionParam* pInstance);
        static void Clean(MiniBossDarumaCyloopReactionParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaDebrisBodySmallParam {
        float lifeTime;
        float forceScale;
        float forceMin;
        float forceMax;
        float forceCyloopExplode;
        float gravity;
        float weight;
        float friction;
        int8_t maxPieceNum;
        csl::math::Vector3 centerOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaDebrisBodySmallParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaDebrisBodySmallParam* pInstance);
        static void Clean(MiniBossDarumaDebrisBodySmallParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaDebrisParam {
        float damageVelocityScale;
        float minSpeed;
        float maxSpeed;
        heur::rfl::MiniBossDarumaDebrisBodySmallParam body;
        heur::rfl::MiniBossDarumaDebrisBodySmallParam cyloop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaDebrisParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaDebrisParam* pInstance);
        static void Clean(MiniBossDarumaDebrisParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;
        float headHeight;
        int32_t bodyMaxHealthPoint;
        float bodyRadius;
        float bodyHeight;
        float baseHeight;
        float partSpace;
        float ringRadius;
        float ringHeight;
        float ringRotationSpeed;
        float gravity;
        float stunTime;
        float maxSpeed;
        float stompingTransitRange;
        int32_t questKodamaMaxNum[3];
        heur::rfl::MiniBossDarumaShotParam shot;
        heur::rfl::MiniBossDarumaShotParam shot3way;
        heur::rfl::MiniBossDarumaShotParam shot5way;
        heur::rfl::MiniBossDarumaBombParam bomb;
        heur::rfl::MiniBossDarumaFlamePillarParam flamePillar;
        heur::rfl::MiniBossDarumaWaveBombParam waveBomb;
        heur::rfl::MiniBossDarumaStompingParam stomping;
        heur::rfl::MiniBossDarumaStompingParam stompingThorn;
        heur::rfl::MiniBossDarumaStompingParam stompingQuest[3];
        heur::rfl::MiniBossDarumaStompingParam stompingQuestHigh[3];
        heur::rfl::MiniBossDarumaStompingParam stompingQuest2[3];
        heur::rfl::MiniBossDarumaStompingParam stompingQuest2High[3];
        heur::rfl::MiniBossDarumaCyloopReactionParam cyloopReaction;
        heur::rfl::MiniBossDarumaShotParam shotBerserk;
        heur::rfl::MiniBossDarumaShotParam shotBerserk3way;
        heur::rfl::MiniBossDarumaShotParam shotBerserk5way;
        heur::rfl::MiniBossDarumaStompingParam hop;
        heur::rfl::MiniBossDarumaStompingParam stompingBerserk;
        heur::rfl::MiniBossDarumaFlamePillarParam flamePillarBerserk;
        heur::rfl::MiniBossDarumaDebrisParam debris;
        heur::rfl::MiniBossDarumaCameraShakeParam cameraShakeStomping;
        heur::rfl::MiniBossDarumaCameraShakeParam cameraShakeStompingQuest;
        heur::rfl::MiniBossDarumaCameraShakeParam cameraShakeStompingQuest2;
        heur::rfl::MiniBossDarumaCameraShakeParam cameraShakeDrop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaCommonParam* pInstance);
        static void Clean(MiniBossDarumaCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaLevelParam* pInstance);
        static void Clean(MiniBossDarumaLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaLevelBand {
        enum class StompingType : int8_t {
            WEEK = 0,
            WAVE = 1,
        };

        enum class BulletType : int8_t {
            NORMAL = 0,
            THREE_WAY = 1,
            FIVE_WAY = 2,
        };

        enum class SpecialBulletType : int8_t {
            BOMB = 0,
            PILLAR = 1,
            WAVE_BOMB = 2,
        };

        uint32_t level;
        StompingType stompingType;
        int8_t laserCount;
        bool isBarrier;
        StompingType stompingTypeThorn;
        int8_t laserCountThorn;
        bool isBarrierThorn;
        BulletType bulletType;
        SpecialBulletType specialBulletType;
        int8_t stompingMaxBreakBodyCount;
        bool isThorn;
        csl::math::Vector3 headRigidColliderExtents;
        csl::math::Vector3 headRigidCollHeightOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaLevelBand* pInstance);
        static void Clean(MiniBossDarumaLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossDarumaConfig {
        heur::rfl::MiniBossDarumaCommonParam commonParam;
        heur::rfl::MiniBossDarumaLevelParam levelParams[5];
        heur::rfl::MiniBossDarumaLevelBand levelBands[5];
        heur::rfl::MiniBossDarumaLevelParam levelParamQuest;
        heur::rfl::MiniBossDarumaLevelBand levelBandQuest;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossDarumaConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossDarumaConfig* pInstance);
        static void Clean(MiniBossDarumaConfig* pInstance);
    };
}

namespace heur::rfl {
    struct FlayerEscapeShotSequenceTable {
        int32_t id;
        float interval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlayerEscapeShotSequenceTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlayerEscapeShotSequenceTable* pInstance);
        static void Clean(FlayerEscapeShotSequenceTable* pInstance);
    };
}

namespace heur::rfl {
    struct FlayerEscapeShotSequenceTableData {
        bool isUse;
        heur::rfl::FlayerEscapeShotSequenceTable table[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlayerEscapeShotSequenceTableData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlayerEscapeShotSequenceTableData* pInstance);
        static void Clean(FlayerEscapeShotSequenceTableData* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerAutoLockonParam {
        float lockonDistance;
        float unlockDistance;
        float distance;
        float minElevation;
        float maxElevation;
        float panningSuspensionK;
        float interiorPanningSuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerAutoLockonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerAutoLockonParam* pInstance);
        static void Clean(FlyerAutoLockonParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerEscapeCameraParam {
        enum class PlayerOffsetType : int8_t {
            PLAYER_OFFSET_NORMAL = 0,
            PLAYER_OFFSET_ABSOLUTE = 1,
        };

        float fovy;
        float zRot;
        float distance;
        float pathOffset;
        bool usePathVerticalComponent;
        bool usePathNormal;
        float angleSensitivity;
        float angleSensitivityBoost;
        float azimuthOffsetDeg;
        float elevationOffsetDeg;
        float gravityOffset;
        csl::math::Vector3 playerOffset;
        PlayerOffsetType playerOffsetType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerEscapeCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerEscapeCameraParam* pInstance);
        static void Clean(FlyerEscapeCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerEscapeShotTableData {
        enum class HorizontalType : int8_t {
            HorzCenter = 0,
            HorzLeft = 1,
            HorzRight = 2,
        };

        HorizontalType horz[6];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerEscapeShotTableData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerEscapeShotTableData* pInstance);
        static void Clean(FlyerEscapeShotTableData* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerEscapeShotParam {
        heur::rfl::FlyerEscapeShotTableData posTable[16];
        float interval;
        float waitAfterLoop;
        float readyDuration;
        float shotAnimSpeed;
        uint32_t shotAnimNum;
        float initSpeed;
        float maxSpeed;
        float acc;
        float lifeTime;
        float nearest;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerEscapeShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerEscapeShotParam* pInstance);
        static void Clean(FlyerEscapeShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerEscapeQuickStepParam {
        bool enable;
        float speed;
        float boostSpeed;
        float boostSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerEscapeQuickStepParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerEscapeQuickStepParam* pInstance);
        static void Clean(FlyerEscapeQuickStepParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerEscapeParam {
        float startSpeed;
        float decrease;
        float minSpeed;
        float targetDisableTime;
        float resetByFallTime;
        float resetByDistance;
        heur::rfl::FlyerEscapeShotParam shot;
        heur::rfl::FlyerEscapeCameraParam camera;
        heur::rfl::FlyerEscapeQuickStepParam quickStep;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerEscapeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerEscapeParam* pInstance);
        static void Clean(FlyerEscapeParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerGuardParam {
        float duration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerGuardParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerGuardParam* pInstance);
        static void Clean(FlyerGuardParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerIdlingNearParam {
        float durationMin;
        float durationMax;
        uint32_t selectRatio[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerIdlingNearParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerIdlingNearParam* pInstance);
        static void Clean(FlyerIdlingNearParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerNearEndLaunchParam {
        float outStrength;
        float inStrength;
        float outElev;
        float inElev;
        float speedMin;
        float speedMax;
        float speedMinLength;
        float speedMaxLength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerNearEndLaunchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerNearEndLaunchParam* pInstance);
        static void Clean(FlyerNearEndLaunchParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerNearStartCamParam {
        float duration;
        csl::math::Vector3 posOffset;
        float fovy;
        float interpolateTimePush;
        float interpolateTimePop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerNearStartCamParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerNearStartCamParam* pInstance);
        static void Clean(FlyerNearStartCamParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerNearParam {
        float duration;
        float startHABounceUp;
        float startHABounceBack;
        float preliminaryMotionSpeed;
        float resetByDistance;
        heur::rfl::FlyerNearStartCamParam startCam;
        heur::rfl::FlyerIdlingNearParam idling;
        heur::rfl::FlyerGuardParam guard;
        heur::rfl::FlyerAutoLockonParam lockon;
        heur::rfl::FlyerNearEndLaunchParam launch;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerNearParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerNearParam* pInstance);
        static void Clean(FlyerNearParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerTrailParam {
        float interval;
        int32_t recordNumWander;
        int32_t recordNumWatch;
        int32_t recordNumBattle;
        float width;
        float wallHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerTrailParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerTrailParam* pInstance);
        static void Clean(FlyerTrailParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerWanderParam {
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerWanderParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerWanderParam* pInstance);
        static void Clean(FlyerWanderParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerWatchShotParam {
        float interval;
        float readyDuration;
        float shotAnimSpeed;
        uint32_t shotAnimNum;
        float speed;
        float lifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerWatchShotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerWatchShotParam* pInstance);
        static void Clean(FlyerWatchShotParam* pInstance);
    };
}

namespace heur::rfl {
    struct FlyerWatchParam {
        float speed;
        float changeWanderTime;
        heur::rfl::FlyerWatchShotParam shot;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlyerWatchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlyerWatchParam* pInstance);
        static void Clean(FlyerWatchParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossFlyerCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;
        heur::rfl::FlyerTrailParam trail;
        heur::rfl::FlyerWanderParam wander;
        heur::rfl::FlyerWatchParam watch;
        heur::rfl::FlyerEscapeParam escape;
        heur::rfl::FlyerNearParam nearRange;
        float stunTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossFlyerCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossFlyerCommonParam* pInstance);
        static void Clean(MiniBossFlyerCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossFlyerLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossFlyerLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossFlyerLevelParam* pInstance);
        static void Clean(MiniBossFlyerLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossFlyerLevelBand {
        int32_t level;
        heur::rfl::FlayerEscapeShotSequenceTableData sequence[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossFlyerLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossFlyerLevelBand* pInstance);
        static void Clean(MiniBossFlyerLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossFlyerConfig {
        heur::rfl::MiniBossFlyerCommonParam commonParam;
        heur::rfl::MiniBossFlyerLevelParam levelParams[5];
        heur::rfl::MiniBossFlyerLevelBand levelBand[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossFlyerConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossFlyerConfig* pInstance);
        static void Clean(MiniBossFlyerConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSkierMissileConfig {
        float colliderHeight;
        float colliderRadius;
        csl::math::Vector3 colliderOffset;
        float explodeRadius;
        float distanceStartCurve;
        float distanceEndCurve;
        float inducedExplosionTimePerDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSkierMissileConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSkierMissileConfig* pInstance);
        static void Clean(ObjSkierMissileConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkeirPlayerControlLR {
        float LRFBNormalRatioSpeed;
        float LRDangerAngle;
        float LRDangerTime;
        float LRInputInterfere;
        float LRRecoverSpeed;
        float LRDragSpeed;
        float LRRecoverEndRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkeirPlayerControlLR* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkeirPlayerControlLR* pInstance);
        static void Clean(MiniBossSkeirPlayerControlLR* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkeirPlayerControlTail {
        float tailRatioChangeSpeed;
        float tailRatioRecoverSpeed;
        float tailAddSpeedMax;
        float tailAddSpeedAttenuation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkeirPlayerControlTail* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkeirPlayerControlTail* pInstance);
        static void Clean(MiniBossSkeirPlayerControlTail* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkeirPlayerControlUD {
        float UDSafeRatio;
        float UDRecoverSpeed;
        float UDDragSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkeirPlayerControlUD* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkeirPlayerControlUD* pInstance);
        static void Clean(MiniBossSkeirPlayerControlUD* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkeirTailMoveParam {
        float tailRotateMinSpeed;
        float tailRotateMaxSpeed;
        float tailRotateAddSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkeirTailMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkeirTailMoveParam* pInstance);
        static void Clean(MiniBossSkeirTailMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierSkiAcitionRate {
        float NoActionRate;
        float SnakeMoveRate;
        float JumpHighRate;
        float JumpLowRate;
        float PylonRate;
        float MissileRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierSkiAcitionRate* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierSkiAcitionRate* pInstance);
        static void Clean(MiniBossSkierSkiAcitionRate* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierBattlePhaseParam {
        float HPRate;
        heur::rfl::MiniBossSkierSkiAcitionRate actionRate;
        float showWeaknessTimeReTry;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierBattlePhaseParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierBattlePhaseParam* pInstance);
        static void Clean(MiniBossSkierBattlePhaseParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierColliderParam {
        float blockRadius;
        float blockHeight;
        float damageRadius;
        float damagedBlockRadius;
        float damagedBlockHeight;
        float returnRadius;
        float returnBlockRadius;
        float returnHeight;
        float weakPointRadius;
        float grabRadius;
        float attackRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierColliderParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierColliderParam* pInstance);
        static void Clean(MiniBossSkierColliderParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierTailParam {
        float tailExtendTime;
        float tailNodeLenthMin;
        float tailNodeLenthMax;
        float checkGroundStartDistanceOnSkiing;
        float checkGroundEndDistanceOnSkiing;
        float checkGroundEndDistanceOnSkiingJump;
        float checkGroundEndDistanceOnSkiingCamera;
        heur::rfl::MiniBossSkeirTailMoveParam rotateParamNormal;
        heur::rfl::MiniBossSkeirTailMoveParam rotateParamAttack;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierTailParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierTailParam* pInstance);
        static void Clean(MiniBossSkierTailParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierMissileParam {
        float timeExplodePassed;
        float timeExplodeAuto;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierMissileParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierMissileParam* pInstance);
        static void Clean(MiniBossSkierMissileParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierCustomCameraParam {
        float interoplateTimeActivate;
        float interoplateTimeDeactivate;
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraPosOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierCustomCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierCustomCameraParam* pInstance);
        static void Clean(MiniBossSkierCustomCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;
        heur::rfl::MiniBossSkierColliderParam colliderParam;
        heur::rfl::MiniBossSkierTailParam tailParam;
        heur::rfl::MiniBossSkeirPlayerControlLR LRControlParam;
        heur::rfl::MiniBossSkeirPlayerControlUD UDControlParam;
        heur::rfl::MiniBossSkeirPlayerControlTail tailControlParam;
        heur::rfl::MiniBossSkierMissileParam missileParam;
        heur::rfl::MiniBossSkierCustomCameraParam customCameraParam;
        heur::rfl::MiniBossSkierCustomCameraParam skiCameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierCommonParam* pInstance);
        static void Clean(MiniBossSkierCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierLevelParam* pInstance);
        static void Clean(MiniBossSkierLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierJumpOutParam {
        float attackInterval;
        float attackSensorRange;
        float returnToWanderTime;
        float pathPosAngleLimit;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierJumpOutParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierJumpOutParam* pInstance);
        static void Clean(MiniBossSkierJumpOutParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierSkiParam {
        float showWeaknessTime;
        float skiMoveSpeed;
        float skiWeakMoveSpeed;
        float skiReturnSpeed;
        float homingSpeed;
        float jumpHighSpeed;
        float jumpLowSpeed;
        float struggleTime;
        float returnUndergroundTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierSkiParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierSkiParam* pInstance);
        static void Clean(MiniBossSkierSkiParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierSnakeMoveParam {
        float snakeMoveAmplitude;
        float snakeMovePeriod;
        float snakeMovePrepareTime;
        float snakeMoveReturnTime;
        float snakeMoveDangerAngleOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierSnakeMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierSnakeMoveParam* pInstance);
        static void Clean(MiniBossSkierSnakeMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierTailAttackParam {
        float signSpeed;
        float attackMinSpeed;
        float attackMaxSpeed;
        float maxWaitTime;
        float driftLenth;
        float driftLenthUIOffset;
        float rotStartAngularSpeed;
        float rotEndAngularSpeed;
        float avoidObjCalMargePylon;
        float avoidObjCalMargeMissile;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierTailAttackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierTailAttackParam* pInstance);
        static void Clean(MiniBossSkierTailAttackParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierTailAttackPylonParam {
        float signSpeed;
        float signTime;
        float pylonAppearTime;
        float pylonDisappearTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierTailAttackPylonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierTailAttackPylonParam* pInstance);
        static void Clean(MiniBossSkierTailAttackPylonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierLevelBand {
        int32_t level;
        heur::rfl::MiniBossSkierBattlePhaseParam phaseParam[3];
        heur::rfl::MiniBossSkierJumpOutParam jumpOutParam;
        heur::rfl::MiniBossSkierSkiParam skiParam;
        heur::rfl::MiniBossSkierSnakeMoveParam snakeMoveParam;
        heur::rfl::MiniBossSkierTailAttackParam tailAttackParam;
        heur::rfl::MiniBossSkierTailAttackPylonParam pylonParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierLevelBand* pInstance);
        static void Clean(MiniBossSkierLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSkierConfig {
        heur::rfl::MiniBossSkierCommonParam commonParam;
        heur::rfl::MiniBossSkierLevelParam levelParams[5];
        heur::rfl::MiniBossSkierLevelBand levelBand[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSkierConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSkierConfig* pInstance);
        static void Clean(MiniBossSkierConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderLevelBandRate {
        float pressRate;
        float stompRate;
        float shotRate;
        float chainRate;
        float traceRate;
        float laserStraightRate;
        float laserTraceRate;
        float jumpRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderLevelBandRate* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderLevelBandRate* pInstance);
        static void Clean(MiniBossSpiderLevelBandRate* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderLevelBandInterval {
        float pressInterval;
        float stompInterval;
        float shotInterval;
        float chainInterval;
        float traceInterval;
        float laserStaightInterval;
        float laserTraceInterval;
        float jumpInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderLevelBandInterval* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderLevelBandInterval* pInstance);
        static void Clean(MiniBossSpiderLevelBandInterval* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderActionParam {
        float nearRange;
        heur::rfl::MiniBossSpiderLevelBandRate nearRates[2];
        heur::rfl::MiniBossSpiderLevelBandRate farRates[2];
        heur::rfl::MiniBossSpiderLevelBandInterval interval[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderActionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderActionParam* pInstance);
        static void Clean(MiniBossSpiderActionParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderCameraLockOn {
        float time;
        float distance;
        float minElevation;
        float maxElevation;
        float panningSuspensionK;
        float interiorPanningSuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderCameraLockOn* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderCameraLockOn* pInstance);
        static void Clean(MiniBossSpiderCameraLockOn* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderCameraShake {
        float time;
        float magnitude;
        int32_t freq;
        float attnRatio;
        float shakeRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderCameraShake* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderCameraShake* pInstance);
        static void Clean(MiniBossSpiderCameraShake* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderWaveParam {
        float radius;
        float appearRadius;
        float keepRadius;
        float disappearRadius;
        float heightMin;
        float heightMax;
        float lifeTime;
        float pauseBeginTime;
        float pauseTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderWaveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderWaveParam* pInstance);
        static void Clean(MiniBossSpiderWaveParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderCommonParam {
        enum class MiniBossSpiderBreakType : int8_t {
            BREAK_NONE = 0,
            BREAK_LEG = 1,
            BREAK_AIR_LEG = 2,
            BREAK_BOUNCE_LEG = 3,
            BREAK_GIMMICK = 4,
            BREAK_ALL = 5,
        };

        heur::rfl::MiniBossCommonConfig commonConfig;
        float patrolWalkWaitTimeMin;
        float patrolWalkWaitTimeMax;
        float jumpSpeed;
        float pressDistance;
        float waveDistance;
        float waveModelScale;
        float waveModelDiameter;
        float waveWaitTime;
        float mineDistance;
        float shotWaitTime;
        float walkWaitTime;
        float laserStraightDistance;
        float laserStraightPrepairTime;
        float laserStraightTime;
        float laserStraightAngle;
        float laserStraightWaitTime;
        float laserTraceDistance;
        float laserTracePrepairTime;
        float laserTraceTime;
        float laserTraceSpeed;
        float laserTraceWaitTime;
        float chainDistance;
        float chainJumpDistance;
        float chainWaitTime;
        float traceDistance;
        float traceJumpDistance;
        float traceSpeed;
        float traceRotSpeed;
        float traceLifeTime;
        float traceWidth;
        float traceHeight;
        float traceAppearDistance;
        float traceKeepDistance;
        float traceDisappearDistance;
        float traceWaitTime;
        float thornSpawnSpeed;
        float thornSpawnRadiusMax;
        float thornLifeTime;
        float thornFlyingSpeed;
        int32_t protecterHp;
        heur::rfl::MiniBossSpiderCameraShake cameraShakeWalk;
        heur::rfl::MiniBossSpiderCameraShake cameraShakeAttack;
        heur::rfl::RingParameter ringParam;
        heur::rfl::MiniBossSpiderWaveParam waveParams[8];
        heur::rfl::MiniBossSpiderCameraLockOn cameraLockBreakArmor;
        heur::rfl::MiniBossSpiderCameraLockOn cameraLockBlownUp;
        heur::rfl::MiniBossSpiderCameraLockOn cameraLockBlownDown;
        heur::rfl::MiniBossSpiderCameraLockOn cameraLockFootUp;
        heur::rfl::MiniBossSpiderCameraLockOn cameraLockFall;
        heur::rfl::DebrisParameter debrisSet;
        MiniBossSpiderBreakType rotationTypeTable[8];
        heur::rfl::MiniBossSpiderActionParam rotationActionTable[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderCommonParam* pInstance);
        static void Clean(MiniBossSpiderCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;
        float attackRate;
        float stunTime;
        float downTime;
        float downTime2;
        float reProtectWaitTime;
        float patrolWalkWaitTimeMin;
        float patrolWalkWaitTimeMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderLevelParam* pInstance);
        static void Clean(MiniBossSpiderLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderLevelPhaseAction {
        int8_t pressType;
        uint8_t pressNum;
        float pressWaitTime;
        int8_t stompType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderLevelPhaseAction* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderLevelPhaseAction* pInstance);
        static void Clean(MiniBossSpiderLevelPhaseAction* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderLevelPhaseDiving {
        float divingEndHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderLevelPhaseDiving* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderLevelPhaseDiving* pInstance);
        static void Clean(MiniBossSpiderLevelPhaseDiving* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderLevelBand {
        enum class MiniBossSpiderBreakType : int8_t {
            BREAK_NONE = 0,
            BREAK_LEG = 1,
            BREAK_AIR_LEG = 2,
            BREAK_BOUNCE_LEG = 3,
            BREAK_GIMMICK = 4,
            BREAK_ALL = 5,
        };

        int32_t level;
        float phaseChangeHpRatio;
        int32_t walkWaveId;
        int32_t stompWaveId;
        int32_t pressWaveId;
        bool enableCounterKick;
        MiniBossSpiderBreakType breakType;
        float mineRadius;
        float mineExplodeRadius;
        int32_t mineNum;
        float mineStartSpeed;
        float mineDecelePower;
        float mineMinSpeed;
        float mineParriedSpeed;
        float mineLifeTime;
        float mineEnableParryRate;
        int32_t mineHorizonMaxNum;
        int32_t mineVerticalNum;
        int32_t shotCount;
        float chainLifeTime;
        float chainTraceTime;
        float chainSpeed;
        float chainWaitTime;
        float chainRotateSpeed;
        int32_t chainWaveNum;
        bool enableReProtect;
        float nearRange;
        heur::rfl::MiniBossSpiderLevelBandRate nearRates[2];
        heur::rfl::MiniBossSpiderLevelBandRate farRates[2];
        heur::rfl::MiniBossSpiderLevelPhaseAction phases[2];
        heur::rfl::MiniBossSpiderLevelBandInterval interval[2];
        heur::rfl::MiniBossSpiderLevelPhaseDiving diving[2];
        float slowRate[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderLevelBand* pInstance);
        static void Clean(MiniBossSpiderLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSpiderConfig {
        heur::rfl::MiniBossSpiderCommonParam commonParam;
        heur::rfl::MiniBossSpiderLevelParam levelParams[5];
        heur::rfl::MiniBossSpiderLevelBand levelBands[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSpiderConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSpiderConfig* pInstance);
        static void Clean(MiniBossSpiderConfig* pInstance);
    };
}

namespace heur::rfl {
    struct AttackInfo {
        enum class MeansOfAttack : uint8_t {
            Bullet = 0,
            Laser = 1,
            NumAttackTypes = 2,
        };

        MeansOfAttack meansOfAttack;
        bool enabled;
        float attackInterval;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AttackInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AttackInfo* pInstance);
        static void Clean(AttackInfo* pInstance);
    };
}

namespace heur::rfl {
    struct AttackPhase {
        heur::rfl::AttackInfo attackInfos[2];
        float triggeredHPRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AttackPhase* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AttackPhase* pInstance);
        static void Clean(AttackPhase* pInstance);
    };
}

namespace heur::rfl {
    struct ArcLaserConfig {
        float arrivalTime;
        uint8_t numPatterns;
        float radius;
        float tilingDistance;
        float fluctuationPeriod;
        float fluctuationAmplitude;
        float uvScrollSpeed;
        csl::ut::Colorf colorPrimary;
        csl::ut::Color8 colorVertexEdge;
        csl::ut::Color8 colorVertexCenter;
        float colorIntensity;
        float patternChangeIntervalTime;
        float edgeWidthScale;
        float edgeWidthScaleLength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ArcLaserConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ArcLaserConfig* pInstance);
        static void Clean(ArcLaserConfig* pInstance);
    };
}

namespace heur::rfl {
    struct CommonBulletParam {
        enum class ShootingDirection : uint8_t {
            Sonic = 0,
            Random = 1,
            NumShootingDirections = 2,
        };

        ShootingDirection shootingDirection;
        float lifeTime;
        float speedToRail;
        float speed;
        float yOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CommonBulletParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CommonBulletParam* pInstance);
        static void Clean(CommonBulletParam* pInstance);
    };
}

namespace heur::rfl {
    struct HomingBulletParam : heur::rfl::CommonBulletParam {
        float railChangeDelay;
        float turnaroundTime;
        float splinePositionDistance;
        bool changesRails;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HomingBulletParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HomingBulletParam* pInstance);
        static void Clean(HomingBulletParam* pInstance);
    };
}

namespace heur::rfl {
    struct ReverseHomingBulletParam : heur::rfl::CommonBulletParam {
        float railChangeDelay;
        float turnaroundTime;
        float splinePositionDistance;
        bool changesRails;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ReverseHomingBulletParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ReverseHomingBulletParam* pInstance);
        static void Clean(ReverseHomingBulletParam* pInstance);
    };
}

namespace heur::rfl {
    struct SameBodyRailBulletParam : heur::rfl::CommonBulletParam {

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SameBodyRailBulletParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SameBodyRailBulletParam* pInstance);
        static void Clean(SameBodyRailBulletParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderBulletConfig {
        heur::rfl::HomingBulletParam homingBulletParam;
        heur::rfl::ReverseHomingBulletParam reverseHomingBulletParam;
        heur::rfl::SameBodyRailBulletParam sameBodyRailBulletParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderBulletConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderBulletConfig* pInstance);
        static void Clean(ObjStriderBulletConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderGrindRailConfig {
        float bulletSpeed;
        float bulletRotDegPerSec;
        float jumpToCenterTime;
        float jumpTime;
        float jumpToCenterTangentY;
        float jumpTangentMultiplier;
        float jumpDestinationOffsetY;
        float jumpDestinationOffsetXZ;
        float jumpToFloorHeight;
        float jumpToFloorOffset;
        float jumpToFloorTime;
        float bulletWaitTime;
        float timeTilDisappear;
        float segmentLength;
        float collisionHeight;
        float collisionRadiusAddend;
        float initialEffectScaleY;
        float initialEffectScaleXZ;
        float maxEffectScaleXZ;
        float timeToMaxEffectScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderGrindRailConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderGrindRailConfig* pInstance);
        static void Clean(ObjStriderGrindRailConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderLaserConfig {
        float lifeTime;
        float degreeVelocityPrePostLaser;
        float degreeVelocity;
        float degreeToRotate;
        float radius;
        float collisionRadius;
        float minStartingPointOffset;
        float maxStartingPointOffset;
        heur::rfl::ArcLaserConfig arcLaserConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderLaserConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderLaserConfig* pInstance);
        static void Clean(ObjStriderLaserConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossStriderCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossStriderCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossStriderCommonParam* pInstance);
        static void Clean(MiniBossStriderCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossStriderLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossStriderLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossStriderLevelParam* pInstance);
        static void Clean(MiniBossStriderLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossStriderLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossStriderLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossStriderLevelBand* pInstance);
        static void Clean(MiniBossStriderLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossStriderParam {
        heur::rfl::AttackPhase attackPhases[3];
        float initialAttackWaitBullet;
        float initialAttackWaitLaser;
        float attackableTime;
        float railBulletAttackInterval;
        float tentativePlatformTopYOffset;
        float tentativePlatformBottomYOffset;
        float tentativePlatformRadius;
        float cameraElevation;
        float cameraFovy;
        float cameraDistance;
        float cameraDegreeForClockwiseMovement;
        float cameraDegreeForCounterClockwiseMovement;
        float cameraLookAtPointOffsetY;
        float cameraMaxChangeableDegreeByStickInput;
        float cameraMaxDegreeChangedByStickInputPerSec;
        float attackableCameraElevation;
        float attackableCameraDistance;
        float attackableCameraInterpolationTime;
        float attackableCameraDuration;
        bool enableAttackableCamera;
        bool enableStun;
        bool enableStagger;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossStriderParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossStriderParam* pInstance);
        static void Clean(MiniBossStriderParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderGrindRailParam {
        float radius1;
        float radius2;
        float radius3;
        float yOffset1;
        float yOffset2;
        float yOffset3;
        uint8_t numRailBulletsFiredAtOnce;
        float railBulletPreAttackEffectTime;
        float railBulletRadius;
        float railBulletSearchDistance;
        float maxJumpDistanceFromRailBullet;
        float distToDestWithinWhichJumpIsDone;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderGrindRailParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderGrindRailParam* pInstance);
        static void Clean(ObjStriderGrindRailParam* pInstance);
    };
}

namespace heur::rfl {
    struct ObjStriderPlatformParam {
        float colliderRadius;
        float colliderHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjStriderPlatformParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjStriderPlatformParam* pInstance);
        static void Clean(ObjStriderPlatformParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossStriderConfig {
        heur::rfl::MiniBossStriderCommonParam commonParam;
        heur::rfl::MiniBossStriderLevelParam levelParams[5];
        heur::rfl::MiniBossStriderLevelBand levelBand[5];
        heur::rfl::MiniBossStriderParam striderParam;
        heur::rfl::ObjStriderGrindRailParam grindRailParam;
        heur::rfl::ObjStriderPlatformParam platformParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossStriderConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossStriderConfig* pInstance);
        static void Clean(MiniBossStriderConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPoleColliderConfig {
        float baseHeight;
        float baseRadius;
        float baseOffset;
        float poleHeight;
        float poleRadius;
        float rigidAdditionalHeight;
        float ropeThicknessRigid;
        float ropeThicknessDamage;
        float ropeThicknessArea;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPoleColliderConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPoleColliderConfig* pInstance);
        static void Clean(ObjSumoPoleColliderConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPoleSlingShotLookDownCameraConfig {
        float interpolationTime;
        float height;
        float fovy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPoleSlingShotLookDownCameraConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPoleSlingShotLookDownCameraConfig* pInstance);
        static void Clean(ObjSumoPoleSlingShotLookDownCameraConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPoleSlingShotConfig {
        float shotGuideMoveDistance;
        float shotRaycastLength;
        float sweepCapsuleHeight;
        float shotMoveLengthMax;
        int32_t shotReflectCountMax;
        int32_t shotReflectOwnerCountMax;
        float shotOffset;
        float shotDirAngleLimit;
        float shotDirAngleChangeSpeed;
        float shotSpeedMin;
        float shotSpeedMax;
        float shotSpeedAdd;
        float cancelSpeed;
        float bendPullLength;
        float aimTimeScale;
        float aimLimitTime;
        heur::rfl::ObjSumoPoleSlingShotLookDownCameraConfig cameraLookDown;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPoleSlingShotConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPoleSlingShotConfig* pInstance);
        static void Clean(ObjSumoPoleSlingShotConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPoleSlingshotLineConfig {
        float width;
        float maxDistance;
        float tilingDistance;
        float uvScrollSpeedMin;
        float uvScrollSpeedMax;
        int32_t reflectCountSpeedMax;
        csl::ut::Color8 colors[5];
        float colorIntensity;
        bool colorGradation;
        bool colorChangeAll;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPoleSlingshotLineConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPoleSlingshotLineConfig* pInstance);
        static void Clean(ObjSumoPoleSlingshotLineConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPoleRopeElectricConfig {
        float width;
        float tilingDistance;
        float fluctuationPeriod;
        float fluctuationAmplitude;
        float uvScrollSpeed;
        csl::ut::Colorf colorPrimary;
        csl::ut::Color8 colorVertexEdge;
        csl::ut::Color8 colorVertexCenter;
        float colorIntensityAnimTime;
        float colorIntensityMin;
        float colorIntensityMax;
        float patternChangeIntervalTime;
        float edgeWidthScale;
        float edgeWidthScaleLength;
        float roll;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPoleRopeElectricConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPoleRopeElectricConfig* pInstance);
        static void Clean(ObjSumoPoleRopeElectricConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPoleRopeConfig {
        float timeAppear;
        float timeDisappear;
        int32_t count;
        float swingWidthMin;
        float swingWidthMax;
        float swingWidthReductionRate;
        float swingTime;
        float swingPeriod;
        float swingReturnSlowTime;
        heur::rfl::ObjSumoPoleRopeElectricConfig electric;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPoleRopeConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPoleRopeConfig* pInstance);
        static void Clean(ObjSumoPoleRopeConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPoleConfig {
        int32_t electricDamageToEnemy;
        heur::rfl::ObjSumoPoleColliderConfig collider;
        heur::rfl::ObjSumoPoleSlingShotConfig slingShot;
        heur::rfl::ObjSumoPoleSlingshotLineConfig line;
        heur::rfl::ObjSumoPoleRopeConfig rope;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPoleConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPoleConfig* pInstance);
        static void Clean(ObjSumoPoleConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjSumoPuckConfig {
        float mass;
        float slopeAngleMax;
        float stairHeightMax;
        float colliderRigidHeight;
        float colliderRigidRadius;
        float colliderEventHeight;
        float colliderEventRadius;
        float colliderOffsetHeightSlingshot;
        float explodeRadius;
        float bumperBlowSpeed;
        float bumperOCTime;
        int32_t damageToEnemy;
        float lifeTimeParried;
        float decelerationParried;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjSumoPuckConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjSumoPuckConfig* pInstance);
        static void Clean(ObjSumoPuckConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoBaseConfig {
        float mass;
        float slopeAngleMax;
        float timeStun;
        float timeExpend;
        float timeGuardBreak;
        float visualOffset;
        csl::math::Vector3 hpGaugeOffset;
        float guardEffectCoolTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoBaseConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoBaseConfig* pInstance);
        static void Clean(MiniBossSumoBaseConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoPuckParam {
        int32_t puckCount;
        float speed;
        float lifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoPuckParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoPuckParam* pInstance);
        static void Clean(MiniBossSumoPuckParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoElectricRopePattern {
        bool enabled;
        bool electriced[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoElectricRopePattern* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoElectricRopePattern* pInstance);
        static void Clean(MiniBossSumoElectricRopePattern* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoRotationElectricRopeParam {
        heur::rfl::MiniBossSumoElectricRopePattern patterns[10];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoRotationElectricRopeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoRotationElectricRopeParam* pInstance);
        static void Clean(MiniBossSumoRotationElectricRopeParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoBehaviorHPRateParam {
        int32_t rateHp;
        heur::rfl::MiniBossSumoPuckParam puck;
        heur::rfl::MiniBossSumoRotationElectricRopeParam rotation8;
        heur::rfl::MiniBossSumoRotationElectricRopeParam rotation7;
        heur::rfl::MiniBossSumoRotationElectricRopeParam rotation6;
        heur::rfl::MiniBossSumoRotationElectricRopeParam rotation5;
        heur::rfl::MiniBossSumoRotationElectricRopeParam rotation4;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoBehaviorHPRateParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoBehaviorHPRateParam* pInstance);
        static void Clean(MiniBossSumoBehaviorHPRateParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoColliderParam {
        enum class ColliderProperty : uint32_t {
            None = 0,
            Damaged = 1,
            DamageToPlayer = 2,
            Block = 4,
            DetectPuck = 8,
            Cyloop = 16,
            BlockBody = 32,
            SensorArm = 64,
            PressBlow = 128,
            PressBlowBody = 256,
            PressBlowArm = 512,
        };

        bool enabled;
        float height;
        float radius;
        csl::ut::VariableString attachNodeName;
        csl::math::Vector3 offset;
        csl::math::Vector3 rotation;
        csl::ut::VariableString tag;
        ColliderProperty properties[2];
        bool debugDraw;
        csl::ut::Color8 color;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoColliderParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoColliderParam* pInstance);
        static void Clean(MiniBossSumoColliderParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoColliderConfig {
        heur::rfl::MiniBossSumoColliderParam damaged[6];
        heur::rfl::MiniBossSumoColliderParam damage[2];
        heur::rfl::MiniBossSumoColliderParam detectPuck;
        heur::rfl::MiniBossSumoColliderParam cyloop;
        heur::rfl::MiniBossSumoColliderParam pressBlow[3];
        heur::rfl::MiniBossSumoColliderParam sensorArm[2];
        heur::rfl::MiniBossSumoColliderParam simpleBody;
        float moveRadius;
        float moveHeight;
        csl::math::Vector3 targetMarkerOffset;
        float comboRadiusMin;
        float comboRadiusMax;
        float comboHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoColliderConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoColliderConfig* pInstance);
        static void Clean(MiniBossSumoColliderConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoRopeConfig {
        float coolDownTimeToChangeElectric;
        float timeToWaitChangeAfterDamage;
        float blowOffSpeedDamagedElectricRope;
        float decelerationDamagedElectricRope;
        float timeElectricReaction;
        int32_t damageByReflectCount[5];
        float bendLengthOnHit;
        int32_t expansionBoundCount;
        float blowOffSpeedExpansionBoundRope;
        float decelerationExpansionBoundRope;
        float lockonPanningSuspensionKExpansionBoundRope;
        float reflectAngleMaxExpansionBoundRope;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoRopeConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoRopeConfig* pInstance);
        static void Clean(MiniBossSumoRopeConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoSlingShotConfig {
        float backInitialSpeeds[5];
        float backDeccelation;
        float frontAngle;
        float timeTurn;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoSlingShotConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoSlingShotConfig* pInstance);
        static void Clean(MiniBossSumoSlingShotConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoMoveConfig {
        float moveHorzLimitAngle;
        float moveRotateDeceleration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoMoveConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoMoveConfig* pInstance);
        static void Clean(MiniBossSumoMoveConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoThrowPuckParam {
        float distanceThrow;
        float coolTime;
        csl::math::Vector3 attachOffset;
        csl::math::Vector3 attachRotateL;
        csl::math::Vector3 attachRotateR;
        float throwAngleLimit;
        csl::math::Vector3 throwOffsetMulti;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoThrowPuckParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoThrowPuckParam* pInstance);
        static void Clean(MiniBossSumoThrowPuckParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoSlingshotComboParam {
        int32_t count;
        bool reflectBack;
        float reflectRagWidth;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoSlingshotComboParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoSlingshotComboParam* pInstance);
        static void Clean(MiniBossSumoSlingshotComboParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoIKFootParam {
        csl::math::Vector3 kneeAxisLS;
        csl::math::Vector3 footEndLS;
        float footPlantedAnkleHeightMS;
        float footRaisedAnkleHeightMS;
        float maxAnkleHeightMS;
        float minAnkleHeightMS;
        float maxKneeAngleDegrees;
        float minKneeAngleDegrees;
        float onOffGain;
        float groundAscendingGain;
        float groundDescendingGain;
        float footPlantedGain;
        float footRaisedGain;
        float footLockingGain;
        float ankleRotationGain;
        csl::ut::VariableString hipName;
        csl::ut::VariableString kneeName;
        csl::ut::VariableString ankleName;
        csl::ut::VariableString toeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoIKFootParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoIKFootParam* pInstance);
        static void Clean(MiniBossSumoIKFootParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoIKHandParam {
        csl::math::Vector3 elbowAxisLS;
        csl::math::Vector3 handOffsetLS;
        csl::math::Vector3 backHandNormalLS;
        float maxElbowAngleDegrees;
        float minElbowAngleDegrees;
        bool enforceWristRotation;
        csl::ut::VariableString shoulderName;
        csl::ut::VariableString elbowName;
        csl::ut::VariableString wristName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoIKHandParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoIKHandParam* pInstance);
        static void Clean(MiniBossSumoIKHandParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoIKParam {
        float footRaycastDistanceUp;
        float footRaycastDistanceDown;
        heur::rfl::MiniBossSumoIKFootParam feet[2];
        float handRaycastDistanceUp;
        float handRaycastDistanceDown;
        float handSweepRadius;
        float handGain;
        float easeInTimeHandIk;
        float easeOutTimeHandIk;
        heur::rfl::MiniBossSumoIKHandParam hands[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoIKParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoIKParam* pInstance);
        static void Clean(MiniBossSumoIKParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoCyloopConfig {
        float puckSpeed;
        float puckTimeStartDecelerate;
        float puckDeceleration;
        float puckLifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoCyloopConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoCyloopConfig* pInstance);
        static void Clean(MiniBossSumoCyloopConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoLockonConfig {
        float distance;
        float minElevation;
        float maxElevation;
        float elevationOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoLockonConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoLockonConfig* pInstance);
        static void Clean(MiniBossSumoLockonConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoCommonParam {
        heur::rfl::MiniBossCommonConfig common;
        heur::rfl::MiniBossSumoBaseConfig base;
        heur::rfl::MiniBossSumoColliderConfig collider;
        heur::rfl::MiniBossSumoRopeConfig rope;
        heur::rfl::MiniBossSumoSlingShotConfig slingShot;
        heur::rfl::MiniBossSumoMoveConfig move;
        heur::rfl::MiniBossSumoThrowPuckParam throwPuck;
        heur::rfl::MiniBossSumoSlingshotComboParam combo;
        heur::rfl::MiniBossSumoIKParam ik;
        heur::rfl::MiniBossSumoCyloopConfig cyloop;
        heur::rfl::MiniBossSumoLockonConfig lockon;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoCommonParam* pInstance);
        static void Clean(MiniBossSumoCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoLevelParam* pInstance);
        static void Clean(MiniBossSumoLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoLevelBand {
        int32_t level;
        heur::rfl::MiniBossSumoBehaviorHPRateParam hpRateParams[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoLevelBand* pInstance);
        static void Clean(MiniBossSumoLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossSumoConfig {
        heur::rfl::MiniBossSumoCommonParam commonParam;
        heur::rfl::MiniBossSumoLevelParam levelParams[5];
        heur::rfl::MiniBossSumoLevelBand levelBand[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossSumoConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossSumoConfig* pInstance);
        static void Clean(MiniBossSumoConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerActionParam {
        enum class ActionType : int8_t {
            BULLET = 0,
            MINE = 1,
            BASEMINE = 2,
            RINGHOLE = 3,
            LOOP = 4,
            END = 5,
        };

        float intervalTable[20];
        ActionType actionTable[20];
        int32_t nextPoint;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerActionParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerActionParam* pInstance);
        static void Clean(MiniBossTrackerActionParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerBulletParam {
        float time;
        float interval;
        float speed;
        float steeringSpeed;
        float startSteeringTime;
        float life;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerBulletParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerBulletParam* pInstance);
        static void Clean(MiniBossTrackerBulletParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerCameraLockOn {
        float time;
        float distance;
        float minElevation;
        float maxElevation;
        float panningSuspensionK;
        float interiorPanningSuspensionK;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerCameraLockOn* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerCameraLockOn* pInstance);
        static void Clean(MiniBossTrackerCameraLockOn* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerCommonParam* pInstance);
        static void Clean(MiniBossTrackerCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerLevelParam* pInstance);
        static void Clean(MiniBossTrackerLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerLevelBand* pInstance);
        static void Clean(MiniBossTrackerLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerMoveParam {
        float facingSpeed;
        float facingSpeed2;
        float steeringSpeed;
        float chaseSpeed;
        float roundSpeed;
        float changeBaseSpeed;
        float returnSpeed;
        float minSpeed;
        float turnSpeed;
        float accel;
        float brake;
        float brakeDistance;
        float damper;
        float springFactor;
        float verticalWidth;
        float verticalDamper;
        float verticalSpringFactor;
        float verticalRotateSpeed;
        float checkChaseRadius;
        float checkRoundRadius;
        float checkReturnRadius;
        float chaseRadius;
        float chaseHeight;
        float chaseWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerMoveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerMoveParam* pInstance);
        static void Clean(MiniBossTrackerMoveParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerMineParam {
        int32_t num;
        int32_t num2;
        float height;
        float deviationTime;
        float searchRadius;
        float playerRadius;
        float playerHeight;
        float setInterval;
        float life;
        float lifeEx;
        float timer;
        float explosionLife;
        float targetEffectiveDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerMineParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerMineParam* pInstance);
        static void Clean(MiniBossTrackerMineParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerRingHoleParam {
        float minRadius;
        float maxRadius;
        float maxDistance;
        float minHeight;
        float maxHeight;
        float deviationTime;
        float maxSpeed;
        float minSpeed;
        float accel;
        float stopTime;
        float damperDistance;
        float damper;
        float chaseRadius;
        float chaseSpeed;
        float disappearTime;
        float life;
        float interval;
        float radius;
        float targetEffectiveDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerRingHoleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerRingHoleParam* pInstance);
        static void Clean(MiniBossTrackerRingHoleParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerGameParam {
        int32_t hp;
        float lossRingTime;
        float pursuitTime;
        int32_t baseDebuffCount;
        int32_t addDebuffCount;
        float cameraDistance;
        float cameraDistance2;
        float cameraMinElevation;
        float cameraMaxElevation;
        float cameraTargetUpOffset;
        float cameraTargetUpOffset2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerGameParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerGameParam* pInstance);
        static void Clean(MiniBossTrackerGameParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTrackerConfig {
        heur::rfl::MiniBossTrackerCommonParam commonParam;
        heur::rfl::MiniBossTrackerLevelParam levelParams[5];
        heur::rfl::MiniBossTrackerLevelBand levelBand[5];
        heur::rfl::MiniBossTrackerCameraLockOn cameraLockDamage;
        heur::rfl::MiniBossTrackerMoveParam move;
        heur::rfl::MiniBossTrackerBulletParam bullet;
        heur::rfl::MiniBossTrackerMineParam mine;
        heur::rfl::MiniBossTrackerRingHoleParam ringHole;
        heur::rfl::MiniBossTrackerActionParam action1;
        heur::rfl::MiniBossTrackerActionParam action2;
        heur::rfl::MiniBossTrackerActionParam action3;
        heur::rfl::MiniBossTrackerActionParam action4;
        heur::rfl::MiniBossTrackerActionParam action5;
        heur::rfl::MiniBossTrackerGameParam game;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTrackerConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTrackerConfig* pInstance);
        static void Clean(MiniBossTrackerConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantAttackAirSpinParam {
        float speed;
        int32_t attackNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantAttackAirSpinParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantAttackAirSpinParam* pInstance);
        static void Clean(MiniBossTyrantAttackAirSpinParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantAttackCircleBullet {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        int32_t num;
        float speed;
        float rotSpeed;
        int32_t arrayNum;
        float arrayTime;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantAttackCircleBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantAttackCircleBullet* pInstance);
        static void Clean(MiniBossTyrantAttackCircleBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantAttackLaserParam {
        csl::math::Vector3 muzzlePosOffset;
        float time;
        float rotSpeed;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantAttackLaserParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantAttackLaserParam* pInstance);
        static void Clean(MiniBossTyrantAttackLaserParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantAttackSpinParam {
        float speed;
        float time;
        float waitTime;
        float rotSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantAttackSpinParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantAttackSpinParam* pInstance);
        static void Clean(MiniBossTyrantAttackSpinParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantAttackRouletteParam {
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantAttackRouletteParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantAttackRouletteParam* pInstance);
        static void Clean(MiniBossTyrantAttackRouletteParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantBarrageParam {
        enum class BarrageType : int8_t {
            TYPE_AIM_PLAYER = 0,
            TYPE_NO_AIM = 1,
        };

        BarrageType type;
        csl::ut::VariableString damageTag;
        float startSpeed;
        float decelePower;
        float minSpeed;
        float lifeTime;
        float waitTime;
        float lineTime;
        float scale;
        float hitVelocity;
        float parriedSpeed;
        int32_t parriedDamage;
        float parriedStaggerValue;
        float parriedStunValue;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantBarrageParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantBarrageParam* pInstance);
        static void Clean(MiniBossTyrantBarrageParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantShotgunBullet {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        bool isFollowPlayer;
        float shotIntarval;
        float maxAngle;
        float yAngleOffset;
        float shotTime;
        float addSpeedMax;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantShotgunBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantShotgunBullet* pInstance);
        static void Clean(MiniBossTyrantShotgunBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantWinderBullet {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        bool isFollowPlayer;
        float shotIntarval;
        float maxAngle;
        float rotateSpeed;
        float rotateAngle;
        float barrageAngleDiff;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantWinderBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantWinderBullet* pInstance);
        static void Clean(MiniBossTyrantWinderBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantLineBullet {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        int32_t num;
        float waitTime;
        bool isFollowPlayer;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantLineBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantLineBullet* pInstance);
        static void Clean(MiniBossTyrantLineBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantWaveBullet {
        int32_t barrageIndex;
        float yOffset;
        float zOffset;
        bool isFollowPlayer;
        float waitTime;
        float sideAngle;
        int32_t arrayNum;
        float arrayTime;
        float startWaitTime;
        float endWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantWaveBullet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantWaveBullet* pInstance);
        static void Clean(MiniBossTyrantWaveBullet* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantSequenceParameter {
        float airBattleRate;
        float nextRoundRate;
        float airBattleRateSecond;
        float chanceTime;
        float chanceTimeSecond;
        bool isSpin;
        bool isSecondAttack;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantSequenceParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantSequenceParameter* pInstance);
        static void Clean(MiniBossTyrantSequenceParameter* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantCyloopDamageParameter {
        float upPower;
        float upTime;
        float attackTime;
        float downPower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantCyloopDamageParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantCyloopDamageParameter* pInstance);
        static void Clean(MiniBossTyrantCyloopDamageParameter* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantAttackParam {
        enum class ActionType : int8_t {
            ACTION_TYPE_NONE = 0,
            ACTION_TYPE_SPIN = 1,
            ACTION_TYPE_ROULETTE = 2,
            ACTION_TYPE_LASER = 3,
            ACTION_TYPE_SHOTGUN = 4,
            ACTION_TYPE_WINDER = 5,
            ACTION_TYPE_LINE = 6,
            ACTION_TYPE_WAVE = 7,
            ACTION_TYPE_CIRCLE = 8,
        };

        heur::rfl::MiniBossTyrantAttackSpinParam spin;
        heur::rfl::MiniBossTyrantAttackAirSpinParam airSpin;
        heur::rfl::MiniBossTyrantAttackRouletteParam roulette;
        heur::rfl::MiniBossTyrantAttackLaserParam laser;
        float rotSpeed;
        heur::rfl::MiniBossTyrantBarrageParam barrage[16];
        heur::rfl::MiniBossTyrantShotgunBullet shotgunBullet;
        heur::rfl::MiniBossTyrantWinderBullet winderBullet;
        heur::rfl::MiniBossTyrantLineBullet lineBullet;
        heur::rfl::MiniBossTyrantWaveBullet waveBullet;
        heur::rfl::MiniBossTyrantAttackCircleBullet circleBullet;
        heur::rfl::MiniBossTyrantSequenceParameter sequenceParam;
        heur::rfl::MiniBossTyrantCyloopDamageParameter cyloopParam;
        ActionType actionListGround[10];
        ActionType actionListAir[10];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantAttackParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantAttackParam* pInstance);
        static void Clean(MiniBossTyrantAttackParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;
        float nonBattleRange;
        float miniDamageRange;
        float miniComboRange;
        float miniOffsetY;
        float bodyDamageRange;
        float bodyComboRange;
        float bodyOffsetY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantCommonParam* pInstance);
        static void Clean(MiniBossTyrantCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantLevelParam* pInstance);
        static void Clean(MiniBossTyrantLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantLevelBand* pInstance);
        static void Clean(MiniBossTyrantLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantDebrisParam {
        float speed;
        float accel;
        float rotate_speed_min;
        float rotate_speed_max;
        float rotate_speed_fast;
        float rotate_accel;
        float life;
        float spawn_offset;
        float spawn_interval;
        int32_t spawn_num;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantDebrisParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantDebrisParam* pInstance);
        static void Clean(MiniBossTyrantDebrisParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantStormEffectParam {
        heur::rfl::MiniBossTyrantDebrisParam debris;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantStormEffectParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantStormEffectParam* pInstance);
        static void Clean(MiniBossTyrantStormEffectParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossTyrantConfig {
        heur::rfl::MiniBossTyrantCommonParam commonParam;
        heur::rfl::MiniBossTyrantLevelParam levelParams[5];
        heur::rfl::MiniBossTyrantLevelBand levelBand[5];
        heur::rfl::MiniBossTyrantAttackParam attackParam;
        heur::rfl::MiniBossTyrantStormEffectParam stormEffectParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossTyrantConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossTyrantConfig* pInstance);
        static void Clean(MiniBossTyrantConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjWarshipDashRingConfig {
        float baseHeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjWarshipDashRingConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjWarshipDashRingConfig* pInstance);
        static void Clean(ObjWarshipDashRingConfig* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipAccelSpeed {
        float min;
        float max;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipAccelSpeed* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipAccelSpeed* pInstance);
        static void Clean(MiniBossWarshipAccelSpeed* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipBombAttackCameraParam {
        float lockonDistance;
        float unlockDistance;
        float duration;
        float distance;
        float minElevation;
        float maxElevation;
        float lockonFrameYOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipBombAttackCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipBombAttackCameraParam* pInstance);
        static void Clean(MiniBossWarshipBombAttackCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipAttackStateCameraParam {
        float midCameraPosOffset;
        heur::rfl::MiniBossWarshipBombAttackCameraParam firstCamera;
        heur::rfl::MiniBossWarshipBombAttackCameraParam secondCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipAttackStateCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipAttackStateCameraParam* pInstance);
        static void Clean(MiniBossWarshipAttackStateCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipAttackStateParam {
        float moveSpeed;
        float bombDropSpeed;
        float bombInterval;
        float explosionRadius;
        float bombPreDistEffectRange;
        float lifeTime;
        float preBombTime;
        float preBombStateSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipAttackStateParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipAttackStateParam* pInstance);
        static void Clean(MiniBossWarshipAttackStateParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipBattleFlagParam {
        float firstFinishTimer;
        float finishTimer;
        float disableHomingTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipBattleFlagParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipBattleFlagParam* pInstance);
        static void Clean(MiniBossWarshipBattleFlagParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipSpeedParam {
        float highSpeed;
        float lowSpeed;
        float changeLowSpeedDistance;
        float disableDistanceMaxSpeed;
        float relativeSpeedDisableDistance;
        float speedOnJump;
        float speedDownOnJumpDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipSpeedParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipSpeedParam* pInstance);
        static void Clean(MiniBossWarshipSpeedParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipWarpCameraParam {
        float zoomDistance;
        csl::math::Vector3 zoomOffset;
        csl::math::Vector3 zoomAngle;
        float zoomFov;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipWarpCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipWarpCameraParam* pInstance);
        static void Clean(MiniBossWarshipWarpCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipEscapeCameraParam {
        float fovy;
        float zRot;
        float distance;
        float pathOffset;
        bool usePathVerticalComponent;
        bool usePathNormal;
        float angleSensitivity;
        float angleSensitivityBoost;
        float azimuthOffsetDeg;
        float elevationOffsetDeg;
        float gravityOffset;
        csl::math::Vector3 playerOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipEscapeCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipEscapeCameraParam* pInstance);
        static void Clean(MiniBossWarshipEscapeCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipObjectParam {
        float dashRingAppearDistance;
        float dashRingDisappearDistance;
        float birdAppearDistance;
        float birdDisappearDistance;
        float bulletAppearDistance;
        float bulletDisappearDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipObjectParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipObjectParam* pInstance);
        static void Clean(MiniBossWarshipObjectParam* pInstance);
    };
}

namespace heur::rfl {
    struct WarshipNearLaunchParam {
        float outStrength;
        float inStrength;
        float outElev;
        float inElev;
        float speedMin;
        float speedMax;
        float speedMinLength;
        float speedMaxLength;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WarshipNearLaunchParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WarshipNearLaunchParam* pInstance);
        static void Clean(WarshipNearLaunchParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipCommonParam {
        heur::rfl::MiniBossCommonConfig commonConfig;
        heur::rfl::MiniBossWarshipSpeedParam speedParam;
        heur::rfl::MiniBossWarshipAccelSpeed normalSpeedParam;
        heur::rfl::MiniBossWarshipAccelSpeed boostSpeedParam;
        heur::rfl::MiniBossWarshipWarpCameraParam warpCameraParam;
        heur::rfl::MiniBossWarshipEscapeCameraParam escapeCameraParam;
        heur::rfl::MiniBossWarshipObjectParam objectParam;
        heur::rfl::WarshipNearLaunchParam launchParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipCommonParam* pInstance);
        static void Clean(MiniBossWarshipCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipLevelParam {
        int32_t level;
        heur::rfl::MiniBossLevelCommonConfig commonConfig;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipLevelParam* pInstance);
        static void Clean(MiniBossWarshipLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipLevelBand {
        int32_t level;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipLevelBand* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipLevelBand* pInstance);
        static void Clean(MiniBossWarshipLevelBand* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipRecoverBoostGaugeParam {
        float normal;
        float boost;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipRecoverBoostGaugeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipRecoverBoostGaugeParam* pInstance);
        static void Clean(MiniBossWarshipRecoverBoostGaugeParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipNearBattleCameraParam {
        float distance;
        float minElevation;
        float maxElevation;
        float targetUpOffset;
        float targetMinUpOffsetLimit;
        float targetMaxUpOffsetLimit;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipNearBattleCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipNearBattleCameraParam* pInstance);
        static void Clean(MiniBossWarshipNearBattleCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct WarshipEscapePathInfo {
        csl::ut::VariableString followPaths;
        heur::rfl::WarshipPathSectionInfo usePathInfo[50];
        heur::rfl::WarshipPathSectionInfo accelInfo[50];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WarshipEscapePathInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WarshipEscapePathInfo* pInstance);
        static void Clean(WarshipEscapePathInfo* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipEscapePathParam {
        heur::rfl::WarshipEscapePathInfo escapePathInfo[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipEscapePathParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipEscapePathParam* pInstance);
        static void Clean(MiniBossWarshipEscapePathParam* pInstance);
    };
}

namespace heur::rfl {
    struct MiniBossWarshipConfig {
        heur::rfl::MiniBossWarshipCommonParam commonParam;
        heur::rfl::MiniBossWarshipLevelParam levelParams[5];
        heur::rfl::MiniBossWarshipLevelBand levelBand[5];
        float wanderMoveSpeed;
        float railMaxLength;
        heur::rfl::MiniBossWarshipSpeedParam shiftStateMoveSpeedParam;
        float locatorDistance;
        float distanceEscapePathToStart;
        heur::rfl::MiniBossWarshipRecoverBoostGaugeParam boostGaugeParam;
        heur::rfl::MiniBossWarshipAttackStateParam attackStateParam;
        heur::rfl::MiniBossWarshipBattleFlagParam battleFlagParam;
        heur::rfl::MiniBossWarshipNearBattleCameraParam nearBattleCameraParam;
        float disableGimmickDistance;
        float warpTime;
        float cameraChangeTime;
        float cameraAppearTime;
        float spreadHomingDistance;
        heur::rfl::MiniBossWarshipEscapePathParam escapePathID[5];
        heur::rfl::MiniBossWarshipAttackStateCameraParam bombAttackCameraParam[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(MiniBossWarshipConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(MiniBossWarshipConfig* pInstance);
        static void Clean(MiniBossWarshipConfig* pInstance);
    };
}

namespace heur::rfl {
    struct FishingCommonParam {
        float baseWaveThickness;
        float baseWaveSuccessRatioNormal;
        float baseWaveSuccessRatioHold;
        float singleWaveThickness;
        float baseWaveEdgeThickness;
        float timingEdgeThickness;
        uint32_t fishShadowNum;
        float fishApproachIntervalMin;
        float fishApproachIntervalMax;
        float fishEscapeDistance;
        uint32_t buoyTwitchNumMin;
        uint32_t buoyTwitchNumMax;
        float buoyTwitchIntervalMin;
        float buoyTwitchIntervalMax;
        float inputValidTime;
        float fishingCameraTransitDelay;
        float cutinDelay;
        float cutinDuration;
        float successPullUpDelay;
        uint32_t goldenChestLimitNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingCommonParam* pInstance);
        static void Clean(FishingCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingFishGroupParam {
        float rate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingFishGroupParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingFishGroupParam* pInstance);
        static void Clean(FishingFishGroupParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingFishParam {
        enum class FishShadowType : int8_t {
            SMALL = 0,
            MEDIUM = 1,
            LARGE = 2,
        };

        enum class CatchUpMotionType : int8_t {
            SHADOW_SIZE = 0,
            LARGE_GOOD_FISH = 1,
            LARGE_GOOD_ITEM = 2,
            LARGE_BAD = 3,
            LARGE = 4,
            MEDIUM = 5,
            SMALL = 6,
            CHEST_GOOD = 7,
            CHEST_VERYGOOD = 8,
            SCROLL = 9,
        };

        enum class ToastType : int8_t {
            MOTION = 0,
            PATTERN_1 = 1,
            PATTERN_2 = 2,
            PATTERN_3 = 3,
            PATTERN_4 = 4,
        };

        int32_t fishGroupId;
        FishShadowType shadowType;
        uint32_t successPatternId;
        uint32_t wavePatternId;
        uint32_t expPoint;
        uint32_t tokenNum;
        bool isRare;
        CatchUpMotionType catchUpMotionType;
        ToastType toastType;
        csl::math::Vector3 catchUpOffsetPos;
        csl::math::Vector3 catchUpOffsetRot;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingFishParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingFishParam* pInstance);
        static void Clean(FishingFishParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingFixedResultParam {
        int32_t count;
        int32_t fishId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingFixedResultParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingFixedResultParam* pInstance);
        static void Clean(FishingFixedResultParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingSuccessPatternParam {
        uint32_t successNum;
        uint32_t failureNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingSuccessPatternParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingSuccessPatternParam* pInstance);
        static void Clean(FishingSuccessPatternParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingWaveParam {
        enum class Type : int8_t {
            TYPE_INVALID = 0,
            TYPE_NORMAL = 1,
            TYPE_HOLD = 2,
        };

        Type type;
        float radius;
        float thickness;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingWaveParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingWaveParam* pInstance);
        static void Clean(FishingWaveParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingWaveGroupParam {
        heur::rfl::FishingWaveParam waves[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingWaveGroupParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingWaveGroupParam* pInstance);
        static void Clean(FishingWaveGroupParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingWavePatternParam {
        float speed;
        float intervalMinFirst;
        float intervalMaxFirst;
        float intervalMin;
        float intervalMax;
        float addRadiusMin;
        float addRadiusMax;
        uint32_t waveGroupNum;
        heur::rfl::FishingWaveGroupParam waveGroups[10];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingWavePatternParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingWavePatternParam* pInstance);
        static void Clean(FishingWavePatternParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingSpotSpawnFishParam {
        int32_t spawnFishId[20];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingSpotSpawnFishParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingSpotSpawnFishParam* pInstance);
        static void Clean(FishingSpotSpawnFishParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingSpotFixedResultParam {
        uint32_t tableSize;
        uint32_t achievementUnlockCount;
        heur::rfl::FishingFixedResultParam fixedResultList[50];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingSpotFixedResultParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingSpotFixedResultParam* pInstance);
        static void Clean(FishingSpotFixedResultParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingSpotParam {
        heur::rfl::FishingSpotSpawnFishParam spawnFish[4];
        heur::rfl::FishingSpotFixedResultParam fixedResults[4];
        uint32_t useFishCoinNum[4];
        uint32_t tokenRate[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingSpotParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingSpotParam* pInstance);
        static void Clean(FishingSpotParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingTutorialParam {
        uint32_t singleWaveSuccessCount;
        uint32_t holdWaveSuccessCount;
        heur::rfl::FishingWavePatternParam singleWave;
        heur::rfl::FishingWavePatternParam holdWave;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingTutorialParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingTutorialParam* pInstance);
        static void Clean(FishingTutorialParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingTradeTableParma {
        uint8_t sales[9];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingTradeTableParma* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingTradeTableParma* pInstance);
        static void Clean(FishingTradeTableParma* pInstance);
    };
}

namespace heur::rfl {
    struct FishingTradeParam {
        heur::rfl::FishingTradeTableParma spot[4];
        uint8_t prices[9];
        uint8_t pricesVeryHard[9];
        uint8_t counts[9];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingTradeParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingTradeParam* pInstance);
        static void Clean(FishingTradeParam* pInstance);
    };
}

namespace heur::rfl {
    struct FishingParameter {
        heur::rfl::FishingCommonParam common;
        heur::rfl::FishingSuccessPatternParam successPattern[10];
        heur::rfl::FishingWavePatternParam wavePattern[10];
        heur::rfl::FishingFishGroupParam fishGroup[10];
        heur::rfl::FishingFishParam fish[130];
        heur::rfl::FishingSpotParam spot;
        heur::rfl::FishingTutorialParam tutorial;
        heur::rfl::FishingTradeParam trade;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishingParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishingParameter* pInstance);
        static void Clean(FishingParameter* pInstance);
    };
}

namespace heur::rfl {
    struct GimmickCameraSimpleParam {
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 cameraPosOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GimmickCameraSimpleParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GimmickCameraSimpleParam* pInstance);
        static void Clean(GimmickCameraSimpleParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaMasterCamera {
        csl::math::Vector3 camLookAtOffset;
        csl::math::Vector3 camEyeOffset;
        float camFovy;
        float camRoll;
        float camEaseInTime;
        float camEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaMasterCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaMasterCamera* pInstance);
        static void Clean(KodamaMasterCamera* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaMasterKingCamera {
        csl::math::Vector3 camLookAtOffset;
        csl::math::Vector3 camEyeOffset;
        float camFovy;
        float camRoll;
        float camEaseInTime;
        float camEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaMasterKingCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaMasterKingCamera* pInstance);
        static void Clean(KodamaMasterKingCamera* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaEscortParameterElement {
        int32_t applicableFailedCount;
        float stackingHeight;
        float blowAwayLengthMin;
        float blowAwayLengthMax;
        float blowAwayHeightMin;
        float blowAwayHeightMax;
        float modelScale;
        float modelScaleSticking;
        float capsuleRadius;
        float capsuleHeight;
        csl::math::Vector3 capsuleOffset;
        float searchRadius;
        float rotationAnglePerSec;
        float verticalJumpSpeedMin;
        float verticalJumpSpeedMax;
        float horizontalJumpSpeedMin;
        float horizontalJumpSpeedMax;
        float jumpInterval;
        float contactRadius;
        float collectTime;
        float splineVelocityY;
        float splineVelocityMultiplier;
        float splineJumpTime;
        float flockRange;
        float spaceHA;
        float maxTiltOfEachKodamaBending;
        float bendingTimeDuringStop;
        float maxTiltOfEachKodamaBendingStop;
        float bendingCycleTimeDuringStay;
        float maxTiltOfEachKodamaBendingStay;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaEscortParameterElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaEscortParameterElement* pInstance);
        static void Clean(ObjKodamaEscortParameterElement* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaEscortParameter {
        heur::rfl::ObjKodamaEscortParameterElement element[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaEscortParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaEscortParameter* pInstance);
        static void Clean(ObjKodamaEscortParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaMasterConfig {
        float followingDistance;
        float followingNormalSpeed;
        float followingDecelerationSpeed;
        float followingDecelerationDistance;
        float followingHomingDistance;
        float followingHomingNormalSpeed;
        float followingHomingDecelerationSpeed;
        float followingHomingDecelerationDistance;
        float followingHeightPosition;
        heur::rfl::KodamaMasterCamera beginCamera;
        heur::rfl::KodamaMasterCamera endCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaMasterConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaMasterConfig* pInstance);
        static void Clean(ObjKodamaMasterConfig* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaMasterKingConfig {
        float playerChangeFadeOutTime;
        float followingDistance;
        float followingNormalSpeed;
        float followingDecelerationSpeed;
        float followingDecelerationDistance;
        float followingHomingDistance;
        float followingHomingNormalSpeed;
        float followingHomingDecelerationSpeed;
        float followingHomingDecelerationDistance;
        float followingHeightPosition;
        float SuperSonicfollowingNormalSpeed;
        float SuperSonicfollowingDecelerationSpeed;
        float SuperSonicfollowingDecelerationDistance;
        float SuperSonicfollowingHomingNormalSpeed;
        float SuperSonicfollowingHomingDecelerationSpeed;
        float SuperSonicfollowingHomingDecelerationDistance;
        csl::math::Vector3 followingInitialLocalPosition;
        csl::math::Vector3 superSonicInitialLocalPosition;
        heur::rfl::KodamaMasterKingCamera beginCamera;
        heur::rfl::KodamaMasterKingCamera endCamera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaMasterKingConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaMasterKingConfig* pInstance);
        static void Clean(ObjKodamaMasterKingConfig* pInstance);
    };
}

namespace heur::rfl {
    struct QuestKodamaCollectionBaseParameter {
        int32_t clearKodamaNum;
        float modelScale;
        float capsuleRadius;
        float capsuleHeight;
        csl::math::Vector3 capsuleOffset;
        float searchRadius;
        float collectTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestKodamaCollectionBaseParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestKodamaCollectionBaseParameter* pInstance);
        static void Clean(QuestKodamaCollectionBaseParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestKodamaCollectionMoveParameter {
        float rotationAnglePerSec;
        float moveSpeed;
        float moveStopSpeed;
        float moveStopeTime;
        float groupRadius;
        float groupMoveAdjustRangeOffset;
        float groupLeaderFixTime;
        float returnToCenterDistance;
        float returnToCenterRotationAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestKodamaCollectionMoveParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestKodamaCollectionMoveParameter* pInstance);
        static void Clean(QuestKodamaCollectionMoveParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestKodamaCollectionBombParameter {
        float bombSpawnTrialTime;
        uint16_t numKodamasNeededForBombSpawnRate2;
        uint16_t numKodamasNeededForBombSpawnRate3;
        float bombSpawnRate1;
        float bombSpawnRate2;
        float bombSpawnRate3;
        uint8_t maxAliveBombNum;
        float bombSpawnRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestKodamaCollectionBombParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestKodamaCollectionBombParameter* pInstance);
        static void Clean(QuestKodamaCollectionBombParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestKodamaCollectionSandBombParameter : heur::rfl::QuestKodamaCollectionBombParameter {
        float sandStormTime;
        float noBombsTime;
        float sandStormInLerpTime;
        float sandStormOutLerpTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestKodamaCollectionSandBombParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestKodamaCollectionSandBombParameter* pInstance);
        static void Clean(QuestKodamaCollectionSandBombParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestKodamaCollectionTimerParameter {
        bool isTimeUp;
        float timeLimitSeconds;
        float cautionTime;
        float warningTime;
        bool useCautionAnimation;
        bool useWarningAnimation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestKodamaCollectionTimerParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestKodamaCollectionTimerParameter* pInstance);
        static void Clean(QuestKodamaCollectionTimerParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaQuestDesertIslandParameter {
        int32_t applicableFailedCount;
        heur::rfl::QuestKodamaCollectionBaseParameter baseParam;
        heur::rfl::QuestKodamaCollectionMoveParameter moveParam;
        heur::rfl::QuestKodamaCollectionSandBombParameter bombParam;
        heur::rfl::QuestKodamaCollectionTimerParameter timerParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaQuestDesertIslandParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaQuestDesertIslandParameter* pInstance);
        static void Clean(ObjKodamaQuestDesertIslandParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaQuestGrassIslandParameter {
        int32_t applicableFailedCount;
        heur::rfl::QuestKodamaCollectionBaseParameter baseParam;
        heur::rfl::QuestKodamaCollectionMoveParameter moveParam;
        heur::rfl::QuestKodamaCollectionBombParameter bombParam;
        heur::rfl::QuestKodamaCollectionTimerParameter timerParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaQuestGrassIslandParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaQuestGrassIslandParameter* pInstance);
        static void Clean(ObjKodamaQuestGrassIslandParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjKodamaQuestParameter {
        heur::rfl::ObjKodamaQuestGrassIslandParameter grassIslandParam[3];
        heur::rfl::ObjKodamaQuestDesertIslandParameter desertIslandParam[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjKodamaQuestParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjKodamaQuestParameter* pInstance);
        static void Clean(ObjKodamaQuestParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjQuestBoxParameter {
        float dropBoxProbabilly;
        float boxHpSmall;
        float boxHpMiddle;
        float boxHpLarge;
        float friction;
        float mass;
        float gravity;
        float linearDamping;
        float angularDamping;
        csl::math::Vector3 maxSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjQuestBoxParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjQuestBoxParameter* pInstance);
        static void Clean(ObjQuestBoxParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBeeFlowerParameter {
        float modelScale;
        float capsuleRadiusSprouts;
        float capsuleRadiusFlower;
        float capsuleHeightSprouts;
        float capsuleHeightFlower;
        csl::math::Vector3 effectOffsetSprouts;
        csl::math::Vector3 effectOffsetFlower;
        float beeAttractDist;
        float efficacyTimeFlower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBeeFlowerParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBeeFlowerParameter* pInstance);
        static void Clean(ObjBeeFlowerParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjBeeSwarmParameter {
        csl::math::Vector3 targetOffset;
        csl::math::Vector3 targetOffsetFlower;
        float collRadius;
        float modelScale;
        float beeMoveSpeed;
        float reflectionAngle;
        float coefAverage;
        float coefCenter;
        float coefRepulse;
        float waitTimeAfterAttack;
        float waitTimeAfterFlower;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjBeeSwarmParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjBeeSwarmParameter* pInstance);
        static void Clean(ObjBeeSwarmParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMowingGrassParameter {
        float radius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMowingGrassParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMowingGrassParameter* pInstance);
        static void Clean(ObjMowingGrassParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMowingParameterElement {
        heur::rfl::ObjMowingGrassParameter grassParam;
        heur::rfl::ObjBeeFlowerParameter beeFlowerParam;
        heur::rfl::ObjBeeSwarmParameter beeSwarm;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMowingParameterElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMowingParameterElement* pInstance);
        static void Clean(ObjMowingParameterElement* pInstance);
    };
}

namespace heur::rfl {
    struct ObjMowingParameter {
        heur::rfl::ObjMowingParameterElement element[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ObjMowingParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ObjMowingParameter* pInstance);
        static void Clean(ObjMowingParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestCameraParameter {
        float distance;
        float azimuthSensitivity;
        float elevationUpSensitivity;
        float elevationDownSensitivity;
        float elevationOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestCameraParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestCameraParameter* pInstance);
        static void Clean(QuestCameraParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestCollectitemTimerParameter {
        float timeLimitSeconds;
        float cautionTime;
        float warningTime;
        bool useCautionAnimation;
        bool useWarningAnimation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestCollectitemTimerParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestCollectitemTimerParameter* pInstance);
        static void Clean(QuestCollectitemTimerParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestCollectItemParameterElement {
        int32_t applicableFailedCount;
        int32_t RequestItemNum;
        heur::rfl::QuestCollectitemTimerParameter timerParam;
        heur::rfl::QuestCameraParameter cameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestCollectItemParameterElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestCollectItemParameterElement* pInstance);
        static void Clean(QuestCollectItemParameterElement* pInstance);
    };
}

namespace heur::rfl {
    struct QuestCollectItemParameter {
        heur::rfl::QuestCollectItemParameterElement element[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestCollectItemParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestCollectItemParameter* pInstance);
        static void Clean(QuestCollectItemParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestDarumaTimerParameter {
        float timeLimitSeconds;
        float cautionTime;
        float warningTime;
        bool useCautionAnimation;
        bool useWarningAnimation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestDarumaTimerParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestDarumaTimerParameter* pInstance);
        static void Clean(QuestDarumaTimerParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestDarumaBattleParameterElement {
        int32_t applicableFailedCount;
        float collectionColliderRadius;
        float collectionColliderHeight;
        heur::rfl::QuestDarumaTimerParameter timerParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestDarumaBattleParameterElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestDarumaBattleParameterElement* pInstance);
        static void Clean(QuestDarumaBattleParameterElement* pInstance);
    };
}

namespace heur::rfl {
    struct QuestDarumaBattleParameter {
        heur::rfl::QuestDarumaBattleParameterElement element[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestDarumaBattleParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestDarumaBattleParameter* pInstance);
        static void Clean(QuestDarumaBattleParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestDrawBridgeTimerParameter {
        float timeLimitSeconds;
        float cautionTime;
        float warningTime;
        bool useCautionAnimation;
        bool useWarningAnimation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestDrawBridgeTimerParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestDrawBridgeTimerParameter* pInstance);
        static void Clean(QuestDrawBridgeTimerParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestDrawBridgeParameterElement {
        int32_t applicableFailedCount;
        heur::rfl::QuestDrawBridgeTimerParameter timerParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestDrawBridgeParameterElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestDrawBridgeParameterElement* pInstance);
        static void Clean(QuestDrawBridgeParameterElement* pInstance);
    };
}

namespace heur::rfl {
    struct QuestDrawBridgeParameter {
        heur::rfl::QuestDrawBridgeParameterElement element[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestDrawBridgeParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestDrawBridgeParameter* pInstance);
        static void Clean(QuestDrawBridgeParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestMowingEarnedScoreParameter {
        float visibleSize;
        float visibleTime;
        csl::math::Vector3 viewOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestMowingEarnedScoreParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestMowingEarnedScoreParameter* pInstance);
        static void Clean(QuestMowingEarnedScoreParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestMowingPlayerParameter {
        float playerBoostRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestMowingPlayerParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestMowingPlayerParameter* pInstance);
        static void Clean(QuestMowingPlayerParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestMowingPointParameter {
        uint32_t collisionNum;
        uint32_t pointLine;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestMowingPointParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestMowingPointParameter* pInstance);
        static void Clean(QuestMowingPointParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestMowingTimerParameter {
        float timeLimitSeconds;
        float cautionTime;
        float warningTime;
        bool useCautionAnimation;
        bool useWarningAnimation;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestMowingTimerParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestMowingTimerParameter* pInstance);
        static void Clean(QuestMowingTimerParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestMowingResultCameraParameter {
        float resultCameraEaseTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestMowingResultCameraParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestMowingResultCameraParameter* pInstance);
        static void Clean(QuestMowingResultCameraParameter* pInstance);
    };
}

namespace heur::rfl {
    struct QuestMowingParameterElement {
        int32_t applicableFailedCount;
        uint32_t questClearPoint;
        heur::rfl::QuestMowingPlayerParameter playerParam;
        uint32_t pointParamNum;
        heur::rfl::QuestMowingPointParameter pointParam[5];
        heur::rfl::QuestMowingTimerParameter timerParam;
        heur::rfl::QuestMowingEarnedScoreParameter scoreUIParam;
        heur::rfl::QuestMowingResultCameraParameter resultCameraParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestMowingParameterElement* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestMowingParameterElement* pInstance);
        static void Clean(QuestMowingParameterElement* pInstance);
    };
}

namespace heur::rfl {
    struct QuestMowingParameter {
        heur::rfl::QuestMowingParameterElement element[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(QuestMowingParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(QuestMowingParameter* pInstance);
        static void Clean(QuestMowingParameter* pInstance);
    };
}

namespace heur::rfl {
    struct AnimationParameter {
        float angle;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AnimationParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AnimationParameter* pInstance);
        static void Clean(AnimationParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BulletPatternParameter {
        enum class Type : uint8_t {
            BulletFixed = 0,
            BulletAimPlayer = 1,
            LaserNormal = 2,
            LaserThick = 3,
            LaserAimPlayer = 4,
        };

        enum class ElementType : uint8_t {
            Hacking1 = 0,
            Hacking2 = 1,
        };

        Type type;
        ElementType element;
        float startAngle;
        float endAngle;
        uint8_t shootNum;
        float shootSpeed;
        uint8_t wayNum;
        float wayAngle;
        float laserLength;
        float lifeTime;
        bool animation;
        heur::rfl::AnimationParameter animParam[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BulletPatternParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BulletPatternParameter* pInstance);
        static void Clean(BulletPatternParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BulletPatternSetParameter {
        csl::ut::VariableString name;
        heur::rfl::BulletPatternParameter param;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BulletPatternSetParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BulletPatternSetParameter* pInstance);
        static void Clean(BulletPatternSetParameter* pInstance);
    };
}

namespace heur::rfl {
    struct HackingBulletParameter {
        float bulletRadius;
        float bulletModelScale;
        float bulletRadiusLastBoss;
        float bulletModelScaleLastBoss;
        float bulletModelOffsetRateLastBoss;
        float laserNormalRadius;
        float laserThickRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HackingBulletParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HackingBulletParameter* pInstance);
        static void Clean(HackingBulletParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BulletPatternSetParameters {
        heur::rfl::HackingBulletParameter bulletParam;
        heur::rfl::BulletPatternSetParameter data[256];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BulletPatternSetParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BulletPatternSetParameters* pInstance);
        static void Clean(BulletPatternSetParameters* pInstance);
    };
}

namespace heur::rfl {
    struct EnemyLaserConfig {
        float rotLaserVanishTime;
        float rotLaserOmenTime;
        float bigLaserVanishTime;
        float bigLaserOmenTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EnemyLaserConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EnemyLaserConfig* pInstance);
        static void Clean(EnemyLaserConfig* pInstance);
    };
}

namespace heur::rfl {
    struct HackingEnemyParameterCore {
        float colliderRadius;
        float colliderHeight;
        float modelScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HackingEnemyParameterCore* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HackingEnemyParameterCore* pInstance);
        static void Clean(HackingEnemyParameterCore* pInstance);
    };
}

namespace heur::rfl {
    struct HackingEnemyParameterNormal {
        uint16_t hpS;
        uint16_t hpM;
        uint16_t hpL;
        float colliderRadius;
        float colliderHeight;
        float modelScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HackingEnemyParameterNormal* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HackingEnemyParameterNormal* pInstance);
        static void Clean(HackingEnemyParameterNormal* pInstance);
    };
}

namespace heur::rfl {
    struct HackingEnemyParameters {
        heur::rfl::HackingEnemyParameterNormal normalEnemyParam;
        heur::rfl::HackingEnemyParameterCore coreEnemyParam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HackingEnemyParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HackingEnemyParameters* pInstance);
        static void Clean(HackingEnemyParameters* pInstance);
    };
}

namespace heur::rfl {
    struct ChaosEmeraldStorageParam {
        bool isEnable;
        int8_t useKeyNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChaosEmeraldStorageParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChaosEmeraldStorageParam* pInstance);
        static void Clean(ChaosEmeraldStorageParam* pInstance);
    };
}

namespace heur::rfl {
    struct ExtraTowerParam {
        bool isEnable;
        int8_t useKeyNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtraTowerParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtraTowerParam* pInstance);
        static void Clean(ExtraTowerParam* pInstance);
    };
}

namespace heur::rfl {
    struct ExtraIslandParam {
        heur::rfl::ExtraTowerParam extratowers[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtraIslandParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtraIslandParam* pInstance);
        static void Clean(ExtraIslandParam* pInstance);
    };
}

namespace heur::rfl {
    struct IslandParam {
        heur::rfl::ChaosEmeraldStorageParam storages[7];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IslandParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IslandParam* pInstance);
        static void Clean(IslandParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaCommonParam {
        float takableRange;
        float fadeTime;
        float chestJumpOutFadeTime;
        float tutorialDelayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaCommonParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaCommonParam* pInstance);
        static void Clean(KodamaCommonParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaFollowParam {
        int8_t maxFollowNum;
        float speed;
        float rotateSpeed;
        float stopDistance;
        float vanishDistance;
        float respawnStandTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaFollowParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaFollowParam* pInstance);
        static void Clean(KodamaFollowParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaNormalParam {
        heur::rfl::KodamaCommonParam common;
        heur::rfl::KodamaFollowParam follow;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaNormalParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaNormalParam* pInstance);
        static void Clean(KodamaNormalParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaElderParam {
        int32_t levelupKodamaNum[3];
        int32_t levelupKodamaNumFriends[3];
        int32_t amyRequiredKodamaNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaElderParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaElderParam* pInstance);
        static void Clean(KodamaElderParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaHermitLvUpParam {
        int32_t difficulty[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaHermitLvUpParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaHermitLvUpParam* pInstance);
        static void Clean(KodamaHermitLvUpParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaHermitParam {
        heur::rfl::KodamaHermitLvUpParam levelupSeedNum[99];
        heur::rfl::KodamaHermitLvUpParam levelupSeedNumFriends[99];
        int32_t amyRequiredKodamaNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaHermitParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaHermitParam* pInstance);
        static void Clean(KodamaHermitParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaNewFormParam {
        float takableRange;
        float colliderRange;
        float fadeTime;
        float spaceVertical;
        float spaceHorizontal;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaNewFormParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaNewFormParam* pInstance);
        static void Clean(KodamaNewFormParam* pInstance);
    };
}

namespace heur::rfl {
    struct KodamaParam {
        heur::rfl::KodamaNormalParam normal;
        heur::rfl::KodamaElderParam elder;
        heur::rfl::KodamaHermitParam hermit;
        heur::rfl::KodamaNewFormParam newform[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KodamaParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KodamaParam* pInstance);
        static void Clean(KodamaParam* pInstance);
    };
}

namespace heur::rfl {
    struct NpcParam {
        int32_t inputSequenceItemNumShort;
        int32_t inputSequenceItemNumMiddle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(NpcParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(NpcParam* pInstance);
        static void Clean(NpcParam* pInstance);
    };
}

namespace heur::rfl {
    struct IslandParameter {
        heur::rfl::IslandParam islands[5];
        heur::rfl::ExtraIslandParam extraIsland;
        heur::rfl::KodamaParam kodama;
        heur::rfl::NpcParam npc;
        int32_t portalExtraKeyNum;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IslandParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IslandParameter* pInstance);
        static void Clean(IslandParameter* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerCameraParameter {
        enum class CameraType : uint8_t {
            None = 0,
            Fixed = 1,
            Offset = 2,
            Follow = 3,
            Pan = 4,
            StaticPan = 5,
            PanUpByFront = 6,
        };

        enum class CameraCoordType : uint8_t {
            Orthgonal = 0,
            Spherical = 1,
        };

        CameraType type;
        float time;
        float easeinTime;
        CameraCoordType lookAtCoord;
        csl::math::Vector3 localLookAtOffset;
        csl::math::Vector3 worldLookAtOffset;
        CameraCoordType eyeCoord;
        csl::math::Vector3 localEyeOffset;
        csl::math::Vector3 worldEyeOffset;
        float roll;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerCameraParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerCameraParameter* pInstance);
        static void Clean(PlayerCameraParameter* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerCameraSetParameter {
        enum class Priority : uint8_t {
            Default = 0,
            High = 1,
        };

        csl::ut::VariableString name;
        float easeoutTime;
        Priority priority;
        heur::rfl::PlayerCameraParameter param[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerCameraSetParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerCameraSetParameter* pInstance);
        static void Clean(PlayerCameraSetParameter* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerCameraSetParameters {
        heur::rfl::PlayerCameraSetParameter data[45];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerCameraSetParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerCameraSetParameters* pInstance);
        static void Clean(PlayerCameraSetParameters* pInstance);
    };
}

namespace heur::rfl {
    struct EffectRecord : heur::rfl::Record {
        csl::ut::VariableString emitterSetName[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EffectRecord* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EffectRecord* pInstance);
        static void Clean(EffectRecord* pInstance);
    };
}

namespace heur::rfl {
    struct EffectRecordBaseTable {
        heur::rfl::EffectRecord data[100];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EffectRecordBaseTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EffectRecordBaseTable* pInstance);
        static void Clean(EffectRecordBaseTable* pInstance);
    };
}

namespace heur::rfl {
    struct EffectRecordTable {
        heur::rfl::EffectRecord data[255];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(EffectRecordTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(EffectRecordTable* pInstance);
        static void Clean(EffectRecordTable* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamAirCyHammer {
        float acceleForce;
        float deceleForce;
        float overSpeedDeceleForce;
        float rotationForce;
        float rotationForceDecaySpeed;
        float rotationForceDecayRate;
        float rotationForceDecayMax;
        float groundRadius;
        csl::ut::VariableString cameraShakeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamAirCyHammer* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamAirCyHammer* pInstance);
        static void Clean(AmyParamAirCyHammer* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamBlowKissCamera {
        float playerUpOffset;
        float playerRightOffset;
        float distance;
        float targetDistance;
        float distanceEaseTime;
        float azimuth;
        float elevation;
        float easeInTime;
        float easeOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamBlowKissCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamBlowKissCamera* pInstance);
        static void Clean(AmyParamBlowKissCamera* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamHeartBreakCamera {
        float distanceToPlayer;
        float azimuthOffset;
        float elevationOffset;
        float easeInTime;
        float easeOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamHeartBreakCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamHeartBreakCamera* pInstance);
        static void Clean(AmyParamHeartBreakCamera* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamCharmAttack {
        float lockonLevelUpSpanTime[5];
        float lockonSearchDistance;
        float lockonSearchDistanceFar;
        float speed;
        float followSpeed;
        float followTime;
        float chargeTime;
        float moveTime;
        float preDamageTime;
        float damageSpanTime;
        float postDamageTime;
        csl::ut::VariableString hitStopObject;
        heur::rfl::AmyParamBlowKissCamera camera;
        heur::rfl::AmyParamHeartBreakCamera cameraHeartBreak;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamCharmAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamCharmAttack* pInstance);
        static void Clean(AmyParamCharmAttack* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamCyHammer {
        float radius;
        float effectTime;
        float rotateCycleTime;
        csl::ut::VariableString cameraShakeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamCyHammer* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamCyHammer* pInstance);
        static void Clean(AmyParamCyHammer* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopDropItemWeightParameter {
        uint32_t noneWeight;
        uint32_t ring10Weight;
        uint32_t powerSeedWeight;
        uint32_t guardSeedWeight;
        uint32_t sequenceItemWeight;
        uint32_t portalBitWeight;
        uint32_t skillPieceWeight;
        uint32_t skillPieceAmyWeight;
        uint32_t skillPieceKnucklesWeight;
        uint32_t skillPieceTailsWeight;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopDropItemWeightParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopDropItemWeightParameter* pInstance);
        static void Clean(CyloopDropItemWeightParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopDropItemParameter {
        heur::rfl::CyloopDropItemWeightParameter weight;
        heur::rfl::CyloopDropItemWeightParameter weight2;
        uint32_t numRings;
        uint32_t numRings2;
        uint32_t num10Rings;
        uint32_t numSkillPieces;
        uint32_t skillPieceExp;
        float rareDropCoolTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopDropItemParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopDropItemParameter* pInstance);
        static void Clean(CyloopDropItemParameter* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamCyHammerAppearGimmick {
        float appearWaitTime;
        heur::rfl::CyloopDropItemParameter dropItem;
        float airCyHammerBonusScale;
        float airCyHammerMinBonusDistance;
        float airCyHammerMaxBonusDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamCyHammerAppearGimmick* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamCyHammerAppearGimmick* pInstance);
        static void Clean(AmyParamCyHammerAppearGimmick* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamComboCommon {
        float longPressTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamComboCommon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamComboCommon* pInstance);
        static void Clean(PlayerParamComboCommon* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamComboMove {
        enum class ComboMoveType : uint8_t {
            Homing = 0,
            Step = 1,
            None = 2,
        };

        ComboMoveType moveType;
        float moveInitialSpeed;
        float moveMaxSpeed;
        float moveAccele;
        float timeout;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamComboMove* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamComboMove* pInstance);
        static void Clean(PlayerParamComboMove* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamComboMoveCorrection {
        float moveSpeed;
        float rotateSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamComboMoveCorrection* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamComboMoveCorrection* pInstance);
        static void Clean(PlayerParamComboMoveCorrection* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamComboTransit {
        enum class Action : int8_t {
            Root = 0,
            HomingAttack = 1,
            AerialHomingAttack = 2,
            Pursuit = 3,
            Stomping = 4,
            LoopKick = 5,
            Crasher = 6,
            SpinSlash = 7,
            SonicBoom = 8,
            CrossSlash = 9,
            HomingShot = 10,
            ChargeAttack = 11,
            QuickCyloop = 12,
            AerialQuickCyloop = 13,
            AcceleCombo1 = 14,
            AcceleCombo2 = 15,
            AcceleCombo3 = 16,
            AcceleCombo4 = 17,
            AerialAcceleCombo1 = 18,
            AerialAcceleCombo2 = 19,
            AerialAcceleCombo3 = 20,
            AerialAcceleCombo4 = 21,
            ComboFinish = 22,
            SpinJump = 23,
            Smash = 24,
            Behind = 25,
            Guarded = 26,
            Avoid = 27,
            AirBoost = 28,
            AfterAirBoost = 29,
            KnucklesPunch1 = 30,
            KnucklesPunch2 = 31,
            KnucklesUppercut = 32,
            KnucklesCyKnuckle = 33,
            KnucklesHeatKnuckle = 34,
            AmyTarotAttack = 35,
            AmyTarotAttack2 = 36,
            AmyTarotRolling = 37,
            AmyCyHammer = 38,
            AmyCharmAttack = 39,
            TailsSpanner = 40,
            ActionNum = 41,
        };

        enum class Control {
            Attack = 0,
            AttackLong = 1,
            Cyloop = 2,
            Jump = 3,
            Squat = 4,
            Shot = 5,
            ControlNum = 6,
            Invalid = -1,
        };

        Action transitExistTarget[6];
        Action transitInAir[6];
        Action transitNotExistTarget[6];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamComboTransit* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamComboTransit* pInstance);
        static void Clean(PlayerParamComboTransit* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamComboTransitTable {
        heur::rfl::PlayerParamComboTransit root;
        heur::rfl::PlayerParamComboTransit homingAttack;
        heur::rfl::PlayerParamComboTransit aerialHoming;
        heur::rfl::PlayerParamComboTransit pursuit;
        heur::rfl::PlayerParamComboTransit stomping;
        heur::rfl::PlayerParamComboTransit loopKick;
        heur::rfl::PlayerParamComboTransit crasher;
        heur::rfl::PlayerParamComboTransit spinSlash;
        heur::rfl::PlayerParamComboTransit sonicBoom;
        heur::rfl::PlayerParamComboTransit crossSlash;
        heur::rfl::PlayerParamComboTransit homingShot;
        heur::rfl::PlayerParamComboTransit chargeAttack;
        heur::rfl::PlayerParamComboTransit quickCyloop;
        heur::rfl::PlayerParamComboTransit aerialQuickCyloop;
        heur::rfl::PlayerParamComboTransit acceleCombo1;
        heur::rfl::PlayerParamComboTransit acceleCombo2;
        heur::rfl::PlayerParamComboTransit acceleCombo3;
        heur::rfl::PlayerParamComboTransit acceleCombo4;
        heur::rfl::PlayerParamComboTransit aerialAcceleCombo1;
        heur::rfl::PlayerParamComboTransit aerialAcceleCombo2;
        heur::rfl::PlayerParamComboTransit aerialAcceleCombo3;
        heur::rfl::PlayerParamComboTransit aerialAcceleCombo4;
        heur::rfl::PlayerParamComboTransit behind;
        heur::rfl::PlayerParamComboTransit guarded;
        heur::rfl::PlayerParamComboTransit avoid;
        heur::rfl::PlayerParamComboTransit airBoost;
        heur::rfl::PlayerParamComboTransit afterAirBoost;
        heur::rfl::PlayerParamComboTransit knucklesPunch1;
        heur::rfl::PlayerParamComboTransit knucklesPunch2;
        heur::rfl::PlayerParamComboTransit knucklesUppercut;
        heur::rfl::PlayerParamComboTransit knucklesCyKnuckle;
        heur::rfl::PlayerParamComboTransit knucklesHeatKnuckle;
        heur::rfl::PlayerParamComboTransit amyTarotAttack;
        heur::rfl::PlayerParamComboTransit amyTarotAttack2;
        heur::rfl::PlayerParamComboTransit amyTarotRolling;
        heur::rfl::PlayerParamComboTransit amyCyHammer;
        heur::rfl::PlayerParamComboTransit amyCharmAttack;
        heur::rfl::PlayerParamComboTransit tailsSpanner;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamComboTransitTable* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamComboTransitTable* pInstance);
        static void Clean(PlayerParamComboTransitTable* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCombo {
        heur::rfl::PlayerParamComboCommon common;
        heur::rfl::PlayerParamComboMove comboMoveSonic;
        heur::rfl::PlayerParamComboMove comboMoveSupersonic;
        heur::rfl::PlayerParamComboMoveCorrection comboMoveCorrection;
        heur::rfl::PlayerParamComboTransitTable comboTable;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCombo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCombo* pInstance);
        static void Clean(PlayerParamCombo* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamParryDebuff {
        uint32_t damagePoint;
        float effectTime;
        float initTime;
        float spanTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamParryDebuff* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamParryDebuff* pInstance);
        static void Clean(AmyParamParryDebuff* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopSlashEffectBaseParameter {
        int32_t m_divideCircle;
        float m_circleRadius;
        float m_circleWaveCycle;
        float m_circleWaveWidth;
        float m_circleWaveSpeed;
        csl::math::Vector2 m_scale;
        csl::ut::VariableString m_textureName;
        float m_flowSpeed;
        float m_twistCycle;
        float m_rollCycle;
        float m_rollPhase;
        float m_alphaHeadDistance;
        float m_alphaTailDistance;
        float m_offsetCycle;
        float m_offsetPhase;
        float m_offsetRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopSlashEffectBaseParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopSlashEffectBaseParameter* pInstance);
        static void Clean(CyloopSlashEffectBaseParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopTransparentLocusParameter : heur::rfl::CyloopSlashEffectBaseParameter {
        csl::ut::Colorf m_color0;
        csl::ut::Colorf m_color1;
        float m_luminance;
        csl::ut::Colorf m_flashColor0;
        csl::ut::Colorf m_flashColor1;
        float m_flashLuminance;
        float m_flashTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopTransparentLocusParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopTransparentLocusParameter* pInstance);
        static void Clean(CyloopTransparentLocusParameter* pInstance);
    };
}

namespace heur::rfl {
    struct OpaqueLineUvCell {
        float scale;
        float speedX;
        float speedY;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OpaqueLineUvCell* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OpaqueLineUvCell* pInstance);
        static void Clean(OpaqueLineUvCell* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopOpaqueLocusParameter : heur::rfl::CyloopSlashEffectBaseParameter {
        csl::ut::Colorf m_color;
        float m_alphaThreshold;
        heur::rfl::OpaqueLineUvCell m_uvCells[2];
        float m_uvLineScaleX;
        float m_uvLineScaleY;
        csl::ut::Colorf m_flashColor;
        float m_flashTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopOpaqueLocusParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopOpaqueLocusParameter* pInstance);
        static void Clean(CyloopOpaqueLocusParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopCrossLineParameter {
        csl::ut::VariableString m_textureNamePattern;
        csl::ut::VariableString m_textureNameDist;
        csl::ut::Colorf startColor;
        csl::ut::Colorf endColor;
        float startColorLuminance;
        float endColorLuminance;
        csl::ut::Colorf startColorFlash;
        csl::ut::Colorf endColorFlash;
        float startColorLuminanceFlash;
        float endColorLuminanceFlash;
        float flashTime;
        float patternDepth;
        float patternScrollSpeed;
        float patternDarkness;
        float patternScale;
        float glitchResX;
        float glitchResY;
        float glitchOffset;
        float glitchMaxLength;
        float startGlitchScrollSpeed;
        float startGlitchChangeSpeed;
        float startGlitchShift;
        float startGlitchContrust;
        float endGlitchScrollSpeed;
        float endGlitchChangeSpeed;
        float endGlitchShift;
        float endGlitchContrust;
        float lineWidth;
        float lineDisplayWidth;
        float lineBlackEdgeWidth;
        float lineBlackEdgeIntensity;
        float lineBlackEdgeNormalFade;
        float distNoiseScale;
        float distLowNoiseScale;
        float distHighNoiseScale;
        float distNoiseRate;
        float distScrollSpeed;
        float distIntensity;
        float dissolve;
        float dissolveRate;
        float heightOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopCrossLineParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopCrossLineParameter* pInstance);
        static void Clean(CyloopCrossLineParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopLocusParameter {
        int32_t m_numTransparentLines;
        heur::rfl::CyloopTransparentLocusParameter m_transparentLines[3];
        int32_t m_numOpaqueLines;
        heur::rfl::CyloopOpaqueLocusParameter m_opaqueLines[3];
        int32_t m_numCrossLines;
        heur::rfl::CyloopCrossLineParameter m_crossline;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopLocusParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopLocusParameter* pInstance);
        static void Clean(CyloopLocusParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopShapeWindCountParameter {
        float damageRate;
        float stunRate;
        float staggerRate;
        float velocityRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopShapeWindCountParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopShapeWindCountParameter* pInstance);
        static void Clean(CyloopShapeWindCountParameter* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopShapeWindEffectParaemter {
        heur::rfl::CyloopShapeWindCountParameter param[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopShapeWindEffectParaemter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopShapeWindEffectParaemter* pInstance);
        static void Clean(CyloopShapeWindEffectParaemter* pInstance);
    };
}

namespace heur::rfl {
    struct CyloopShapeEffectParameter {
        heur::rfl::CyloopShapeWindEffectParaemter wind;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyloopShapeEffectParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyloopShapeEffectParameter* pInstance);
        static void Clean(CyloopShapeEffectParameter* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCyloop {
        heur::rfl::CyloopLocusParameter locus;
        heur::rfl::CyloopLocusParameter locusQuick;
        heur::rfl::CyloopLocusParameter locusSuperSonic;
        heur::rfl::CyloopLocusParameter locusSuperSonicQuick;
        csl::ut::Colorf auraColor;
        heur::rfl::CyloopDropItemParameter dropItem;
        float needSpeed;
        heur::rfl::CyloopShapeEffectParameter shapeEffect;
        float lossQuickCyloopEnergy;
        float recoveryQuickCyloopEnergyByTime;
        float recoveryQuickCyloopEnergyByTimeInMinigame;
        float recoveryFriendsQuickCyloopEnergyByRing;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCyloop* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCyloop* pInstance);
        static void Clean(PlayerParamCyloop* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamOffensive {
        uint16_t pointMin;
        uint16_t pointMax;
        float damageRandomRate;
        float damageRandomRateSS;
        float shapeDamageRate;
        float shapeStunRate;
        float shapeStaggerRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamOffensive* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamOffensive* pInstance);
        static void Clean(PlayerParamOffensive* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDefensive {
        uint8_t rateMin;
        uint8_t rateMax;
        uint16_t infimumDropRings;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDefensive* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDefensive* pInstance);
        static void Clean(PlayerParamDefensive* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAttackCommon {
        heur::rfl::PlayerParamOffensive offensive;
        heur::rfl::PlayerParamDefensive defensive;
        float criticalDamageRate;
        float criticalRate;
        float criticalRateSS;
        float downedDamageRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAttackCommon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAttackCommon* pInstance);
        static void Clean(PlayerParamAttackCommon* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAttackData {
        enum class HitSE : int8_t {
            SE_None = -1,
            Weak = 0,
            Strong = 1,
            VeryStrong = 2,
        };

        enum class PlayerDamageAttribute {
            AttrHomingAttack = 0,
            AttrSpinAttack = 1,
            AttrCyloop = 2,
            AttrQuickCyloop = 3,
            AttrBlowOff = 4,
            AttrBlowUp = 5,
            AttrSlamDownward = 6,
            AttrDuplicatedDamage = 7,
            AttrShot = 8,
            AttrSlingShot = 9,
            AttrAcceleCombo = 10,
            AttrStomping = 11,
            AttrFinish = 12,
            AttrAcceleHitRate = 13,
            AttrNoneHitEffect = 14,
            AttrNoneHitReaction = 15,
            AttrTailsWaveCannon = 16,
            AttrTailsSpanner = 17,
        };

        float damageRate;
        float damageRateSS;
        uint16_t pointMin;
        uint16_t pointMax;
        float damageRateAcceleMode;
        float damageRateManual;
        float stunPoint;
        float staggerPoint;
        csl::math::Vector3 velocity;
        float velocityKeepTime;
        float addComboValue;
        float addComboValueAccele;
        float addComboValueSS;
        float addComboValueAcceleSS;
        float addQuickCyloopEnergy;
        float addQuickCyloopEnergyAccele;
        float addQuickCyloopEnergySS;
        float addQuickCyloopEnergyAcceleSS;
        float addQuickCyloopEnergyGuard;
        float addQuickCyloopEnergyAcceleGuard;
        csl::math::Vector3 gimmickVelocity;
        float ignoreTime;
        csl::ut::Bitset<uint32_t> attributes;
        HitSE se;
        csl::ut::VariableString hitEffectName;
        csl::ut::VariableString hitEffectNameSS;
        csl::ut::VariableString hitStopName;
        csl::ut::VariableString hitStopNameDead;
        csl::ut::VariableString hitStopNameDeadBoss;
        csl::ut::VariableString hitStopNameSS;
        csl::ut::VariableString hitStopNameDeadSS;
        csl::ut::VariableString hitCameraShakeName;
        csl::ut::VariableString hitCameraShakeNameDead;
        csl::ut::VariableString hitCameraShakeNameDeadBoss;
        csl::ut::VariableString hitCameraShakeNameSS;
        csl::ut::VariableString hitCameraShakeNameDeadSS;
        csl::ut::VariableString hitVibrationName;
        csl::ut::VariableString hitVibrationNameSS;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAttackData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAttackData* pInstance);
        static void Clean(PlayerParamAttackData* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAttack {
        heur::rfl::PlayerParamAttackCommon common;
        heur::rfl::PlayerParamAttackData spinAttack;
        heur::rfl::PlayerParamAttackData spinDash;
        heur::rfl::PlayerParamAttackData homingAttack;
        heur::rfl::PlayerParamAttackData homingAttackAir;
        heur::rfl::PlayerParamAttackData pursuitKick;
        heur::rfl::PlayerParamAttackData stomping;
        heur::rfl::PlayerParamAttackData stompingAttack;
        heur::rfl::PlayerParamAttackData boundStompingLast;
        heur::rfl::PlayerParamAttackData sliding;
        heur::rfl::PlayerParamAttackData loopKick;
        heur::rfl::PlayerParamAttackData crasher;
        heur::rfl::PlayerParamAttackData spinSlashHoming;
        heur::rfl::PlayerParamAttackData spinSlash;
        heur::rfl::PlayerParamAttackData spinSlashLast;
        heur::rfl::PlayerParamAttackData sonicBoom;
        heur::rfl::PlayerParamAttackData crossSlash;
        heur::rfl::PlayerParamAttackData homingShot;
        heur::rfl::PlayerParamAttackData chargeAttack;
        heur::rfl::PlayerParamAttackData chargeAttackLast;
        heur::rfl::PlayerParamAttackData cyloop;
        heur::rfl::PlayerParamAttackData cyloopQuick;
        heur::rfl::PlayerParamAttackData cyloopAerial;
        heur::rfl::PlayerParamAttackData accele1;
        heur::rfl::PlayerParamAttackData accele2;
        heur::rfl::PlayerParamAttackData aerialAccele1;
        heur::rfl::PlayerParamAttackData aerialAccele2;
        heur::rfl::PlayerParamAttackData comboFinish;
        heur::rfl::PlayerParamAttackData comboFinishF;
        heur::rfl::PlayerParamAttackData comboFinishB;
        heur::rfl::PlayerParamAttackData comboFinishL;
        heur::rfl::PlayerParamAttackData comboFinishR;
        heur::rfl::PlayerParamAttackData acceleComboFinish;
        heur::rfl::PlayerParamAttackData acceleComboFinishF;
        heur::rfl::PlayerParamAttackData acceleComboFinishB;
        heur::rfl::PlayerParamAttackData acceleComboFinishL;
        heur::rfl::PlayerParamAttackData acceleComboFinishR;
        heur::rfl::PlayerParamAttackData smash;
        heur::rfl::PlayerParamAttackData smashLast;
        heur::rfl::PlayerParamAttackData slingShot;
        heur::rfl::PlayerParamAttackData knucklesPunch1;
        heur::rfl::PlayerParamAttackData knucklesPunch2;
        heur::rfl::PlayerParamAttackData knucklesUppercut;
        heur::rfl::PlayerParamAttackData knucklesHeatKnuckle;
        heur::rfl::PlayerParamAttackData knucklesHeatKnuckleLast;
        heur::rfl::PlayerParamAttackData amyTarotAttack;
        heur::rfl::PlayerParamAttackData amyTarotAttack2;
        heur::rfl::PlayerParamAttackData amyTarotRolling;
        heur::rfl::PlayerParamAttackData amyCharmAttack;
        heur::rfl::PlayerParamAttackData amyTarotBoost;
        heur::rfl::PlayerParamAttackData tailsSpanner;
        heur::rfl::PlayerParamAttackData tailsSpannerFloat;
        heur::rfl::PlayerParamAttackData tailsPowerBoost;
        heur::rfl::PlayerParamAttackData tailsWaveCannon;
        heur::rfl::PlayerParamAttackData tailsWaveCannonFinish;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAttack* pInstance);
        static void Clean(PlayerParamAttack* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamWaterAct {
        float resistRate;
        float breatheBrake;
        float breatheTime;
        float breatheGravity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamWaterAct* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamWaterAct* pInstance);
        static void Clean(PlayerParamWaterAct* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBaseJump {
        float baseSpeed;
        float upSpeed;
        float upSpeedAir;
        float edgeSpeed;
        float airActionTime;
        float wallMoveTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBaseJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBaseJump* pInstance);
        static void Clean(PlayerParamBaseJump* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBallMove {
        float maxSpeed;
        float slidePower;
        float brakeForce;
        float slidePowerSlalom;
        float brakeForceSlalom;
        float releaseSpeed;
        bool useInput;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBallMove* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBallMove* pInstance);
        static void Clean(PlayerParamBallMove* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamLocusData {
        float width;
        float distance;
        float u0;
        float u1;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamLocusData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamLocusData* pInstance);
        static void Clean(PlayerParamLocusData* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamLocus {
        heur::rfl::PlayerParamLocusData data[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamLocus* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamLocus* pInstance);
        static void Clean(PlayerParamLocus* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAuraTrain {
        float effectSpanTime;
        float effectLifeTime;
        float effectOffsetDistance;
        float effectOverlapDistance;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAuraTrain* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAuraTrain* pInstance);
        static void Clean(PlayerParamAuraTrain* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamLevel {
        uint8_t ringsLevel;
        uint8_t speedLevel;
        uint8_t offensiveLevel;
        uint8_t defensiveLevel;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamLevel* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamLevel* pInstance);
        static void Clean(PlayerParamLevel* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBarrierWall {
        float coolTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBarrierWall* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBarrierWall* pInstance);
        static void Clean(PlayerParamBarrierWall* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageRateLevel {
        float rates[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageRateLevel* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageRateLevel* pInstance);
        static void Clean(PlayerParamDamageRateLevel* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageRate {
        heur::rfl::PlayerParamDamageRateLevel diffculties[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageRate* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageRate* pInstance);
        static void Clean(PlayerParamDamageRate* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAcceleMode {
        float declineSpeed;
        float declineSpeedAccele;
        float lossDamaged;
        float lossDamagedAccele;
        uint32_t comboRateAccele;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAcceleMode* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAcceleMode* pInstance);
        static void Clean(PlayerParamAcceleMode* pInstance);
    };
}

namespace heur::rfl {
    struct CommonPackage {
        heur::rfl::PlayerParamAttack attack;
        heur::rfl::PlayerParamWaterAct wateract;
        heur::rfl::PlayerParamBaseJump basejump;
        heur::rfl::PlayerParamBallMove ballmove;
        heur::rfl::PlayerParamLocus locus;
        heur::rfl::PlayerParamAuraTrain auratrain;
        heur::rfl::PlayerParamLevel level;
        heur::rfl::PlayerParamBarrierWall barrierWall;
        heur::rfl::PlayerParamDamageRate damageRate;
        heur::rfl::PlayerParamAcceleMode acceleMode;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CommonPackage* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CommonPackage* pInstance);
        static void Clean(CommonPackage* pInstance);
    };
}

namespace heur::rfl {
    struct CommonPackageAmy : heur::rfl::CommonPackage {
        heur::rfl::PlayerParamCombo combo;
        heur::rfl::AmyParamParryDebuff parryDebuff;
        heur::rfl::PlayerParamCyloop cyloop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CommonPackageAmy* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CommonPackageAmy* pInstance);
        static void Clean(CommonPackageAmy* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamPropellerJump {
        float initialSpeed;
        float bounceSpeed;
        float limitSpeedMin;
        float riseDampingStartTime;
        float riseDampingRate;
        float maxFallSpeed;
        float fallGravitySize;
        float minDuration;
        float propellerVertSpeedThreshold;
        bool holdTransitHover;
        float practiceTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamPropellerJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamPropellerJump* pInstance);
        static void Clean(AmyParamPropellerJump* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamStomping {
        float landAttackScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamStomping* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamStomping* pInstance);
        static void Clean(AmyParamStomping* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamHighJump {
        float jumpForce;
        float longPressTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamHighJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamHighJump* pInstance);
        static void Clean(AmyParamHighJump* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAttackCollider {
        enum class Condition : int8_t {
            Time = 0,
            Animation = 1,
        };

        enum class Shape : int8_t {
            Sphere = 0,
            Cylinder = 1,
            Box = 2,
        };

        Condition condition;
        int8_t count;
        float spanTime;
        Shape shape;
        csl::math::Vector3 shapeSize;
        csl::math::Vector3 shapeOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAttackCollider* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAttackCollider* pInstance);
        static void Clean(PlayerParamAttackCollider* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamTarotAttackSpeed {
        float initial;
        float min;
        float max;
        float minTurn;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamTarotAttackSpeed* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamTarotAttackSpeed* pInstance);
        static void Clean(AmyParamTarotAttackSpeed* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamTarotAttack {
        heur::rfl::PlayerParamAttackCollider hit;
        heur::rfl::PlayerParamAttackCollider rollingHit;
        heur::rfl::AmyParamTarotAttackSpeed speed;
        heur::rfl::AmyParamTarotAttackSpeed speedRingMax;
        float speedEaseInTime;
        float speedEaseOutTime;
        float minSpeedScale;
        float longPressTime;
        float minRollingTime;
        float rollingTime;
        float stunTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamTarotAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamTarotAttack* pInstance);
        static void Clean(AmyParamTarotAttack* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpeedAcceleData {
        float force;
        float force2;
        float damperRange;
        float jerkMin;
        float jerkMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpeedAcceleData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpeedAcceleData* pInstance);
        static void Clean(PlayerParamSpeedAcceleData* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamTarotBoostSpeed {
        float buildInitialSpeed;
        float buildMinSpeed;
        float buildMaxSpeed;
        float buildAirRotationForce;
        float initialSpeed;
        float maxSpeed;
        heur::rfl::PlayerParamSpeedAcceleData accele;
        heur::rfl::PlayerParamSpeedAcceleData decele;
        float baseRotateForce;
        float minTurnSpeed;
        float turnDeceleAngleMin;
        float turnDeceleAngleMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamTarotBoostSpeed* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamTarotBoostSpeed* pInstance);
        static void Clean(AmyParamTarotBoostSpeed* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamTarotTurnCamera {
        float minDistance;
        float maxDistance;
        float followTime;
        float easeInTime;
        float easeOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamTarotTurnCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamTarotTurnCamera* pInstance);
        static void Clean(AmyParamTarotTurnCamera* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamTarotBoost {
        enum class AirAccelMode : int8_t {
            Alawys = 0,
            None = 1,
            Speed = 2,
        };

        float prepareTime;
        float initialRunTime;
        heur::rfl::AmyParamTarotBoostSpeed speed;
        float gravitySize;
        float gravityBeginTime;
        float gravityMaxTime;
        float gravitySizeMinInAir;
        float gravitySizeMaxInAir;
        float maxGravityAccele;
        float maxGravityDecele;
        float jumpOutAngle;
        float jumpOutSpeed;
        bool humpJumpOut;
        AirAccelMode airAccelMode;
        float airAccelVertSpeedThreshold;
        float quickTurnTime;
        float quickTurnThresholdSpeed;
        float quickTurnThresholdAngle;
        float quickTurnTurnAfterSpeed;
        bool quickTurnStopEdge;
        float stompingLimitHeight;
        float stompingLimitJumpOutTime;
        heur::rfl::AmyParamTarotTurnCamera cameraTurn;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamTarotBoost* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamTarotBoost* pInstance);
        static void Clean(AmyParamTarotBoost* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamTarotDriftCamera {
        float fovy;
        float zRot;
        float distance;
        float angleLerpFactorPerSec;
        float azimuthOffset;
        float elevationOffset;
        float gravityOffset;
        float maxAzimuthOffset;
        float maxHorzOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamTarotDriftCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamTarotDriftCamera* pInstance);
        static void Clean(AmyParamTarotDriftCamera* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParamTarotDrift {
        float startAngle;
        float endSpeed;
        float minSpeed;
        float minSpeedMax;
        float maxSpeed;
        float maxSpeedMax;
        float accel;
        float brake;
        float maxSteerAngle;
        float steerAccel;
        float maxSteerSpeed;
        float neutralSteerAccel;
        float maxNeutralSteerSpeed;
        float maxRotateSpeed;
        bool steerFixedInput;
        float driftDashTime;
        heur::rfl::AmyParamTarotDriftCamera camera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParamTarotDrift* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParamTarotDrift* pInstance);
        static void Clean(AmyParamTarotDrift* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpinBoostSpeed {
        float initialSpeed;
        float maxSpeed;
        heur::rfl::PlayerParamSpeedAcceleData accele;
        heur::rfl::PlayerParamSpeedAcceleData decele;
        float baseRotateForce;
        float minTurnSpeed;
        float turnDeceleAngleMin;
        float turnDeceleAngleMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpinBoostSpeed* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpinBoostSpeed* pInstance);
        static void Clean(PlayerParamSpinBoostSpeed* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpeedAcceleData2 {
        float force;
        float damperRange;
        float jerkMin;
        float jerkMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpeedAcceleData2* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpeedAcceleData2* pInstance);
        static void Clean(PlayerParamSpeedAcceleData2* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpinBoost {
        enum class AirAccelMode : int8_t {
            Alawys = 0,
            None = 1,
            Speed = 2,
        };

        float forceRunTime;
        float initialRunTime;
        heur::rfl::PlayerParamSpinBoostSpeed speedBall;
        heur::rfl::PlayerParamSpinBoostSpeed speedBoost;
        heur::rfl::PlayerParamSpeedAcceleData2 deceleNeutralMin;
        heur::rfl::PlayerParamSpeedAcceleData2 deceleNeutralMax;
        float gravitySize;
        float gravityBeginTime;
        float gravityMaxTime;
        float gravitySizeMinInAir;
        float gravitySizeMaxInAir;
        float maxGravityAccele;
        float maxGravityDecele;
        float inAirTime;
        float spinBoostEndSpeed;
        float jumpOutAngle;
        float jumpOutSpeed;
        bool humpJumpOut;
        AirAccelMode airAccelMode;
        float airAccelVertSpeedThreshold;
        float chargeRotateForce;
        float chargeRotateForceMinAngle;
        float chargeRotateForceMaxAngle;
        csl::ut::VariableString cameraShakeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpinBoost* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpinBoost* pInstance);
        static void Clean(PlayerParamSpinBoost* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCommon {
        enum class SupportedPlane : int8_t {
            Flat = 0,
            Slope = 1,
            Wall = 2,
        };

        float movableMaxSlope;
        float activeLandingSlope;
        float activeLandingSlopeInBoost;
        float landingMaxSlope;
        float slidingMaxSlope;
        float wallAngleMaxSlope;
        SupportedPlane onStand;
        SupportedPlane onRunInAir;
        SupportedPlane onRun;
        bool moveHolding;
        bool wallSlideSlowInBoost;
        bool attrWallOnGround;
        float priorityInputTime;
        int32_t capacityRings;
        int32_t capacityRingsLvMax;
        float collectRingRange;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCommon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCommon* pInstance);
        static void Clean(PlayerParamCommon* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpeedData {
        float initial;
        float min;
        float max;
        float minTurn;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpeedData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpeedData* pInstance);
        static void Clean(PlayerParamSpeedData* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpeed {
        heur::rfl::PlayerParamSpeedData normal;
        heur::rfl::PlayerParamSpeedData normal2;
        heur::rfl::PlayerParamSpeedData boost;
        heur::rfl::PlayerParamSpeedData boost2;
        heur::rfl::PlayerParamSpeedData boostLvMax;
        heur::rfl::PlayerParamSpeedData boostLvMax2;
        float maxSpeedOver;
        float opitonMaxSpeedLimitMin;
        float opitonMaxSpeedLimitMax;
        float thresholdStopSpeed;
        float maxFallSpeed;
        heur::rfl::PlayerParamSpeedAcceleData accele;
        heur::rfl::PlayerParamSpeedAcceleData decele;
        heur::rfl::PlayerParamSpeedAcceleData2 deceleNeutralMin;
        heur::rfl::PlayerParamSpeedAcceleData2 deceleNeutralMax;
        float acceleAuto;
        float deceleAuto;
        float turnDeceleAngleMin;
        float turnDeceleAngleMax;
        float maxGravityAccele;
        float maxGravityDecele;
        float deceleSquat;
        float acceleSensitive;
        float boostAnimSpeedInWater;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpeed* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpeed* pInstance);
        static void Clean(PlayerParamSpeed* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamRotation {
        float baseRotateForce;
        float baseRotateForce2;
        float baseRotateForceSpeed;
        float minRotateForce;
        float maxRotateForce;
        bool angleRotateForceDecayEnabled;
        float frontRotateRatio;
        float rotationForceDecaySpeed;
        float rotationForceDecayRate;
        float rotationForceDecayMax;
        float autorunRotateForce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamRotation* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamRotation* pInstance);
        static void Clean(PlayerParamRotation* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamRunning {
        float walkSpeed;
        float sneakingSpeed;
        float animSpeedSneak;
        float animSpeedWalk;
        float animSpeedRun;
        float animSpeedBoost;
        float animLRBlendSampleTime;
        float animLRBlendAngleMin;
        float animLRBlendAngleMax;
        float animLRBlendSpeed;
        float animLRBlendSpeedToCenter;
        float minChangeWalkTime;
        float fallAnimationAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamRunning* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamRunning* pInstance);
        static void Clean(PlayerParamRunning* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBalanceData {
        float rotateSpeedMinFB;
        float rotateSpeedMaxFB;
        float rotateSpeedMinLR;
        float rotateSpeedMaxLR;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBalanceData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBalanceData* pInstance);
        static void Clean(PlayerParamBalanceData* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBalance {
        heur::rfl::PlayerParamBalanceData standard;
        heur::rfl::PlayerParamBalanceData loop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBalance* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBalance* pInstance);
        static void Clean(PlayerParamBalance* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBrake {
        float initialSpeedRatio;
        float maxSpeed;
        float forceLand;
        float forceAir;
        float endSpeed;
        float stopTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBrake* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBrake* pInstance);
        static void Clean(PlayerParamBrake* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamTurn {
        float thresholdSpeed;
        float thresholdAngle;
        float turnAfterSpeed;
        bool stopEdge;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamTurn* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamTurn* pInstance);
        static void Clean(PlayerParamTurn* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamJump {
        float preActionTime;
        float longPressTime;
        float addForceTime;
        float force;
        float addForce;
        float forceMin;
        float gravitySize;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamJump* pInstance);
        static void Clean(PlayerParamJump* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamJumpSpeed {
        float acceleForce;
        float deceleForce;
        float deceleNeutralForce;
        float deceleBackForce;
        float limitMin;
        float limitUpSpeed;
        float rotationForce;
        float rotationForceDecaySpeed;
        float rotationForceDecayRate;
        float rotationForceDecayMax;
        float baseAirDragScaleMin;
        float baseAirDragScaleMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamJumpSpeed* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamJumpSpeed* pInstance);
        static void Clean(PlayerParamJumpSpeed* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDoubleJump {
        float initialSpeed;
        float bounceSpeed;
        float limitSpeedMin;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDoubleJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDoubleJump* pInstance);
        static void Clean(PlayerParamDoubleJump* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamFall {
        float thresholdVertSpeed;
        float tolerateJumpTime;
        float fallEndDelayTime;
        float fallEndFadeTime;
        float acceleForce;
        float deceleForce;
        float overSpeedDeceleForce;
        float rotationForce;
        float rotationForceDecaySpeed;
        float rotationForceDecayRate;
        float rotationForceDecayMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamFall* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamFall* pInstance);
        static void Clean(PlayerParamFall* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageCommon {
        float invincibleTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageCommon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageCommon* pInstance);
        static void Clean(PlayerParamDamageCommon* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageNormal {
        float initialHorzSpeed;
        float initialVertSpeed;
        float deceleForce;
        float transitFallTime;
        float gravityScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageNormal* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageNormal* pInstance);
        static void Clean(PlayerParamDamageNormal* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageTurnBack {
        float fixedTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageTurnBack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageTurnBack* pInstance);
        static void Clean(PlayerParamDamageTurnBack* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageBlowOff {
        float initialHorzSpeed;
        float initialVertSpeed;
        float deceleForceInAir;
        float deceleForceOnGround;
        float gravityScale;
        float downTime;
        float transitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageBlowOff* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageBlowOff* pInstance);
        static void Clean(PlayerParamDamageBlowOff* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageGuarded {
        float vertSpeed;
        float horzSpeed;
        float deceleForce;
        float transitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageGuarded* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageGuarded* pInstance);
        static void Clean(PlayerParamDamageGuarded* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageRunning {
        float actionTime;
        float minSpeed;
        float lossSpeed;
        float lossTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageRunning* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageRunning* pInstance);
        static void Clean(PlayerParamDamageRunning* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageQuake {
        float actionTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageQuake* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageQuake* pInstance);
        static void Clean(PlayerParamDamageQuake* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageLava {
        csl::math::Vector3 jumpVelocity;
        float gravitySize;
        float invincibleTime;
        float noActionTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageLava* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageLava* pInstance);
        static void Clean(PlayerParamDamageLava* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamageMine {
        csl::math::Vector3 jumpVelocity;
        float gravitySize;
        float invincibleTime;
        float noActionTime;
        float gravitySizeForFall;
        float maxFallSpeed;
        csl::ut::VariableString cameraShakeName;
        csl::ut::VariableString vibrationName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamageMine* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamageMine* pInstance);
        static void Clean(PlayerParamDamageMine* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDamage {
        heur::rfl::PlayerParamDamageCommon common;
        heur::rfl::PlayerParamDamageNormal normal;
        heur::rfl::PlayerParamDamageTurnBack turnBack;
        heur::rfl::PlayerParamDamageBlowOff blowOff;
        heur::rfl::PlayerParamDamageGuarded guarded;
        heur::rfl::PlayerParamDamageGuarded guardedSS;
        heur::rfl::PlayerParamDamageRunning running;
        heur::rfl::PlayerParamDamageQuake quake;
        heur::rfl::PlayerParamDamageLava lava;
        heur::rfl::PlayerParamDamageMine mine;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDamage* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDamage* pInstance);
        static void Clean(PlayerParamDamage* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDeadNormal {
        float invincibleTime;
        float initialHorzSpeed;
        float initialVertSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDeadNormal* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDeadNormal* pInstance);
        static void Clean(PlayerParamDeadNormal* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDead {
        heur::rfl::PlayerParamDeadNormal normal;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDead* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDead* pInstance);
        static void Clean(PlayerParamDead* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSliding {
        float minSpeed;
        float endSpeed;
        float deceleJerk;
        float deceleJerkContinue;
        float deceleForceMax;
        float baseRotateForce;
        float baseRotateForceSpeed;
        float maxRotateForce;
        float frontRotateRatio;
        float rotationForceAutoRun;
        float movableMaxSlope;
        float gravitySize;
        float minContinueTime;
        float maxAutoRunTime;
        float endSpeedAutoRun;
        float loopKickTransitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSliding* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSliding* pInstance);
        static void Clean(PlayerParamSliding* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamStomping {
        float initialSpeed;
        float initialAccele;
        float maxAccele;
        float jerk;
        float maxFallSpeed;
        float angle;
        float landingCancelTime;
        float boundStompingCollisionScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamStomping* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamStomping* pInstance);
        static void Clean(PlayerParamStomping* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamGrind {
        float maxSpeed;
        float maxBoostSpeed;
        float acceleForce;
        float deceleForce;
        float limitSpeedMin;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamGrind* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamGrind* pInstance);
        static void Clean(PlayerParamGrind* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamFallSlope {
        float initialSpeed;
        float maxSpeed;
        float brakeAngle;
        float highBrakeAngle;
        float brakeForce;
        float brakeForceHigh;
        float gravitySize;
        float gravitySizeAir;
        float endSpeedFront;
        float endSpeedBack;
        float reverseFallTime;
        float fallToSlipTime;
        float slipIdlingTime;
        float minSlipTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamFallSlope* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamFallSlope* pInstance);
        static void Clean(PlayerParamFallSlope* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamFallFlip {
        float thresholdSpeed;
        float maxSpeed;
        float flipAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamFallFlip* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamFallFlip* pInstance);
        static void Clean(PlayerParamFallFlip* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamTumble {
        bool enabled;
        float sideSpinAngle;
        float initialVertSpeed;
        float gravitySize;
        float gravitySize2;
        float deceleForceInAir;
        float minSpeedInAir;
        float rotateEaseTimeLeftRight;
        float rotateEaseTimeFrontBack;
        float rotateSpeedMinLeftRight;
        float rotateSpeedMaxLeftRight;
        float rotateSpeedMinFrontBack;
        float rotateSpeedMaxFrontBack;
        float angleLeftRightStagger;
        float angleLeftRightRoll;
        float angleFrontBackRoll;
        float angleBigRoll;
        float inRunTime;
        float inAirTime;
        float rollSpeedFront;
        float bigRollVelocityRatio;
        float dropDashHoldTime;
        float airBrakeVertSpeed;
        float airBrakeForce;
        float airTrickHeight;
        float airTrickTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamTumble* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamTumble* pInstance);
        static void Clean(PlayerParamTumble* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpinAttack {
        float jumpForce;
        float jumpAddForce;
        float addTime;
        float acceleForce;
        float deceleForce;
        float brakeForce;
        float limitSpeedMin;
        float limitSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpinAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpinAttack* pInstance);
        static void Clean(PlayerParamSpinAttack* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamHomingAttackData {
        float speed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamHomingAttackData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamHomingAttackData* pInstance);
        static void Clean(PlayerParamHomingAttackData* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamHomingBounceData {
        float bounceVertSpeed;
        float bounceHorzSpeed;
        float bounceAcceleForce;
        float bounceDeceleForce;
        float bounceAngleWidth;
        float bounceTime;
        float attackDownTime;
        float attackDownTimeForStomp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamHomingBounceData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamHomingBounceData* pInstance);
        static void Clean(PlayerParamHomingBounceData* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamHomingAttack {
        heur::rfl::PlayerParamHomingAttackData sonic;
        heur::rfl::PlayerParamHomingAttackData supersonic;
        heur::rfl::PlayerParamHomingBounceData sonicBounce;
        heur::rfl::PlayerParamHomingBounceData sonicBounceWeak;
        heur::rfl::PlayerParamHomingBounceData sonicBounceStorm;
        heur::rfl::PlayerParamHomingBounceData sonicBounceStormSwirl;
        heur::rfl::PlayerParamHomingBounceData supersonicBounce;
        float cameraEaseInTime;
        float cameraEaseOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamHomingAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamHomingAttack* pInstance);
        static void Clean(PlayerParamHomingAttack* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamHitEnemy {
        float bounceVertSpeed;
        float bounceHorzSpeed;
        float attackDownTime;
        float enableHomingTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamHitEnemy* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamHitEnemy* pInstance);
        static void Clean(PlayerParamHitEnemy* pInstance);
    };
}

namespace heur::rfl {
    struct SpeedParam {
        float maxVertSpeed;
        float acceleVertForce;
        float maxHorzSpeed;
        float acceleHorzForce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SpeedParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SpeedParam* pInstance);
        static void Clean(SpeedParam* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDiving {
        heur::rfl::SpeedParam normal;
        heur::rfl::SpeedParam fast;
        heur::rfl::SpeedParam damaged;
        heur::rfl::SpeedParam ringdash;
        float startHeight;
        float startSpeed;
        float deceleVertForce;
        float deceleHorzForce;
        float deceleNeutralForce;
        float damageTime;
        float ringdashTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDiving* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDiving* pInstance);
        static void Clean(PlayerParamDiving* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamFan {
        float damperV;
        float damperH;
        float accelRate;
        float moveForceFV;
        float moveForceSV;
        float jumpCheckSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamFan* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamFan* pInstance);
        static void Clean(PlayerParamFan* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBackflip {
        float jumpSpeed;
        float backSpeed;
        float downAccel;
        float damperV;
        float damperH;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBackflip* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBackflip* pInstance);
        static void Clean(PlayerParamBackflip* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSlowMove {
        float startSpeed;
        float maxSpeed;
        float accel;
        float brake;
        float damageSpeed;
        float damageBrake;
        float steeringSpeed;
        float endSteeringSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSlowMove* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSlowMove* pInstance);
        static void Clean(PlayerParamSlowMove* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpin {
        float startSlopeAngle;
        float endSlopeAngle;
        float startSpeed;
        float endSpeed;
        float stickAngle;
        float brake;
        float forceBrake;
        float maxSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpin* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpin* pInstance);
        static void Clean(PlayerParamSpin* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamWallMove {
        float maxSpeed;
        float walkSpeed;
        float walkSpeedMax;
        float runSpeed;
        float runSpeedMax;
        float walkSpeedOnMesh;
        float walkSpeedOnMeshMax;
        float runSpeedOnMesh;
        float runSpeedOnMeshMax;
        float minAccessSpeed;
        float stickSpeed;
        float gravity;
        float accel;
        float brake;
        float stopBrake;
        float fallSpeed;
        float steeringSpeed1;
        float steeringSpeed2;
        float startSteeringSpeed;
        float endSteeringSpeed;
        float startTime;
        float useEnergySpeedBase;
        float useEnergySpeedBaseOnMesh;
        float useEnergySpeedVal;
        float useEnergySpeedValOnMesh;
        float useEnergyAngle;
        float useEnergyAngleOnMesh;
        float brakeStartEnergy;
        float brakeStartEnergyOnMesh;
        float homingSearchDistanceNear;
        float homingSearchDistanceFar;
        float wallBumpHeightUpper;
        float wallBumpHeightUnder;
        float recoveryCheckTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamWallMove* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamWallMove* pInstance);
        static void Clean(PlayerParamWallMove* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamWallJump {
        float gravitySize;
        float minTime;
        float maxTime;
        float stopTime;
        float maxDownSpeed;
        float fallGroundDistance;
        float frontForce;
        float upForce;
        float impulseTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamWallJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamWallJump* pInstance);
        static void Clean(PlayerParamWallJump* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamClimbing {
        float stepSpeedFront;
        float stepSpeedFrontDash;
        float stepSpeedSide;
        float stepSpeedSideDash;
        float stepSpeedBack;
        float stepDashRate;
        float maxAnimSpeed;
        float exhaustAngle;
        float exhaustAngleOnMesh;
        float exhaustBase;
        float exhaustBaseOnMesh;
        float exhaustRate;
        float exhaustRateOnMesh;
        float useGrabGaugeSpeed;
        float useGrabGaugeSpeedOnMesh;
        float useGrabGaugeTurbo;
        float useGrabGaugeTurboOnMesh;
        float homingSearchDistanceNear;
        float homingSearchDistanceFar;
        float resetAngle;
        float recoveryCheckTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamClimbing* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamClimbing* pInstance);
        static void Clean(PlayerParamClimbing* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSlideDown {
        float time;
        float speed;
        float speedOnMesh;
        float accel;
        float brake;
        float brakeOnMesh;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSlideDown* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSlideDown* pInstance);
        static void Clean(PlayerParamSlideDown* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBoost {
        float consumptionRate;
        float consumptionRateSS;
        float recoveryRate;
        float recoveryRateSS;
        float reigniteRatio;
        float recoveryByRing;
        float recoveryByAttack;
        float blurPowers[3];
        float blurEaseInTime;
        float blurEaseOutTime;
        float endSpeed;
        float powerBoostCoolTime;
        float infinityBoostTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBoost* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBoost* pInstance);
        static void Clean(PlayerParamBoost* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAirBoost {
        float startHSpeed;
        float startHSpeedMax;
        float startVSpeed;
        float minHSpeed;
        float minHSpeedMax;
        float brakeTime;
        float minKeepTime;
        float maxKeepTime;
        float maxTime;
        float gravityRate;
        float steeringSpeed;
        float additionalTransitTime;
        float supersonicTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAirBoost* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAirBoost* pInstance);
        static void Clean(PlayerParamAirBoost* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAutorun {
        float initialSideSpeed;
        float acceleSideForce;
        float deceleSideForce;
        float maxSideSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAutorun* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAutorun* pInstance);
        static void Clean(PlayerParamAutorun* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSideStep {
        float speed;
        float brakeForce;
        float motionSpeedRatio;
        float stepSpeed;
        float maxStepDistance;
        float minStepDistance;
        float maxStepSpeed;
        float minStepSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSideStep* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSideStep* pInstance);
        static void Clean(PlayerParamSideStep* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSideStep2 {
        float speed;
        float brakeForce;
        float motionSpeedRatio;
        float stepSpeed;
        float maxStepDistance;
        float minStepDistance;
        float maxStepSpeed;
        float minStepSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSideStep2* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSideStep2* pInstance);
        static void Clean(PlayerParamSideStep2* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamQuickStep {
        float needSpeed;
        float acceleForce;
        float acceleSideForce;
        float stepInitialSpeed;
        float avoidForce;
        float justBoostForce;
        float justBoostMax;
        float justBoostTime;
        float justBoostBrake;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamQuickStep* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamQuickStep* pInstance);
        static void Clean(PlayerParamQuickStep* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamParry {
        float minRecieveTime;
        float maxRecieveTimes[4];
        float justRecieveTimes[4];
        float frozenTime;
        float justFrozenTime;
        float justEffectEasein;
        float justEffectEaseout;
        float justEffectTime;
        float justEffectEasein2;
        float justEffectEaseout2;
        float justEffectTime2;
        float justEffectEasein3;
        float justEffectEaseout3;
        float justEffectTime3;
        csl::ut::VariableString cameraName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamParry* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamParry* pInstance);
        static void Clean(PlayerParamParry* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAvoidData {
        float speed;
        float damper;
        float parryTime;
        float invincibleTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAvoidData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAvoidData* pInstance);
        static void Clean(PlayerParamAvoidData* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAvoid {
        float time;
        float fixedTime;
        float reentryInputPriorityTime;
        float reentryTime;
        float frontAngle;
        float backAngle;
        float addFallSpeed;
        heur::rfl::PlayerParamAvoidData data[7];
        float baseDistance;
        float limitAngle;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAvoid* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAvoid* pInstance);
        static void Clean(PlayerParamAvoid* pInstance);
    };
}

namespace heur::rfl {
    struct ModePackage {
        heur::rfl::PlayerParamCommon common;
        heur::rfl::PlayerParamSpeed speed;
        heur::rfl::PlayerParamRotation rotation;
        heur::rfl::PlayerParamRunning running;
        heur::rfl::PlayerParamBalance balance;
        heur::rfl::PlayerParamBrake brake;
        heur::rfl::PlayerParamTurn turn;
        heur::rfl::PlayerParamJump jump;
        heur::rfl::PlayerParamJumpSpeed jumpSpeed;
        heur::rfl::PlayerParamDoubleJump doubleJump;
        heur::rfl::PlayerParamFall fall;
        heur::rfl::PlayerParamDamage damage;
        heur::rfl::PlayerParamDead dead;
        heur::rfl::PlayerParamSliding sliding;
        heur::rfl::PlayerParamStomping stomping;
        heur::rfl::PlayerParamGrind grind;
        heur::rfl::PlayerParamFallSlope fallSlope;
        heur::rfl::PlayerParamFallFlip fallFlip;
        heur::rfl::PlayerParamTumble tumble;
        heur::rfl::PlayerParamSpinAttack spinAttack;
        heur::rfl::PlayerParamHomingAttack homingAttack;
        heur::rfl::PlayerParamHitEnemy hitEnemy;
        heur::rfl::PlayerParamDiving diving;
        heur::rfl::PlayerParamFan fan;
        heur::rfl::PlayerParamBackflip backflip;
        heur::rfl::PlayerParamSlowMove slowmove;
        heur::rfl::PlayerParamSpin spin;
        heur::rfl::PlayerParamWallMove wallmove;
        heur::rfl::PlayerParamWallJump walljump;
        heur::rfl::PlayerParamClimbing climbing;
        heur::rfl::PlayerParamSlideDown slidedown;
        heur::rfl::PlayerParamBoost boost;
        heur::rfl::PlayerParamAirBoost airboost;
        heur::rfl::PlayerParamAutorun autorun;
        heur::rfl::PlayerParamSideStep sidestep;
        heur::rfl::PlayerParamSideStep2 sidestep2;
        heur::rfl::PlayerParamQuickStep quickstep;
        heur::rfl::PlayerParamParry parry;
        heur::rfl::PlayerParamAvoid avoid;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ModePackage* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ModePackage* pInstance);
        static void Clean(ModePackage* pInstance);
    };
}

namespace heur::rfl {
    struct ModePackageAmy : heur::rfl::ModePackage {
        heur::rfl::AmyParamPropellerJump propellerJump;
        heur::rfl::AmyParamStomping stomping;
        heur::rfl::AmyParamHighJump highJump;
        heur::rfl::AmyParamTarotAttack tarotAttack;
        heur::rfl::AmyParamCyHammer cyHammer;
        heur::rfl::AmyParamAirCyHammer airCyHammer;
        heur::rfl::AmyParamCyHammerAppearGimmick cyHammerAppearGimmick;
        heur::rfl::AmyParamTarotBoost tarotBoost;
        heur::rfl::AmyParamTarotDrift tarotDrift;
        heur::rfl::AmyParamCharmAttack charmAttack;
        heur::rfl::PlayerParamSpinBoost spinBoost;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ModePackageAmy* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ModePackageAmy* pInstance);
        static void Clean(ModePackageAmy* pInstance);
    };
}

namespace heur::rfl {
    struct WaterModePackage {
        heur::rfl::PlayerParamSpeed speed;
        heur::rfl::PlayerParamJump jump;
        heur::rfl::PlayerParamJumpSpeed jumpSpeed;
        heur::rfl::PlayerParamDoubleJump doubleJump;
        heur::rfl::PlayerParamBoost boost;
        heur::rfl::PlayerParamAirBoost airboost;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WaterModePackage* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WaterModePackage* pInstance);
        static void Clean(WaterModePackage* pInstance);
    };
}

namespace heur::rfl {
    struct AmyParameters {
        heur::rfl::CommonPackageAmy common;
        heur::rfl::ModePackageAmy forwardView;
        heur::rfl::WaterModePackage water;
        heur::rfl::ModePackageAmy cyberspaceSV;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmyParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmyParameters* pInstance);
        static void Clean(AmyParameters* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamComboPunch1 {
        heur::rfl::PlayerParamAttackCollider hit;
        float motionScale;
        float motionSpeedRate;
        int32_t fallSpeedBaseCount;
        float fallSpeedStep;
        float fallSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamComboPunch1* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamComboPunch1* pInstance);
        static void Clean(KnucklesParamComboPunch1* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamComboPunch2 {
        heur::rfl::PlayerParamAttackCollider hit;
        float motionScale;
        float motionSpeedRate;
        int32_t fallSpeedBaseCount;
        float fallSpeedStep;
        float fallSpeedMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamComboPunch2* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamComboPunch2* pInstance);
        static void Clean(KnucklesParamComboPunch2* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamComboUppercut {
        heur::rfl::PlayerParamAttackCollider hit;
        float motionScale;
        float motionSpeedRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamComboUppercut* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamComboUppercut* pInstance);
        static void Clean(KnucklesParamComboUppercut* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamParryDebuff {
        float damageRate;
        float effectTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamParryDebuff* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamParryDebuff* pInstance);
        static void Clean(KnucklesParamParryDebuff* pInstance);
    };
}

namespace heur::rfl {
    struct CommonPackageKnuckles : heur::rfl::CommonPackage {
        heur::rfl::PlayerParamCombo combo;
        heur::rfl::KnucklesParamComboPunch1 comboPunch1;
        heur::rfl::KnucklesParamComboPunch2 comboPunch2;
        heur::rfl::KnucklesParamComboUppercut comboUppercut;
        heur::rfl::KnucklesParamParryDebuff parryDebuff;
        heur::rfl::PlayerParamCyloop cyloop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CommonPackageKnuckles* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CommonPackageKnuckles* pInstance);
        static void Clean(CommonPackageKnuckles* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAcceleCombo {
        heur::rfl::PlayerParamAttackCollider hit;
        float motionSpeedRatio;
        float motionSpeedRatioAccele;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAcceleCombo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAcceleCombo* pInstance);
        static void Clean(PlayerParamAcceleCombo* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAcceleComboSet {
        heur::rfl::PlayerParamAcceleCombo sonic;
        heur::rfl::PlayerParamAcceleCombo superSonic1;
        heur::rfl::PlayerParamAcceleCombo superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAcceleComboSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAcceleComboSet* pInstance);
        static void Clean(PlayerParamAcceleComboSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamLoopKick {
        float loopRadius;
        float loopTime;
        float loopSpeedCurveRatio;
        float loopEndStopTime;
        float loopEndSpeed;
        float kickSpeed;
        float failSafeTime;
        csl::math::Vector3 offset;
        csl::ut::VariableString cameraName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamLoopKick* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamLoopKick* pInstance);
        static void Clean(PlayerParamLoopKick* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamLoopKickSet {
        heur::rfl::PlayerParamLoopKick sonic;
        heur::rfl::PlayerParamLoopKick superSonic1;
        heur::rfl::PlayerParamLoopKick superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamLoopKickSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamLoopKickSet* pInstance);
        static void Clean(PlayerParamLoopKickSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCrasher {
        float startWait;
        float distanceRatios[5];
        float angles[5];
        float radii[5];
        float distanceMax;
        float zigzagBeginOneStepTime;
        float zigzagEndOneStepTime;
        float crasherSpeed;
        float failSafeTime;
        float cameraDistance;
        float cameraOffsetElevation;
        float cameraOffsetAzimuth;
        float cameraRoll;
        csl::math::Vector3 offset;
        csl::ut::VariableString cameraName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCrasher* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCrasher* pInstance);
        static void Clean(PlayerParamCrasher* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCrasherSet {
        heur::rfl::PlayerParamCrasher sonic;
        heur::rfl::PlayerParamCrasher superSonic1;
        heur::rfl::PlayerParamCrasher superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCrasherSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCrasherSet* pInstance);
        static void Clean(PlayerParamCrasherSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpinSlash {
        heur::rfl::PlayerParamAttackCollider hit;
        heur::rfl::PlayerParamAttackCollider hitLast;
        float chargeTime;
        float homingSpeed;
        float bounceTime;
        float radius;
        float slashTime;
        int8_t numSlashs;
        float angle;
        float lastHitTime;
        float slowRatio0;
        float slowRatio1;
        csl::math::Vector3 offset;
        csl::ut::VariableString cameraName;
        csl::ut::VariableString cameraNamePost;
        csl::ut::VariableString cameraShakeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpinSlash* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpinSlash* pInstance);
        static void Clean(PlayerParamSpinSlash* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpinSlashSet {
        heur::rfl::PlayerParamSpinSlash sonic;
        heur::rfl::PlayerParamSpinSlash superSonic1;
        heur::rfl::PlayerParamSpinSlash superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpinSlashSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpinSlashSet* pInstance);
        static void Clean(PlayerParamSpinSlashSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamChargeAttack {
        heur::rfl::PlayerParamAttackCollider hit;
        heur::rfl::PlayerParamAttackCollider hitLast;
        float ignoreSwingingTime;
        float riseSlowRatio;
        float riseTime;
        float riseDistance;
        float preRiseDistance;
        float postRiseDistance;
        float lastVelocity;
        float spiralRadius;
        float spiralRadiusEaseInTime;
        float spiralRadiusEaseOutTime;
        float spiralAngularSpeed;
        float lastHitTime;
        csl::ut::VariableString cameraName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamChargeAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamChargeAttack* pInstance);
        static void Clean(PlayerParamChargeAttack* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamChargeAttackSet {
        heur::rfl::PlayerParamChargeAttack sonic;
        heur::rfl::PlayerParamChargeAttack superSonic1;
        heur::rfl::PlayerParamChargeAttack superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamChargeAttackSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamChargeAttackSet* pInstance);
        static void Clean(PlayerParamChargeAttackSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamStompingAttack {
        heur::rfl::PlayerParamAttackCollider hit;
        heur::rfl::PlayerParamAttackCollider hitLast;
        float riseTime;
        float flipSpeed;
        float motionTime;
        float lastHitTime;
        float slowRatio;
        float minPressTime;
        float minPressTimeHeight;
        float maxPressTime;
        float maxPressTimeHeight;
        csl::math::Vector3 offset;
        csl::math::Vector3 offsetAsura;
        csl::ut::VariableString cameraName;
        csl::ut::VariableString cameraNameBarrage;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamStompingAttack* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamStompingAttack* pInstance);
        static void Clean(PlayerParamStompingAttack* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamStompingAttackSet {
        heur::rfl::PlayerParamStompingAttack sonic;
        heur::rfl::PlayerParamStompingAttack superSonic1;
        heur::rfl::PlayerParamStompingAttack superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamStompingAttackSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamStompingAttackSet* pInstance);
        static void Clean(PlayerParamStompingAttackSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamComboFinish {
        heur::rfl::PlayerParamAttackCollider hit;
        float ignoreSwingingTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamComboFinish* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamComboFinish* pInstance);
        static void Clean(PlayerParamComboFinish* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamComboFinishSet {
        heur::rfl::PlayerParamComboFinish sonic;
        heur::rfl::PlayerParamComboFinish superSonic1;
        heur::rfl::PlayerParamComboFinish superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamComboFinishSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamComboFinishSet* pInstance);
        static void Clean(PlayerParamComboFinishSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSonicBoom {
        float waitTime;
        float spanTime;
        float fallSpeed;
        float autoContinueTime;
        float speed;
        float maxSpeed;
        float accele;
        float slowRatio;
        csl::math::Vector3 offset;
        csl::ut::VariableString cameraName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSonicBoom* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSonicBoom* pInstance);
        static void Clean(PlayerParamSonicBoom* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSonicBoomSet {
        heur::rfl::PlayerParamSonicBoom sonic;
        heur::rfl::PlayerParamSonicBoom superSonic1;
        heur::rfl::PlayerParamSonicBoom superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSonicBoomSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSonicBoomSet* pInstance);
        static void Clean(PlayerParamSonicBoomSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCrossSlash {
        float spanTime;
        float attackTime;
        float moveAngle;
        float stopTime;
        float slowRatio;
        float spinPhase;
        float spinRadius;
        float spinSpeed;
        float spawnDelayTime[2];
        csl::math::Vector3 spawnLocalTranslation[2];
        csl::math::Vector3 spawnLocalAngle[2];
        float speed;
        float maxSpeed;
        float accele;
        csl::math::Vector3 offset;
        csl::ut::VariableString cameraName;
        csl::ut::VariableString launchCameraShakeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCrossSlash* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCrossSlash* pInstance);
        static void Clean(PlayerParamCrossSlash* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCrossSlashSet {
        heur::rfl::PlayerParamCrossSlash sonic;
        heur::rfl::PlayerParamCrossSlash superSonic1;
        heur::rfl::PlayerParamCrossSlash superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCrossSlashSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCrossSlashSet* pInstance);
        static void Clean(PlayerParamCrossSlashSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamHomingShot {
        float appearTime;
        float appearPhaseTime;
        float spinRadius;
        float spinSpeed;
        float spinSpeedPostLaunch;
        float chargeTime;
        float spawnTime;
        float launchPreWaitTime;
        float spanTime;
        bool launchRandomize;
        float launchWaitTime;
        float beginAngleX;
        float tangent0;
        float tangent1;
        float spiralWaitTime;
        float spiralAngularSpeed;
        float spiralAngularSpeedMax;
        float spiralAngularSpeedAccele;
        uint8_t numShots;
        float speed;
        float maxSpeed;
        float accele;
        float whiteoutBeginTime;
        float whiteoutFadeOutTime;
        float whiteoutFadingTime;
        float whiteoutFadeInTime;
        csl::math::Vector3 offset;
        csl::ut::VariableString cameraName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamHomingShot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamHomingShot* pInstance);
        static void Clean(PlayerParamHomingShot* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamHomingShotSet {
        heur::rfl::PlayerParamHomingShot sonic;
        heur::rfl::PlayerParamHomingShot superSonic1;
        heur::rfl::PlayerParamHomingShot superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamHomingShotSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamHomingShotSet* pInstance);
        static void Clean(PlayerParamHomingShotSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSmash {
        heur::rfl::PlayerParamAttackCollider hit1;
        heur::rfl::PlayerParamAttackCollider hit2;
        csl::math::Vector3 offsets[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSmash* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSmash* pInstance);
        static void Clean(PlayerParamSmash* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSmashSet {
        heur::rfl::PlayerParamSmash sonic;
        heur::rfl::PlayerParamSmash superSonic1;
        heur::rfl::PlayerParamSmash superSonic2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSmashSet* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSmashSet* pInstance);
        static void Clean(PlayerParamSmashSet* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBehind {
        float moveTime;
        float moveTimeSS;
        float tangentScale;
        float waitTime;
        float cameraTurnRatio;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBehind* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBehind* pInstance);
        static void Clean(PlayerParamBehind* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSuperSonicShapeAttackData {
        enum class Part : int8_t {
            PunchR = 0,
            PunchL = 1,
            KickR = 2,
            KickL = 3,
        };

        csl::ut::VariableString name;
        Part part;
        csl::math::Vector3 begin;
        csl::math::Vector3 end;
        float scale;
        float roll;
        float moveTime;
        float fadeoutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSuperSonicShapeAttackData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSuperSonicShapeAttackData* pInstance);
        static void Clean(PlayerParamSuperSonicShapeAttackData* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSuperSonic {
        int32_t numRings;
        float decreaseSec;
        float inletRadius;
        float moveSoundSpeed;
        csl::ut::Colorf auraColor2;
        heur::rfl::PlayerParamSuperSonicShapeAttackData shapeEffects[32];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSuperSonic* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSuperSonic* pInstance);
        static void Clean(PlayerParamSuperSonic* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSandSki {
        float blowDeceleForce;
        float blowDeceleForceOnGround;
        float blowGravityScale;
        float blowTransitTime;
        float blowDownTime;
        float pylonBlowUpSize;
        float pylonBlowSpeed;
        csl::ut::VariableString pylonHitStop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSandSki* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSandSki* pInstance);
        static void Clean(PlayerParamSandSki* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSlingshot {
        enum class CameraShakeTiming : int8_t {
            StartCameraInterpolation = 0,
            EndCameraInterpolation = 1,
        };

        float timeScaleInMove;
        float hitStartRestTime;
        csl::math::Vector3 hitCameraOffset;
        float hitCameraTimeEaseIn;
        float hitCameraFovyAngle;
        float hitTimeScaleValue;
        float hitTimeScaleTimeEaseIn;
        float resetCameraEaseOutTime;
        float resetTimeScaleEaseOutTime;
        float timeScaleKeepTime;
        float shotEffOffset;
        float hitEffOffset;
        CameraShakeTiming cameraShakeTiming;
        csl::ut::VariableString cameraShakeName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSlingshot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSlingshot* pInstance);
        static void Clean(PlayerParamSlingshot* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamRunawayBee {
        float meanderCycle;
        float meanderAngle;
        float minSpeed;
        float maxSpeed;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamRunawayBee* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamRunawayBee* pInstance);
        static void Clean(PlayerParamRunawayBee* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamRunWithKodamaParam {
        int32_t numKodamas;
        float initialSpeed;
        float minSpeed;
        float maxSpeed;
        float jumpForce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamRunWithKodamaParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamRunWithKodamaParam* pInstance);
        static void Clean(PlayerParamRunWithKodamaParam* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamRunWithKodama {
        int32_t maxKodamas;
        float gravitySize;
        heur::rfl::PlayerParamRunWithKodamaParam params[8];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamRunWithKodama* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamRunWithKodama* pInstance);
        static void Clean(PlayerParamRunWithKodama* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamMine {
        float radiusLow;
        float radiusMedium;
        float radiusHigh;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamMine* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamMine* pInstance);
        static void Clean(PlayerParamMine* pInstance);
    };
}

namespace heur::rfl {
    struct CommonPackageSonic : heur::rfl::CommonPackage {
        heur::rfl::PlayerParamAcceleComboSet acceleComboSet;
        heur::rfl::PlayerParamLoopKickSet loopKickSet;
        heur::rfl::PlayerParamCrasherSet crasherSet;
        heur::rfl::PlayerParamSpinSlashSet spinSlashSet;
        heur::rfl::PlayerParamChargeAttackSet chargeAtackSet;
        heur::rfl::PlayerParamStompingAttackSet stompingAttackSet;
        heur::rfl::PlayerParamComboFinishSet comboFinishSet;
        heur::rfl::PlayerParamSonicBoomSet sonicboomSet;
        heur::rfl::PlayerParamCrossSlashSet crossSlashSet;
        heur::rfl::PlayerParamHomingShotSet homingShotSet;
        heur::rfl::PlayerParamSmashSet smashSet;
        heur::rfl::PlayerParamBehind behind;
        heur::rfl::PlayerParamCombo combo;
        heur::rfl::PlayerParamCyloop cyloop;
        heur::rfl::PlayerParamSuperSonic supersonic;
        heur::rfl::PlayerParamSandSki sandski;
        heur::rfl::PlayerParamSlingshot slingshot;
        heur::rfl::PlayerParamRunawayBee runawayBee;
        heur::rfl::PlayerParamRunWithKodama runWithKodama;
        heur::rfl::PlayerParamMine mine;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CommonPackageSonic* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CommonPackageSonic* pInstance);
        static void Clean(CommonPackageSonic* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamParryDebuff {
        float damageRate;
        float effectTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamParryDebuff* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamParryDebuff* pInstance);
        static void Clean(TailsParamParryDebuff* pInstance);
    };
}

namespace heur::rfl {
    struct CommonPackageTails : heur::rfl::CommonPackage {
        heur::rfl::PlayerParamCombo combo;
        heur::rfl::TailsParamParryDebuff parryDebuff;
        heur::rfl::PlayerParamCyloop cyloop;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CommonPackageTails* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CommonPackageTails* pInstance);
        static void Clean(CommonPackageTails* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamCyKnuckle {
        float findRadius;
        uint32_t numNotifies;
        float effectTime;
        float effectTimeWall;
        float rotateCycleTime;
        float activeRadius;
        float findDistanceStomp;
        float findRadiusStomp;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamCyKnuckle* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamCyKnuckle* pInstance);
        static void Clean(KnucklesParamCyKnuckle* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamCyKnuckleAppearGimmick {
        float appearWaitTime;
        heur::rfl::CyloopDropItemParameter dropItem;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamCyKnuckleAppearGimmick* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamCyKnuckleAppearGimmick* pInstance);
        static void Clean(KnucklesParamCyKnuckleAppearGimmick* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamCyKnuckleDig {
        float diveScale;
        float speed;
        float stompingAttackScale;
        bool alsoStomping;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamCyKnuckleDig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamCyKnuckleDig* pInstance);
        static void Clean(KnucklesParamCyKnuckleDig* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamCyKnucklePopupItem {
        float appearWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamCyKnucklePopupItem* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamCyKnucklePopupItem* pInstance);
        static void Clean(KnucklesParamCyKnucklePopupItem* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamCyKnuckleWarp {
        float appearWaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamCyKnuckleWarp* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamCyKnuckleWarp* pInstance);
        static void Clean(KnucklesParamCyKnuckleWarp* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamDrillBoost {
        float prepareTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamDrillBoost* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamDrillBoost* pInstance);
        static void Clean(KnucklesParamDrillBoost* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamGlidingCamera {
        float azimuthSensitivity;
        float elevationOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamGlidingCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamGlidingCamera* pInstance);
        static void Clean(KnucklesParamGlidingCamera* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamGliding {
        float minSpeed;
        float minSpeedRingMax;
        float moveWaitTime;
        float minActionTime;
        float fallSpeed;
        float fallAccel;
        float maxSteerSpeed;
        float rollSpeed;
        float neutralRollSpeed;
        float rollSpeedRingMax;
        float neutralRollSpeedRingMax;
        float yawSpeed;
        float yawSpeedRingMax;
        float maxRollAngle;
        float rollAngleRatioMin;
        float rollAngleRatioMax;
        float rollAngleRatioMinRingMax;
        float rollAngleRatioMaxRingMax;
        float height;
        float startHeight;
        heur::rfl::KnucklesParamGlidingCamera camera;
        float practiceTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamGliding* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamGliding* pInstance);
        static void Clean(KnucklesParamGliding* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParamMaximumHeatKnuckle {
        float lockonLevelUpSpanTime[4];
        float damageTime[4];
        float speed;
        float chargeTime;
        float chargeTime2;
        float preDamageTime;
        float postDamageTime;
        float slowRate;
        heur::rfl::PlayerParamAttackCollider hit;
        heur::rfl::PlayerParamAttackCollider hit2;
        csl::math::Vector3 hitVisualOffset;
        csl::math::Vector3 hitEffectOffset;
        float followSpeed;
        float followTime;
        csl::ut::VariableString cameraNameMove;
        csl::ut::VariableString cameraNameHit;
        bool startMoveCameraFromCharge;
        float enabledCameraHeight;
        csl::ut::VariableString cameraShakeName;
        csl::ut::VariableString vibrationName;
        float shakeEndTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParamMaximumHeatKnuckle* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParamMaximumHeatKnuckle* pInstance);
        static void Clean(KnucklesParamMaximumHeatKnuckle* pInstance);
    };
}

namespace heur::rfl {
    struct ModePackageKnuckles : heur::rfl::ModePackage {
        heur::rfl::KnucklesParamGliding gliding;
        heur::rfl::KnucklesParamCyKnuckle cyknuckle;
        heur::rfl::KnucklesParamCyKnuckleDig cyknuckleDig;
        heur::rfl::KnucklesParamCyKnuckleWarp cyknuckleWarp;
        heur::rfl::KnucklesParamCyKnucklePopupItem cyknucklePopupItem;
        heur::rfl::KnucklesParamCyKnuckleAppearGimmick cyknuckleAppearGimmick;
        heur::rfl::KnucklesParamMaximumHeatKnuckle maximumHeatKnuckle;
        heur::rfl::KnucklesParamDrillBoost drillBoost;
        heur::rfl::PlayerParamSpinBoost spinBoost;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ModePackageKnuckles* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ModePackageKnuckles* pInstance);
        static void Clean(ModePackageKnuckles* pInstance);
    };
}

namespace heur::rfl {
    struct KnucklesParameters {
        heur::rfl::CommonPackageKnuckles common;
        heur::rfl::ModePackageKnuckles forwardView;
        heur::rfl::WaterModePackage water;
        heur::rfl::ModePackageKnuckles cyberspaceSV;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(KnucklesParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(KnucklesParameters* pInstance);
        static void Clean(KnucklesParameters* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamStorm {
        float damperV;
        float damperH;
        float brake;
        float accelRate;
        float moveForce;
        float maxSpeedH;
        float maxSpeedV;
        float rotateSpeed;
        float rotateAngularSpeed;
        float minDrawSpeed;
        float maxDrawSpeed;
        float minDrawSpeedDistance;
        float maxDrawSpeedDistance;
        float damageTime;
        float damageNoBrakeTime;
        float forceHomingReaction;
        float forceHomingReaction2;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamStorm* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamStorm* pInstance);
        static void Clean(PlayerParamStorm* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCloudJump {
        float acceleForce;
        float deceleForce;
        float overSpeedDeceleForce;
        float rotationForce;
        float rotationForceDecaySpeed;
        float rotationForceDecayRate;
        float rotationForceDecayMax;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCloudJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCloudJump* pInstance);
        static void Clean(PlayerParamCloudJump* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAquaBall {
        float fallAccel;
        float damper;
        float jumpSpeed;
        float stompingSpeed;
        float boundSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAquaBall* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAquaBall* pInstance);
        static void Clean(PlayerParamAquaBall* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSlider {
        float frontAccel;
        float frontBrake;
        float sideBrake;
        float damageBrake;
        float defaultRotateSpeed;
        float rotateSpeed;
        float rotateSpeedAir;
        float gravity;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSlider* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSlider* pInstance);
        static void Clean(PlayerParamSlider* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAirTrick {
        uint32_t amount;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAirTrick* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAirTrick* pInstance);
        static void Clean(PlayerParamAirTrick* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDrift {
        float startAngle;
        float endSpeed;
        float minSpeed;
        float minSpeedMax;
        float maxSpeed;
        float maxSpeedMax;
        float minBoostSpeed;
        float minBoostSpeedMax;
        float maxBoostSpeed;
        float maxBoostSpeedMax;
        float accel;
        float brake;
        float maxSteerAngle;
        float steerAccel;
        float maxSteerSpeed;
        float neutralSteerAccel;
        float maxNeutralSteerSpeed;
        float maxRotateSpeed;
        float recoverTime;
        float maxChargeTime;
        float minDashSpeed;
        float maxDashSpeed;
        float minDashJumpSpeed;
        float maxDashJumpSpeed;
        float jumpSpeed;
        float checkFallTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDrift* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDrift* pInstance);
        static void Clean(PlayerParamDrift* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDriftAir {
        float startAngle;
        float endSpeed;
        float minSpeed;
        float maxSpeed;
        float accel;
        float brake;
        float maxSteerAngle;
        float steerAccel;
        float maxSteerSpeed;
        float neutralSteerAccel;
        float maxNeutralSteerSpeed;
        float maxRotateSpeed;
        float recoverTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDriftAir* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDriftAir* pInstance);
        static void Clean(PlayerParamDriftAir* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDriftDash {
        float maxSpeed;
        float brake;
        float steeringSpeed1;
        float steeringSpeed2;
        float startSteeringSpeed;
        float endSteeringSpeed;
        float outOfControlSpeed;
        float checkDashSpeed;
        float checkDashTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDriftDash* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDriftDash* pInstance);
        static void Clean(PlayerParamDriftDash* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBoarding {
        float maxSpeed;
        float minSpeed;
        float damageSpeed;
        float accel;
        float damageBrake;
        float damageBrakeTime;
        float damageMotionTime;
        float damageInvicibleTime;
        float damper;
        float airDamperV;
        float airDamperH;
        float gravity;
        float airJumpSpeed;
        float groundJumpSpeed;
        float airAccel;
        float maxAirAddSpeed;
        float downForceRate;
        float steeringSpeed1;
        float steeringSpeed2;
        float steeringSpeed3;
        float startSteeringSpeed;
        float endSteeringSpeed;
        float startSpeed;
        float startSlope;
        float staticStartSlope;
        float finishSlope;
        float finishTime;
        float bigLandTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBoarding* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBoarding* pInstance);
        static void Clean(PlayerParamBoarding* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamDropDash {
        float maxChargeTime;
        float minDashSpeed;
        float minDashSpeedMax;
        float maxDashSpeed;
        float maxDashSpeedMax;
        float tumbleDashSpeed;
        float maxSpeed;
        float brake;
        float steeringSpeed1;
        float steeringSpeed2;
        float startSteeringSpeed;
        float endSteeringSpeed;
        float outOfControlSpeed;
        float checkDashSpeed;
        float checkDashTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamDropDash* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamDropDash* pInstance);
        static void Clean(PlayerParamDropDash* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBounceJump {
        float startSpeed;
        float jumpRate1;
        float jumpRate2;
        float jumpRate3;
        float inoperableTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBounceJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBounceJump* pInstance);
        static void Clean(PlayerParamBounceJump* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamLightDash {
        float dashSpeed;
        float dashSpeedMax;
        float speed;
        float speedMax;
        float accel;
        float brake;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamLightDash* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamLightDash* pInstance);
        static void Clean(PlayerParamLightDash* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamSpinDash {
        float time;
        float minSpeed;
        float deceleForce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamSpinDash* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamSpinDash* pInstance);
        static void Clean(PlayerParamSpinDash* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamFly {
        float maxSpeed;
        float maxDashSpeed;
        float accel;
        float dashAccel;
        float brake;
        float minRotateSpeed;
        float maxRotateSpeed;
        float blowOffTime;
        float blowOffAngle;
        float turnBrake;
        float turnRotateSpeed;
        float quickTurnThresholdAngle;
        float quickTurnStartSpeed;
        float quickTurnBrake;
        float quickTurnRotateSpeed;
        float comboTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamFly* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamFly* pInstance);
        static void Clean(PlayerParamFly* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamLimitedFly {
        float maxSpeed1D;
        float accel1D;
        float brake1D;
        float fixAccel1D;
        float fixSpeed1D;
        float fixAccelQuick;
        float fixSpeedQuick;
        float rotateSpeed1D;
        float maxSpeed2D;
        float accel2D;
        float brake2D;
        float fixSpeed2D;
        float rotateSpeed2D;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamLimitedFly* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamLimitedFly* pInstance);
        static void Clean(PlayerParamLimitedFly* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerCyberModeSpeedParam {
        float initial;
        float min;
        float max;
        float minTurn;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerCyberModeSpeedParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerCyberModeSpeedParam* pInstance);
        static void Clean(PlayerCyberModeSpeedParam* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerMaxSpeedChallengeLevelParam {
        heur::rfl::PlayerCyberModeSpeedParam speed;
        heur::rfl::PlayerCyberModeSpeedParam speedPowerBoost;
        float recoveryRate;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerMaxSpeedChallengeLevelParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerMaxSpeedChallengeLevelParam* pInstance);
        static void Clean(PlayerMaxSpeedChallengeLevelParam* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamCyberMode {
        float lowGravityScale;
        float timeScale;
        float accelForce;
        float jerk;
        float minSpeedThreshold;
        float maxSpeedThreshold;
        float recoveryRate;
        float maxSpeed;
        float maxSpeedInBoost;
        uint32_t numLevels;
        heur::rfl::PlayerMaxSpeedChallengeLevelParam levels[8];
        float animalMinSpeed;
        float animalMaxSpeed;
        float animalInitialSpeed;
        float animalMinTurnSpeed;
        float animalJumpForce;
        float animalGravitySize;
        float nitroConsumptionRate;
        float nitroAirDragPowerMin;
        float nitroAirDragPowerMax;
        csl::ut::VariableString nitroHitStopName;
        csl::ut::VariableString nitroHitStopNameAir;
        csl::ut::VariableString nitroCameraShakeName;
        csl::ut::VariableString nitroCameraShakeNameAir;
        csl::ut::VariableString nitroVibrationName;
        csl::ut::VariableString nitroVibrationNameAir;
        float nitroRunEffectDelay;
        csl::ut::VariableString nitroCameraShakeNameInRun;
        csl::ut::VariableString nitroVibrationNameInRun;
        heur::rfl::PlayerCyberModeSpeedParam nitroSpeed;
        heur::rfl::PlayerCyberModeSpeedParam nitroSpeedLvMax;
        heur::rfl::PlayerCyberModeSpeedParam nitroSpeedPowerBoost;
        heur::rfl::PlayerCyberModeSpeedParam nitroSpeedLvMaxPowerBoost;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamCyberMode* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamCyberMode* pInstance);
        static void Clean(PlayerParamCyberMode* pInstance);
    };
}

namespace heur::rfl {
    struct ModePackageSonic : heur::rfl::ModePackage {
        heur::rfl::PlayerParamStorm storm;
        heur::rfl::PlayerParamCloudJump cloudJump;
        heur::rfl::PlayerParamAquaBall aquaball;
        heur::rfl::PlayerParamSlider slider;
        heur::rfl::PlayerParamAirTrick airtrick;
        heur::rfl::PlayerParamDrift drift;
        heur::rfl::PlayerParamDriftAir driftair;
        heur::rfl::PlayerParamDriftDash driftDash;
        heur::rfl::PlayerParamBoarding boarding;
        heur::rfl::PlayerParamDropDash dropDash;
        heur::rfl::PlayerParamBounceJump bounceJump;
        heur::rfl::PlayerParamLightDash lightDash;
        heur::rfl::PlayerParamSpinDash spindash;
        heur::rfl::PlayerParamSpinBoost spinBoost;
        heur::rfl::PlayerParamFly fly;
        heur::rfl::PlayerParamLimitedFly limitedfly;
        heur::rfl::PlayerParamCyberMode cyberMode;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ModePackageSonic* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ModePackageSonic* pInstance);
        static void Clean(ModePackageSonic* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamFlyStart {
        float decY;
        float duration;
        float moveMaxSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamFlyStart* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamFlyStart* pInstance);
        static void Clean(TailsParamFlyStart* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamFlyRise {
        float speedYStart;
        float speedYMax;
        float accY;
        float height;
        int32_t riseNum;
        float heightRatio[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamFlyRise* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamFlyRise* pInstance);
        static void Clean(TailsParamFlyRise* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamFlyCruise {
        float decY;
        float duration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamFlyCruise* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamFlyCruise* pInstance);
        static void Clean(TailsParamFlyCruise* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamFlyDescend {
        float speedYMax;
        float accY;
        float moveMaxSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamFlyDescend* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamFlyDescend* pInstance);
        static void Clean(TailsParamFlyDescend* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamFlyCamera {
        float azimuthSensitivity;
        float elevationOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamFlyCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamFlyCamera* pInstance);
        static void Clean(TailsParamFlyCamera* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamFly {
        heur::rfl::TailsParamFlyStart start;
        heur::rfl::TailsParamFlyRise rise;
        heur::rfl::TailsParamFlyCruise cruise;
        heur::rfl::TailsParamFlyDescend descend;
        float maxSpeed;
        float acc;
        float dec;
        float maxSteerSpeed;
        float rollSpeed;
        float neutralRollSpeed;
        float yawSpeed;
        float maxRollAngle;
        float height;
        float heightLimit;
        heur::rfl::TailsParamFlyCamera camera;
        float practiceTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamFly* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamFly* pInstance);
        static void Clean(TailsParamFly* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamSpannerShot {
        float archSpeed;
        float archHomingMinSpeed;
        float archHomingMaxSpeed;
        float archHomingMinSpeedDistance;
        float archHomingMaxSpeedDistance;
        float archRange;
        float archHeight;
        float archHomingMinHeight;
        float archHomingMaxHeight;
        float archHomingMinHeightDistance;
        float archHomingMaxHeightDistance;
        float archModelScale;
        float archColliderRadius;
        float archSpinSpeed;
        float floatSpeed;
        float floatSpeedMinHoming;
        float floatRange;
        float floatAirYOffset;
        float floatDuration;
        float floatDamageInterval;
        float floatModelScale;
        float floatColliderRadius;
        float floatSpinSpeed;
        float floatOrbitRadius;
        float floatOrbitSpeed;
        float floatOrbitSpinSpeed;
        float addMoveSpeedRatio;
        float modelExtendDuration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamSpannerShot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamSpannerShot* pInstance);
        static void Clean(TailsParamSpannerShot* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamSpannerCombo {
        float initialTime;
        float continueTime;
        float fallSpeed;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamSpannerCombo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamSpannerCombo* pInstance);
        static void Clean(TailsParamSpannerCombo* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamSpanner {
        heur::rfl::TailsParamSpannerShot shot;
        heur::rfl::TailsParamSpannerCombo combo;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamSpanner* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamSpanner* pInstance);
        static void Clean(TailsParamSpanner* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamCyBlasterShot {
        float speed;
        float range;
        float colliderRadius;
        float colliderHeight;
        float splineHeight;
        float lifetime;
        float readyDuration;
        float readyRotateSpeed;
        float readyFallSpeed;
        float addMoveSpeedRatio;
        bool explodeOnMoveFinish;
        float cyLineRadius;
        float cyLineRotateCycleTime;
        float cyLineLifeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamCyBlasterShot* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamCyBlasterShot* pInstance);
        static void Clean(TailsParamCyBlasterShot* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamCyBlasterLiftRun {
        float initial;
        float min;
        float max;
        float minTurn;
        float acceleForce;
        float rotateForce;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamCyBlasterLiftRun* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamCyBlasterLiftRun* pInstance);
        static void Clean(TailsParamCyBlasterLiftRun* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamCyBlasterLiftAir {
        float jumpForce;
        float gravitySize;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamCyBlasterLiftAir* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamCyBlasterLiftAir* pInstance);
        static void Clean(TailsParamCyBlasterLiftAir* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamCyBlasterLift {
        heur::rfl::TailsParamCyBlasterLiftRun run;
        heur::rfl::TailsParamCyBlasterLiftAir air;
        float liftUpTime;
        csl::math::Vector3 liftOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamCyBlasterLift* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamCyBlasterLift* pInstance);
        static void Clean(TailsParamCyBlasterLift* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamCyBlaster {
        heur::rfl::TailsParamCyBlasterShot shot;
        heur::rfl::TailsParamCyBlasterLift lift;
        heur::rfl::CyloopDropItemParameter dropItem;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamCyBlaster* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamCyBlaster* pInstance);
        static void Clean(TailsParamCyBlaster* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamStomping {
        float landAttackScale;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamStomping* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamStomping* pInstance);
        static void Clean(TailsParamStomping* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamCycloneBoostCamera {
        float azimuthSensitivity;
        float elevationOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamCycloneBoostCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamCycloneBoostCamera* pInstance);
        static void Clean(TailsParamCycloneBoostCamera* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamCycloneBoost {
        float startHSpeed;
        float yawSpeedMax;
        float yawAcc;
        float neutralYawDec;
        float attackScale;
        heur::rfl::TailsParamCycloneBoostCamera camera;
        float practiceTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamCycloneBoost* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamCycloneBoost* pInstance);
        static void Clean(TailsParamCycloneBoost* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamAirBoostCycloneCamera {
        float azimuthSensitivity;
        float elevationOffset;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamAirBoostCycloneCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamAirBoostCycloneCamera* pInstance);
        static void Clean(TailsParamAirBoostCycloneCamera* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamAirBoostCycloneTakeOff {
        float vSpeedStart;
        float heightMin;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamAirBoostCycloneTakeOff* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamAirBoostCycloneTakeOff* pInstance);
        static void Clean(TailsParamAirBoostCycloneTakeOff* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamAirBoostCyclone {
        float startHSpeed;
        float vSpeedMax;
        float vSpeedAcc;
        float vSpeedDec;
        float heightMax;
        float yawSpeedMax;
        float rollSpeed;
        float neutralRollSpeed;
        float maxRollAngle;
        float maxPitchAngle;
        float maxPitchVSpeed;
        float barrelRollDuration;
        float additionalTransitTime;
        float attackScale;
        heur::rfl::TailsParamAirBoostCycloneCamera camera;
        heur::rfl::TailsParamAirBoostCycloneTakeOff takeOff;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamAirBoostCyclone* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamAirBoostCyclone* pInstance);
        static void Clean(TailsParamAirBoostCyclone* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamStepCyclone {
        float stepSpeed;
        float stepDistance;
        float barrelRollDuration;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamStepCyclone* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamStepCyclone* pInstance);
        static void Clean(TailsParamStepCyclone* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamWaveCannonCamera {
        csl::math::Vector3 frameOffset;
        float elevation;
        float distance;
        float fovy;
        float interpolateBegin;
        float interpolateEnd;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamWaveCannonCamera* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamWaveCannonCamera* pInstance);
        static void Clean(TailsParamWaveCannonCamera* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParamWaveCannon {
        float chargeDuration;
        float chargeTurnSpeed;
        float shotDuration;
        float shotTurnSpeed;
        float turnLimit;
        float colliderLengthMax;
        float colliderRadius;
        float colliderExtendSpeed;
        float damageInterval;
        float hitEffectInterval;
        heur::rfl::TailsParamWaveCannonCamera camera;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParamWaveCannon* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParamWaveCannon* pInstance);
        static void Clean(TailsParamWaveCannon* pInstance);
    };
}

namespace heur::rfl {
    struct ModePackageTails : heur::rfl::ModePackage {
        heur::rfl::TailsParamFly tailsFly;
        heur::rfl::TailsParamSpanner spanner;
        heur::rfl::TailsParamCyBlaster cyBlaster;
        heur::rfl::TailsParamStomping stomping;
        heur::rfl::TailsParamCycloneBoost cycloneBoost;
        heur::rfl::TailsParamAirBoostCyclone airBoostCyclone;
        heur::rfl::TailsParamStepCyclone stepCyclone;
        heur::rfl::PlayerParamSpinBoost spinBoost;
        heur::rfl::TailsParamWaveCannon waveCannon;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ModePackageTails* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ModePackageTails* pInstance);
        static void Clean(ModePackageTails* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamAerialFinish {
        heur::rfl::PlayerParamAttackCollider hit;
        float ignoreSwingingTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamAerialFinish* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamAerialFinish* pInstance);
        static void Clean(PlayerParamAerialFinish* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamBehindFinish {
        heur::rfl::PlayerParamAttackCollider hit;
        float ignoreSwingingTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamBehindFinish* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamBehindFinish* pInstance);
        static void Clean(PlayerParamBehindFinish* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamLowAltitudeJump {
        float upSpeed;
        float frontSpeed;
        float damperV;
        float damperH;
        float gravity;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamLowAltitudeJump* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamLowAltitudeJump* pInstance);
        static void Clean(PlayerParamLowAltitudeJump* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamPursuitFinish {
        heur::rfl::PlayerParamAttackCollider hit;
        float ignoreSwingingTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamPursuitFinish* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamPursuitFinish* pInstance);
        static void Clean(PlayerParamPursuitFinish* pInstance);
    };
}

namespace heur::rfl {
    struct PlayerParamStompingFinish {
        heur::rfl::PlayerParamAttackCollider hit;
        float ignoreSwingingTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayerParamStompingFinish* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayerParamStompingFinish* pInstance);
        static void Clean(PlayerParamStompingFinish* pInstance);
    };
}

namespace heur::rfl {
    struct SonicParameters {
        heur::rfl::CommonPackageSonic common;
        heur::rfl::ModePackageSonic forwardView;
        heur::rfl::WaterModePackage water;
        heur::rfl::ModePackageSonic cyberspace;
        heur::rfl::ModePackageSonic cyberspaceSV;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SonicParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SonicParameters* pInstance);
        static void Clean(SonicParameters* pInstance);
    };
}

namespace heur::rfl {
    struct TailsParameters {
        heur::rfl::CommonPackageTails common;
        heur::rfl::ModePackageTails forwardView;
        heur::rfl::WaterModePackage water;
        heur::rfl::ModePackageTails cyberspaceSV;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TailsParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TailsParameters* pInstance);
        static void Clean(TailsParameters* pInstance);
    };
}

namespace heur::rfl {
    struct ScriptParameter {
        uint32_t intervalMinuntes;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ScriptParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ScriptParameter* pInstance);
        static void Clean(ScriptParameter* pInstance);
    };
}

namespace heur::rfl {
    struct TalkEventCameraPresetParameter {
        enum class GazePositionType : int8_t {
            Base = 0,
            Head = 1,
            Eye = 2,
            Center = 3,
        };

        bool enable;
        GazePositionType primaryTarget;
        GazePositionType secondaryTarget;
        float targetRatio;
        float rotateDegreePitch;
        float rotateDegreeYaw;
        float cameraOffsetRatio;
        float fovy;
        float targetOffsetX;
        float targetOffsetY;
        float targetOffsetZ;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TalkEventCameraPresetParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TalkEventCameraPresetParameter* pInstance);
        static void Clean(TalkEventCameraPresetParameter* pInstance);
    };
}

namespace heur::rfl {
    struct TalkEventCameraPresetParameters {
        heur::rfl::TalkEventCameraPresetParameter param[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(TalkEventCameraPresetParameters* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(TalkEventCameraPresetParameters* pInstance);
        static void Clean(TalkEventCameraPresetParameters* pInstance);
    };
}

namespace heur::rfl {
    struct AmbBaseNoiseParameter {
        csl::ut::VariableString cueName;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmbBaseNoiseParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmbBaseNoiseParameter* pInstance);
        static void Clean(AmbBaseNoiseParameter* pInstance);
    };
}

namespace heur::rfl {
    struct AmbInfo {
        csl::ut::VariableString cueName;
        float fadeInTime;
        float fadeOutTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmbInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmbInfo* pInstance);
        static void Clean(AmbInfo* pInstance);
    };
}

namespace heur::rfl {
    struct AmbNearPointParameter {
        csl::ut::VariableString cueName;
        float sensorRebootTime;
        float sensorRepositionTime;
        float lifeAreaRadius;
        float lifeTime;
        float fadeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmbNearPointParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmbNearPointParameter* pInstance);
        static void Clean(AmbNearPointParameter* pInstance);
    };
}

namespace heur::rfl {
    struct AmbRelativeWindParameter {
        csl::ut::VariableString cueName;
        float speedThreshold;
        float fadeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmbRelativeWindParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmbRelativeWindParameter* pInstance);
        static void Clean(AmbRelativeWindParameter* pInstance);
    };
}

namespace heur::rfl {
    struct AmbRiverParameter_Multiple3D {
        csl::ut::VariableString cueName;
        float attenuationDistance;
        float maxLevelPerPoint;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmbRiverParameter_Multiple3D* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmbRiverParameter_Multiple3D* pInstance);
        static void Clean(AmbRiverParameter_Multiple3D* pInstance);
    };
}

namespace heur::rfl {
    struct AmbRiverParameter_Nearest {
        csl::ut::VariableString cueName;
        float sensorRadius;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmbRiverParameter_Nearest* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmbRiverParameter_Nearest* pInstance);
        static void Clean(AmbRiverParameter_Nearest* pInstance);
    };
}

namespace heur::rfl {
    struct AmbSoundParameter {
        heur::rfl::AmbInfo ambSoundInfo[8];
        heur::rfl::AmbBaseNoiseParameter baseNoise;
        heur::rfl::AmbRelativeWindParameter relativeWind;
        heur::rfl::AmbNearPointParameter insect;
        heur::rfl::AmbNearPointParameter grass;
        heur::rfl::AmbRiverParameter_Nearest riverNearest;
        heur::rfl::AmbRiverParameter_Multiple3D riverMultiple3D;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AmbSoundParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AmbSoundParameter* pInstance);
        static void Clean(AmbSoundParameter* pInstance);
    };
}

namespace heur::rfl {
    struct AisacChangeInfo {
        float value;
        float fadeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AisacChangeInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AisacChangeInfo* pInstance);
        static void Clean(AisacChangeInfo* pInstance);
    };
}

namespace heur::rfl {
    struct AisacChangeInfoList {
        heur::rfl::AisacChangeInfo sunny;
        heur::rfl::AisacChangeInfo cloudy;
        heur::rfl::AisacChangeInfo rainy;
        heur::rfl::AisacChangeInfo beginUnderWater;
        heur::rfl::AisacChangeInfo finishUnderWater;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(AisacChangeInfoList* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(AisacChangeInfoList* pInstance);
        static void Clean(AisacChangeInfoList* pInstance);
    };
}

namespace heur::rfl {
    struct BGMInfo {
        enum class Priority : int8_t {
            PRIORITY_LOW = 0,
            PRIORITY_DEFAULT = 1,
            PRIORITY_HIGH = 2,
            PRIORITY_SUPER_HIGH = 3,
            NUM_PRIORITY = 4,
            PRIORITY_INVALID = -1,
        };

        enum class InterruptType : int8_t {
            INTERRUPT_TYPE_STOP = 0,
            INTERRUPT_TYPE_PAUSE = 1,
            INTERRUPT_TYPE_OVERLAP = 2,
            NUM_INTERRUPT_TYPE = 3,
        };

        csl::ut::VariableString cueName;
        int32_t blockId;
        float fadeInTime;
        float fadeOutTime;
        float delayTime;
        csl::ut::VariableString aisacName;
        float aisacValue;
        float aisacFadeTime;
        bool isVolumeControl;
        bool isOverlapPlay;
        Priority priority;
        InterruptType interruptType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BGMInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BGMInfo* pInstance);
        static void Clean(BGMInfo* pInstance);
    };
}

namespace heur::rfl {
    struct BGMTransitInfo {
        enum class InterruptType : int8_t {
            INTERRUPT_TYPE_STOP = 0,
            INTERRUPT_TYPE_PAUSE = 1,
            INTERRUPT_TYPE_OVERLAP = 2,
            NUM_INTERRUPT_TYPE = 3,
        };

        csl::ut::VariableString tagName;
        int32_t beforeId;
        int32_t beforeIdMax;
        int32_t afterId;
        InterruptType type;
        float fadeOutTime;
        float fadeInTime;
        float delayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BGMTransitInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BGMTransitInfo* pInstance);
        static void Clean(BGMTransitInfo* pInstance);
    };
}

namespace heur::rfl {
    struct BGMSceneInfo {
        csl::ut::VariableString sceneName;
        int32_t bgmId;
        bool disableSameBgmId;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BGMSceneInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BGMSceneInfo* pInstance);
        static void Clean(BGMSceneInfo* pInstance);
    };
}

namespace heur::rfl {
    struct BGMInfoParameter {
        heur::rfl::BGMInfo changeBgmInfo[32];
        heur::rfl::BGMTransitInfo transitBgmInfo[32];
        heur::rfl::BGMSceneInfo sceneBgmInfo[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BGMInfoParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BGMInfoParameter* pInstance);
        static void Clean(BGMInfoParameter* pInstance);
    };
}

namespace heur::rfl {
    struct BGMVolumeChangeInfo {
        float value;
        float delayTime;
        float fadeTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BGMVolumeChangeInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BGMVolumeChangeInfo* pInstance);
        static void Clean(BGMVolumeChangeInfo* pInstance);
    };
}

namespace heur::rfl {
    struct BGMVolumeChangeInfoList {
        heur::rfl::BGMVolumeChangeInfo playerStop;
        heur::rfl::BGMVolumeChangeInfo playerWalk;
        heur::rfl::BGMVolumeChangeInfo playerRun;
        heur::rfl::BGMVolumeChangeInfo fishingHitIn;
        heur::rfl::BGMVolumeChangeInfo fishingHitOut;
        heur::rfl::BGMVolumeChangeInfo musicBoxIn;
        heur::rfl::BGMVolumeChangeInfo musicBoxOut;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(BGMVolumeChangeInfoList* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(BGMVolumeChangeInfoList* pInstance);
        static void Clean(BGMVolumeChangeInfoList* pInstance);
    };
}

namespace heur::rfl {
    struct CustomMusicInfo {
        enum class MusicType : int8_t {
            THEME_SONG = 0,
            OTHER = 1,
        };

        csl::ut::VariableString cueName;
        float fadeOutTiming;
        bool lock;
        MusicType musicType;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CustomMusicInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CustomMusicInfo* pInstance);
        static void Clean(CustomMusicInfo* pInstance);
    };
}

namespace heur::rfl {
    struct CustomMusicTransitInfo {
        float fadeOutTime;
        float delayTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CustomMusicTransitInfo* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CustomMusicTransitInfo* pInstance);
        static void Clean(CustomMusicTransitInfo* pInstance);
    };
}

namespace heur::rfl {
    struct CustomMusicParameter {
        heur::rfl::CustomMusicTransitInfo transitInfo;
        heur::rfl::CustomMusicInfo musicInfos[128];
        float idlingViewTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CustomMusicParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CustomMusicParameter* pInstance);
        static void Clean(CustomMusicParameter* pInstance);
    };
}

namespace heur::rfl {
    struct SoundCommonParameter {
        float pauseFadeOutTime;
        float pauseFadeInTime;
        float enterCyberFadeOutTime;
        float leaveCyberResultFadeOutTime;
        heur::rfl::BGMVolumeChangeInfoList bgmVolumeInfo;
        heur::rfl::AisacChangeInfoList aisacInfo;
        heur::rfl::BGMInfo changeBgmInfo[128];
        heur::rfl::BGMTransitInfo transitBgmInfo[128];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(SoundCommonParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(SoundCommonParameter* pInstance);
        static void Clean(SoundCommonParameter* pInstance);
    };
}

namespace heur::rfl {
    struct LabelData {
        enum class DisplayType : int8_t {
            Caption = 0,
            Tutorial = 1,
        };

        DisplayType display;
        csl::ut::VariableString label;
        float waitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(LabelData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(LabelData* pInstance);
        static void Clean(LabelData* pInstance);
    };
}

namespace heur::rfl {
    struct Discussion {
        heur::rfl::LabelData labels[20];
        bool isForcePlay;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(Discussion* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(Discussion* pInstance);
        static void Clean(Discussion* pInstance);
    };
}

namespace heur::rfl {
    struct CaptionParameter {
        heur::rfl::Discussion discussions[10];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CaptionParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CaptionParameter* pInstance);
        static void Clean(CaptionParameter* pInstance);
    };
}

namespace heur::rfl {
    struct UICreditParameter {
        float LicenseInterval;
        float NameInterval;
        float PostInterval;
        float CompanyInterval;
        float LogoInterval;
        float WaitTime;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(UICreditParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(UICreditParameter* pInstance);
        static void Clean(UICreditParameter* pInstance);
    };
}

namespace heur::rfl {
    struct FishCameraParam {
        csl::math::Vector3 position;
        csl::math::Vector3 target;
        float fovy;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FishCameraParam* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FishCameraParam* pInstance);
        static void Clean(FishCameraParam* pInstance);
    };
}

namespace heur::rfl {
    struct UIFishiGuideConfig {
        heur::rfl::FishCameraParam fishList[105];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(UIFishiGuideConfig* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(UIFishiGuideConfig* pInstance);
        static void Clean(UIFishiGuideConfig* pInstance);
    };
}

namespace heur::rfl {
    struct UIWireframeParameter {
        csl::math::Vector3 camerapos;
        float lineAlpha;
        float noiseScale;
        float noiseSpeed;
        float moveWidth;
        hh::needle::FxDOFParameter dofparam;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(UIWireframeParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(UIWireframeParameter* pInstance);
        static void Clean(UIWireframeParameter* pInstance);
    };
}

namespace heur::rfl {
    struct ChallengeID1DimParameter {
        int32_t challengeID[40];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChallengeID1DimParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChallengeID1DimParameter* pInstance);
        static void Clean(ChallengeID1DimParameter* pInstance);
    };
}

namespace heur::rfl {
    struct IDColor {
        int32_t id;
        csl::ut::Color8 color;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IDColor* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IDColor* pInstance);
        static void Clean(IDColor* pInstance);
    };
}

namespace heur::rfl {
    struct IslandMapParameter {
        heur::rfl::ChallengeID1DimParameter challengeIDHorizonGridGroup[40];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IslandMapParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IslandMapParameter* pInstance);
        static void Clean(IslandMapParameter* pInstance);
    };
}

namespace heur::rfl {
    struct UIMapParameter {
        heur::rfl::IslandMapParameter islandMapParam[6];
        heur::rfl::IDColor idColors[264];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(UIMapParameter* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(UIMapParameter* pInstance);
        static void Clean(UIMapParameter* pInstance);
    };
}

namespace app::save {
    struct PlayLog {
        csl::ut::VariableString stagecode;
        csl::ut::VariableString play;
        csl::ut::VariableString option;
        csl::math::Vector3 position;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayLog* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayLog* pInstance);
        static void Clean(PlayLog* pInstance);
    };
}

namespace app::save {
    struct PlayStatsSummary {
        csl::ut::VariableString stagecode;
        int32_t highTime;
        int32_t highScore;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayStatsSummary* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayStatsSummary* pInstance);
        static void Clean(PlayStatsSummary* pInstance);
    };
}

namespace app::save {
    struct PlayStatsData {
        int32_t enemies;
        int32_t damages;
        int32_t misses;
        int32_t retry;
        int32_t restart;
        csl::ut::MoveArray<app::save::PlayLog> logs;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayStatsData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayStatsData* pInstance);
        static void Clean(PlayStatsData* pInstance);
    };
}

namespace app::save {
    struct PlayStats {
        csl::ut::VariableString username;
        csl::ut::VariableString time;
        csl::ut::MoveArray<app::save::PlayStatsSummary> summaries;
        app::save::PlayStatsData playLog;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayStats* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayStats* pInstance);
        static void Clean(PlayStats* pInstance);
    };
}

namespace app::save {
    struct ScoreAndRnakData {
        uint32_t hightScore;
        uint16_t rank;
        uint16_t padding0;
        uint32_t reserved0;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ScoreAndRnakData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ScoreAndRnakData* pInstance);
        static void Clean(ScoreAndRnakData* pInstance);
    };
}

namespace app::save {
    struct ActionChainStruct {
        app::save::ScoreAndRnakData hightState[200];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ActionChainStruct* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ActionChainStruct* pInstance);
        static void Clean(ActionChainStruct* pInstance);
    };
}

namespace app::save {
    struct HeaderData {
        enum class Status : int8_t {
            STATUS_ZERO_FILL = 0,
            STATUS_INITIALIZED = 1,
        };

        enum class Sequence : int8_t {
            Island1 = 0,
            Island2 = 1,
            Island3 = 2,
            Island4 = 3,
            Island5 = 4,
            FinalBossBefore = 5,
            FinalBossAfter = 6,
        };

        enum class SaveDataIcon : int8_t {
            IconNoData = 0,
            IconIsland1 = 1,
            IconIsland2 = 2,
            IconIsland3 = 3,
            IconIsland4 = 4,
            IconIsland5 = 5,
            IconLastBoss = 6,
            IconExtra = 7,
        };

        enum class AppVersion : uint8_t {
            AppVersion_1_10 = 0,
            AppVersion_1_20 = 1,
            AppVersion_1_30 = 2,
            AppVersion_1_40 = 3,
        };

        uint32_t signature;
        uint8_t version;
        Status status;
        uint8_t config;
        Sequence sequence;
        uint32_t playTime;
        SaveDataIcon icon;
        AppVersion appVersion;
        uint8_t config2;
        uint8_t reserved1;
        uint32_t saveDate;
        uint8_t index;
        uint32_t reserved[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(HeaderData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(HeaderData* pInstance);
        static void Clean(HeaderData* pInstance);
    };
}

namespace app::save {
    struct CyberStageData {
        uint16_t flags;
        uint32_t bestTime;
        uint32_t flags2;
        uint32_t reserved[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyberStageData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyberStageData* pInstance);
        static void Clean(CyberStageData* pInstance);
    };
}

namespace app::save {
    struct CyberStageContainerData {
        app::save::CyberStageData actStages[32];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CyberStageContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CyberStageContainerData* pInstance);
        static void Clean(CyberStageContainerData* pInstance);
    };
}

namespace app::save {
    struct ArcadeData {
        app::save::HeaderData header;
        bool unlocked;
        app::save::CyberStageContainerData stages;
        uint32_t reserved[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ArcadeData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ArcadeData* pInstance);
        static void Clean(ArcadeData* pInstance);
    };
}

namespace app::save {
    struct ChallengeBattleRushScoreData {
        uint32_t bestTime;
        uint32_t reserved0;
        uint32_t reserved1;
        uint32_t reserved2;
        uint32_t reserved3;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChallengeBattleRushScoreData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChallengeBattleRushScoreData* pInstance);
        static void Clean(ChallengeBattleRushScoreData* pInstance);
    };
}

namespace app::save {
    struct ChallengeBattleRushData {
        uint32_t status;
        app::save::ChallengeBattleRushScoreData scores[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChallengeBattleRushData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChallengeBattleRushData* pInstance);
        static void Clean(ChallengeBattleRushData* pInstance);
    };
}

namespace app::save {
    struct ChallengeBattleRushContainerData {
        app::save::ChallengeBattleRushData stages[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChallengeBattleRushContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChallengeBattleRushContainerData* pInstance);
        static void Clean(ChallengeBattleRushContainerData* pInstance);
    };
}

namespace app::save {
    struct ChallengeCyberStageData {
        enum class Value : int8_t {
            S = 0,
            A = 1,
            B = 2,
            C = 3,
            D = 4,
            Num = 5,
        };

        uint32_t status;
        uint32_t totalBestTime;
        Value totalBestRank;
        app::save::CyberStageContainerData stages;
        int32_t stageNos[32];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChallengeCyberStageData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChallengeCyberStageData* pInstance);
        static void Clean(ChallengeCyberStageData* pInstance);
    };
}

namespace app::save {
    struct ChallengeCyberStageContainerData {
        app::save::ChallengeCyberStageData stages[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChallengeCyberStageContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChallengeCyberStageContainerData* pInstance);
        static void Clean(ChallengeCyberStageContainerData* pInstance);
    };
}

namespace app::save {
    struct ChallengeData {
        app::save::HeaderData header;
        uint32_t status;
        app::save::ChallengeCyberStageContainerData cyberStage;
        app::save::ChallengeBattleRushContainerData battleRush;
        app::save::ChallengeBattleRushContainerData battleRushAll;
        uint32_t reserved0;
        uint32_t reserved1;
        uint32_t reserved2;
        uint32_t reserved3;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ChallengeData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ChallengeData* pInstance);
        static void Clean(ChallengeData* pInstance);
    };
}

namespace app::save {
    struct CharacterData {
        uint16_t numRings;
        uint8_t ringLevel;
        uint8_t speedLevel;
        uint8_t obtainChaosEmeralds;
        uint8_t hasChaosEmeralds;
        uint8_t skillLevel[30];
        uint8_t skillPointOld;
        uint8_t levelOld;
        uint16_t padding0;
        uint32_t expPoint;
        uint8_t powerLevel;
        uint8_t guardLevel;
        uint16_t boostGaugeLevel;
        uint32_t numPowerSeeds;
        uint32_t numGuardSeeds;
        uint16_t numFishCoins;
        uint16_t numFishTokens;
        uint16_t numGoldCards;
        uint16_t numSlotStars;
        float quickCyloopGauge;
        uint32_t practiceMaxCleared;
        uint32_t practiceMaxCombos;
        uint32_t flags;
        int16_t skillPoint;
        int16_t level;
        uint32_t dlcrsvExpPoint;
        uint32_t dlcrsvNumPowerSeeds;
        uint32_t dlcrsvNumGuardSeeds;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(CharacterData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(CharacterData* pInstance);
        static void Clean(CharacterData* pInstance);
    };
}

namespace app::save {
    struct ExtraCharacterData {
        uint32_t bossRushNumRings;
        float bossRushQuickCyloopGauge;
        uint32_t bossRushFlags;
        uint32_t reserved3;
        uint32_t reserved4;
        uint32_t reserved5;
        uint32_t reserved6;
        uint32_t reserved7;
        uint32_t reserved8;
        uint32_t reserved9;
        uint32_t reserved10;
        uint32_t reserved11;
        uint32_t reserved12;
        uint32_t reserved13;
        uint32_t reserved14;
        uint32_t reserved15;
        uint32_t reserved16;
        uint32_t reserved17;
        uint32_t reserved18;
        uint32_t reserved19;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtraCharacterData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtraCharacterData* pInstance);
        static void Clean(ExtraCharacterData* pInstance);
    };
}

namespace app::save {
    struct ExtraCharacterContainerData {
        app::save::CharacterData characters[3];
        app::save::ExtraCharacterData extras[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtraCharacterContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtraCharacterContainerData* pInstance);
        static void Clean(ExtraCharacterContainerData* pInstance);
    };
}

namespace app::save {
    struct ExtraCyberStageContainerData {
        app::save::CyberStageData actStages[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtraCyberStageContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtraCyberStageContainerData* pInstance);
        static void Clean(ExtraCyberStageContainerData* pInstance);
    };
}

namespace app::save {
    struct WorldFlagData {
        uint32_t bitFlags[1024];
        int8_t byteFlags[1024];
        uint32_t intDatas[512];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WorldFlagData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WorldFlagData* pInstance);
        static void Clean(WorldFlagData* pInstance);
    };
}

namespace app::save {
    struct ExtraFlagData {
        uint32_t bitFlags[512];
        int8_t byteFlags[512];
        uint32_t intDatas[256];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtraFlagData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtraFlagData* pInstance);
        static void Clean(ExtraFlagData* pInstance);
    };
}

namespace app::save {
    struct ExtraFlagContainerData {
        app::save::WorldFlagData worldData;
        app::save::ExtraFlagData extraData;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtraFlagContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtraFlagContainerData* pInstance);
        static void Clean(ExtraFlagContainerData* pInstance);
    };
}

namespace app::save {
    struct IslandMapGridData {
        uint8_t x;
        uint8_t y;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IslandMapGridData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IslandMapGridData* pInstance);
        static void Clean(IslandMapGridData* pInstance);
    };
}

namespace app::save {
    struct IslandMapData {
        app::save::IslandMapGridData grid[136];
        uint16_t numReleaseGrids;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IslandMapData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IslandMapData* pInstance);
        static void Clean(IslandMapData* pInstance);
    };
}

namespace app::save {
    struct IslandStageData {
        csl::math::Vector3 destination;
        uint32_t flags;
        app::save::IslandMapData map;
        uint32_t reserved[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IslandStageData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IslandStageData* pInstance);
        static void Clean(IslandStageData* pInstance);
    };
}

namespace app::save {
    struct ExtraIslandStageContainerData {
        app::save::IslandStageData islands[1];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ExtraIslandStageContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ExtraIslandStageContainerData* pInstance);
        static void Clean(ExtraIslandStageContainerData* pInstance);
    };
}

namespace app::save {
    struct FlagContainerData {
        uint32_t bitFlags[24];
        int8_t byteFlags[128];
        uint32_t intDatas[16];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(FlagContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(FlagContainerData* pInstance);
        static void Clean(FlagContainerData* pInstance);
    };
}

namespace app::save {
    struct GamePlayData {
        enum class Status : int8_t {
            STATUS_NEWGAME = 0,
            STATUS_CONTINUE = 1,
        };

        enum class SequenceDeprecated : int8_t {
            Island1 = 0,
            Island2 = 1,
            Island3 = 2,
            Island4 = 3,
            Island5 = 4,
            FinalBossBefore = 5,
            FinalBossAfter = 6,
        };

        Status status;
        int8_t lastPlayedStageNo;
        uint8_t flags;
        SequenceDeprecated sequence;
        csl::math::Vector3 position;
        csl::math::Quaternion rotation;
        uint32_t day;
        uint32_t hour;
        uint32_t minute;
        float second;
        uint8_t character;
        uint8_t reserved0;
        uint16_t reserved1;
        uint32_t reserved[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GamePlayData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GamePlayData* pInstance);
        static void Clean(GamePlayData* pInstance);
    };
}

namespace app::save {
    struct IslandStageContainerData {
        app::save::IslandStageData islands[5];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(IslandStageContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(IslandStageContainerData* pInstance);
        static void Clean(IslandStageContainerData* pInstance);
    };
}

namespace app::save {
    struct WorldFlagContainerData {
        app::save::WorldFlagData worldDatas[5];
        app::save::WorldFlagData debugWorldData;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WorldFlagContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WorldFlagContainerData* pInstance);
        static void Clean(WorldFlagContainerData* pInstance);
    };
}

namespace app::save {
    struct ReservedData {
        uint8_t reserved[601552];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(ReservedData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(ReservedData* pInstance);
        static void Clean(ReservedData* pInstance);
    };
}

namespace app::save {
    struct StatValue {
        int32_t value;
        bool assigned;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StatValue* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StatValue* pInstance);
        static void Clean(StatValue* pInstance);
    };
}

namespace app::save {
    struct StatsContainerData {
        app::save::StatValue stats[3393];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(StatsContainerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(StatsContainerData* pInstance);
        static void Clean(StatsContainerData* pInstance);
    };
}

namespace app::save {
    struct WeatherTimerData {
        float duration;
        float time;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherTimerData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherTimerData* pInstance);
        static void Clean(WeatherTimerData* pInstance);
    };
}

namespace app::save {
    struct WeatherBlockData {
        enum class Type : int8_t {
            Sunny = 0,
            Cloudy = 1,
            Rainy = 2,
            SandStorm = 3,
            MeteorShower = 4,
            Num = 5,
        };

        enum class Status : int8_t {
            None = 0,
            Wait = 1,
            Active = 2,
            External = 3,
        };

        Type weather;
        uint32_t hour;
        uint32_t minute;
        float second;
        Status status;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherBlockData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherBlockData* pInstance);
        static void Clean(WeatherBlockData* pInstance);
    };
}

namespace app::save {
    struct WeatherData {
        enum class Type : int8_t {
            Sunny = 0,
            Cloudy = 1,
            Rainy = 2,
            SandStorm = 3,
            MeteorShower = 4,
            Num = 5,
        };

        Type currentWeather;
        Type prevWeather;
        app::save::WeatherTimerData timer;
        app::save::WeatherBlockData block;
        int32_t stageNo;
        uint32_t reserved[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(WeatherData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(WeatherData* pInstance);
        static void Clean(WeatherData* pInstance);
    };
}

namespace app::save {
    struct GameData {
        app::save::HeaderData header;
        app::save::GamePlayData gameplay;
        app::save::CharacterData character;
        app::save::IslandStageContainerData islands;
        app::save::CyberStageContainerData stages;
        app::save::FlagContainerData flags;
        app::save::WorldFlagContainerData worldFlags;
        app::save::ExtraFlagContainerData extraFlags;
        app::save::ActionChainStruct actionChain;
        app::save::ExtraCharacterContainerData extraCharacters;
        app::save::ExtraCyberStageContainerData extraStages;
        app::save::ExtraIslandStageContainerData extraIslands;
        app::save::ReservedData reserved;
        app::save::StatsContainerData stats;
        app::save::WeatherData weather;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameData* pInstance);
        static void Clean(GameData* pInstance);
    };
}

namespace app::save {
    struct PlayLogCoordData {
        uint16_t time;
        uint16_t x;
        uint16_t z;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayLogCoordData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayLogCoordData* pInstance);
        static void Clean(PlayLogCoordData* pInstance);
    };
}

namespace app::save {
    struct PlayLogEventData {
        enum class EventType : int8_t {
            InvalidEvent = -1,
            Dead = 0,
            BeginStage = 1,
            EndStage = 2,
            ReleaseLightPillar = 3,
            ObtainChaosEmerald = 4,
            ContactMiniboss = 5,
            DefeatMiniboss = 6,
            BeginCyberStage = 7,
            EndCyberStage = 8,
            CompleteCyberStage = 9,
            RestartCyberStage = 10,
            GiveupCyberStage = 11,
            OpenTreasureChest = 12,
            AccessRingSensor = 13,
        };

        app::save::PlayLogCoordData coord;
        EventType eventType;
        int8_t option;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayLogEventData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayLogEventData* pInstance);
        static void Clean(PlayLogEventData* pInstance);
    };
}

namespace app::save {
    struct PlayLogData {
        uint32_t numFootMarks;
        uint32_t footMarksIndex;
        app::save::PlayLogCoordData footmarks[36000];
        uint32_t numEvents;
        uint32_t eventsIndex;
        app::save::PlayLogEventData events[50000];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(PlayLogData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(PlayLogData* pInstance);
        static void Clean(PlayLogData* pInstance);
    };
}

namespace app::save {
    struct GameDataInPlayLog {
        app::save::HeaderData header;
        app::save::GamePlayData gameplay;
        app::save::CharacterData character;
        app::save::IslandStageContainerData islands;
        app::save::CyberStageContainerData stages;
        app::save::FlagContainerData flags;
        app::save::WorldFlagContainerData worldFlags;
        app::save::PlayLogData playlog;
        app::save::StatsContainerData stats;
        app::save::WeatherData weather;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(GameDataInPlayLog* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(GameDataInPlayLog* pInstance);
        static void Clean(GameDataInPlayLog* pInstance);
    };
}

namespace app::save {
    struct OptionAudioData {
        enum class MusicSelect : int8_t {
            MUSIC_SELECT_ON = 0,
            MUSIC_SELECT_OFF = 1,
        };

        enum class MusicSelectType : int8_t {
            MUSIC_SELECT_NORMAL = 0,
            MUSIC_SELECT_SHUFFLE = 1,
            MUSIC_SELECT_LOOP = 2,
        };

        uint8_t masterVolume;
        uint8_t sfxVolume;
        uint8_t musicVolume;
        uint8_t voiceVolume;
        MusicSelect musicSelectEnable;
        MusicSelectType musicSelectType;
        uint8_t flags;
        uint8_t padding[1];
        uint32_t reserved[3];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OptionAudioData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OptionAudioData* pInstance);
        static void Clean(OptionAudioData* pInstance);
    };
}

namespace app::save {
    struct OptionCameraData {
        enum class MovementStyle : int8_t {
            PadSimulate = 0,
            Aiming = 1,
        };

        float rotateSpeedPad;
        float rotateSpeedVertMouse;
        float rotateSpeedHorzMouse;
        float reticleSpeedPad;
        float reticleSpeedVertMouse;
        float reticleSpeedHorzMouse;
        uint8_t rotateSpeedRate;
        uint8_t distanceRate;
        uint8_t fovyRate;
        MovementStyle movementStyle;
        uint8_t config;
        uint32_t reserved[4];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OptionCameraData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OptionCameraData* pInstance);
        static void Clean(OptionCameraData* pInstance);
    };
}

namespace app::save {
    struct OptionControlsData {
        enum class InputKey : int32_t {
            Invalid = -1,
            GamePad_DPadLeft = 0,
            GamePad_DPadRight = 1,
            GamePad_DPadUp = 2,
            GamePad_DPadDown = 3,
            GamePad_ButtonLeft = 4,
            GamePad_ButtonRight = 5,
            GamePad_ButtonTop = 6,
            GamePad_ButtonBottom = 7,
            GamePad_LeftX = 8,
            GamePad_LeftY = 9,
            GamePad_RightX = 10,
            GamePad_RightY = 11,
            GamePad_LeftShoulder = 12,
            GamePad_LeftTrigger = 13,
            GamePad_LeftClick = 14,
            GamePad_RightShoulder = 15,
            GamePad_RightTrigger = 16,
            GamePad_RightClick = 17,
            GamePad_LeftStickLeft = 18,
            GamePad_LeftStickRight = 19,
            GamePad_LeftStickUp = 20,
            GamePad_LeftStickDown = 21,
            GamePad_RightStickLeft = 22,
            GamePad_RightStickRight = 23,
            GamePad_RightStickUp = 24,
            GamePad_RightStickDown = 25,
            GamePad_Start = 26,
            GamePad_Select = 27,
            GamePad_LeftSideTriggerLeft = 28,
            GamePad_LeftSideTriggerRight = 29,
            GamePad_RightSideTriggerLeft = 30,
            GamePad_RightSideTriggerRight = 31,
            Keyboard_Nop = 32,
            Keyboard_A = 33,
            Keyboard_B = 34,
            Keyboard_C = 35,
            Keyboard_D = 36,
            Keyboard_E = 37,
            Keyboard_F = 38,
            Keyboard_G = 39,
            Keyboard_H = 40,
            Keyboard_I = 41,
            Keyboard_J = 42,
            Keyboard_K = 43,
            Keyboard_L = 44,
            Keyboard_M = 45,
            Keyboard_N = 46,
            Keyboard_O = 47,
            Keyboard_P = 48,
            Keyboard_Q = 49,
            Keyboard_R = 50,
            Keyboard_S = 51,
            Keyboard_T = 52,
            Keyboard_U = 53,
            Keyboard_V = 54,
            Keyboard_W = 55,
            Keyboard_X = 56,
            Keyboard_Y = 57,
            Keyboard_Z = 58,
            Keyboard_1 = 59,
            Keyboard_2 = 60,
            Keyboard_3 = 61,
            Keyboard_4 = 62,
            Keyboard_5 = 63,
            Keyboard_6 = 64,
            Keyboard_7 = 65,
            Keyboard_8 = 66,
            Keyboard_9 = 67,
            Keyboard_0 = 68,
            Keyboard_Enter = 69,
            Keyboard_Escape = 70,
            Keyboard_BackSpace = 71,
            Keyboard_Tab = 72,
            Keyboard_Spacebar = 73,
            Keyboard_Minus = 74,
            Keyboard_Accent = 75,
            Keyboard_Atmark = 76,
            Keyboard_LeftBracket = 77,
            Keyboard_BackSlash = 78,
            Keyboard_RightBracket = 79,
            Keyboard_SemiColon = 80,
            Keyboard_Colon = 81,
            Keyboard_Comma = 82,
            Keyboard_Period = 83,
            Keyboard_Slash = 84,
            Keyboard_CapsLock = 85,
            Keyboard_F1 = 86,
            Keyboard_F2 = 87,
            Keyboard_F3 = 88,
            Keyboard_F4 = 89,
            Keyboard_F5 = 90,
            Keyboard_F6 = 91,
            Keyboard_F7 = 92,
            Keyboard_F8 = 93,
            Keyboard_F9 = 94,
            Keyboard_F10 = 95,
            Keyboard_F11 = 96,
            Keyboard_F12 = 97,
            Keyboard_Insert = 98,
            Keyboard_Home = 99,
            Keyboard_PageUp = 100,
            Keyboard_Delete = 101,
            Keyboard_End = 102,
            Keyboard_PageDown = 103,
            Keyboard_LeftArrow = 104,
            Keyboard_RightArrow = 105,
            Keyboard_UpArrow = 106,
            Keyboard_DownArrow = 107,
            Keyboard_PadSlash = 108,
            Keyboard_PadAsterisk = 109,
            Keyboard_PadMinus = 110,
            Keyboard_PadPlus = 111,
            Keyboard_PadEnter = 112,
            Keyboard_PadNum1 = 113,
            Keyboard_PadNum2 = 114,
            Keyboard_PadNum3 = 115,
            Keyboard_PadNum4 = 116,
            Keyboard_PadNum5 = 117,
            Keyboard_PadNum6 = 118,
            Keyboard_PadNum7 = 119,
            Keyboard_PadNum8 = 120,
            Keyboard_PadNum9 = 121,
            Keyboard_PadNum0 = 122,
            Keyboard_PadPeriod = 123,
            Keyboard_LeftCtrl = 124,
            Keyboard_RightCtrl = 125,
            Keyboard_LeftShift = 126,
            Keyboard_RightShift = 127,
            Keyboard_LeftAlt = 128,
            Keyboard_RightAlt = 129,
            Keyboard_LeftGui = 130,
            Keyboard_RightGui = 131,
            Mouse_X = 132,
            Mouse_Y = 133,
            Mouse_ButtonLeft = 134,
            Mouse_ButtonRight = 135,
            Mouse_ButtonMiddle = 136,
            Mouse_ButtonX1 = 137,
            Mouse_ButtonX2 = 138,
            Mouse_Wheel = 139,
            Mouse_WheelUp = 140,
            Mouse_WheelDown = 141,
            Keyboard_Grave = 142,
            Keyboard_Equals = 143,
            Keyboard_Apostrophe = 144,
            Keyboard_OEM_102 = 145,
            Keyboard_ABNT_C1 = 146,
            Keyboard_ABNT_C2 = 147,
            Keyboard_Shift = 148,
            Keyboard_Ctrl = 149,
            NumAppKeys = 150,
        };

        InputKey padMappings[62];
        InputKey mainMappings[62];
        InputKey subMappings[62];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OptionControlsData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OptionControlsData* pInstance);
        static void Clean(OptionControlsData* pInstance);
    };
}

namespace app::save {
    struct OptionGamePlayData {
        enum class VoiceLanguageType : int8_t {
            VOICE_LANGUAGE_ENGLISH = 0,
            VOICE_LANGUAGE_FRENCH = 1,
            VOICE_LANGUAGE_ITALIAN = 2,
            VOICE_LANGUAGE_GERMAN = 3,
            VOICE_LANGUAGE_SPANISH = 4,
            VOICE_LANGUAGE_JAPANESE = 5,
            NUM_VOICE_LANGUAGES = 6,
        };

        enum class LanguageType : int8_t {
            LANGUAGE_ENGLISH = 0,
            LANGUAGE_FRENCH = 1,
            LANGUAGE_ITALIAN = 2,
            LANGUAGE_GERMAN = 3,
            LANGUAGE_SPANISH = 4,
            LANGUAGE_POLISH = 5,
            LANGUAGE_PORTUGUESE = 6,
            LANGUAGE_RUSSIAN = 7,
            LANGUAGE_JAPANESE = 8,
            LANGUAGE_ZHONGWEN = 9,
            LANGUAGE_ZHONGWEN_S = 10,
            LANGUAGE_KOREAN = 11,
            NUM_LANGUAGES = 12,
        };

        enum class VibrationLevel : int8_t {
            None = 0,
            Low = 1,
            Medium = 2,
            High = 3,
        };

        enum class Value : int8_t {
            Easy = 0,
            Normal = 1,
            Hard = 2,
            Num = 3,
            VeryHard = 3,
            NumInVeryHard = 4,
        };

        uint8_t initialSpeedRate;
        uint8_t boostInitialSpeedRate;
        uint8_t acceleRate;
        uint8_t maxSpeedRate;
        uint8_t minTurnSpeedRate;
        uint8_t boostMinTurnSpeedRate;
        uint8_t rotateForceRate;
        uint8_t bumpJumpGravityRate;
        VoiceLanguageType speech;
        LanguageType text;
        VibrationLevel vibrationLevel;
        Value diffculty;
        uint8_t config;
        uint8_t padSensibilityRate;
        uint8_t mouseSensibilityRate;
        uint8_t neutralDecelerationRate;
        uint8_t dlcSonicCostume;
        uint8_t dlcKodamaModel;
        uint8_t dlcRingSE;
        uint8_t dlcConfig;
        uint8_t config2;
        uint8_t islandVisual;
        uint8_t npcVisual;
        uint8_t baseAirDragScaleRate;
        uint32_t status;
        uint32_t reserved2[1];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OptionGamePlayData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OptionGamePlayData* pInstance);
        static void Clean(OptionGamePlayData* pInstance);
    };
}

namespace app::save {
    struct OptionGraphicsData {
        enum class Resolution : int8_t {
            Reso3840x2160 = 0,
            Reso2560x1440 = 1,
            Reso1920x1080 = 2,
            Reso1280x720 = 3,
        };

        enum class GraphicQuality : int8_t {
            High = 0,
            Low = 1,
            Custom = 2,
        };

        enum class FrameRate : int8_t {
            FPS60 = 0,
            FPS30 = 1,
            FPSNoLimit = 2,
        };

        enum class AntiAliasing : int8_t {
            TAA = 0,
            FXAA = 1,
            None = 2,
        };

        enum class AnisotropicFiltering : int8_t {
            None = 0,
            Low = 1,
            Medium = 2,
            High = 3,
        };

        enum class DOF : int8_t {
            Disabled = 0,
            Low = 1,
            Medium = 2,
            High = 3,
        };

        enum class Bloom : int8_t {
            High = 0,
            Low = 1,
        };

        enum class Shadow : int8_t {
            High = 0,
            Low = 1,
        };

        enum class VolumetricLight : int8_t {
            High = 0,
            Low = 1,
        };

        enum class RederingScale : int8_t {
            High = 0,
            Medium = 1,
            Low = 2,
        };

        Resolution resolution;
        GraphicQuality graphicQuality;
        FrameRate frameRate;
        uint8_t brightness;
        AntiAliasing antiAliasing;
        AnisotropicFiltering anisotropicFiltering;
        DOF depthOfField;
        Bloom bloom;
        uint8_t config;
        uint8_t hudVisible;
        Shadow shadow;
        VolumetricLight volumetricLight;
        RederingScale renderingScale;
        uint8_t reserved1[1];
        uint16_t width;
        uint16_t height;
        uint16_t padding0;
        uint32_t reserved[2];

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OptionGraphicsData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OptionGraphicsData* pInstance);
        static void Clean(OptionGraphicsData* pInstance);
    };
}

namespace app::save {
    struct OptionData {
        app::save::HeaderData header;
        app::save::OptionGamePlayData gameplay;
        app::save::OptionControlsData controls;
        app::save::OptionCameraData camera;
        app::save::OptionAudioData audio;
        app::save::OptionGraphicsData graphics;

        static const hh::fnd::RflTypeInfo typeInfo;
        static const hh::fnd::RflClass rflClass;
    private:
        static void Construct(OptionData* pInstance, csl::fnd::IAllocator* pAllocator);
        static void Finish(OptionData* pInstance);
        static void Clean(OptionData* pInstance);
    };
}

